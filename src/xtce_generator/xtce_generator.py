from xml.etree import ElementTree as ET
import src.xtce_generator.xtce as xtce
import argparse
import sqlite3
import logging
from enum import Enum


# TODO:Implementation to enable nesting of spacesystems beyond root+1
# class NameSpace(xtce.SpaceSystemType):
#     def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
#                  operationalStatus=None, base=None, Header=None, TelemetryMetaData=None, CommandMetaData=None,
#                  ServiceSet=None, SpaceSystem=None, gds_collector_=None, **kwargs_):
#         super(NameSpace, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
#                                         operationalStatus, base, Header, TelemetryMetaData,
#                                         CommandMetaData,
#                                         ServiceSet, SpaceSystem, gds_collector_,**kwargs_)
#         self.__namespace_dict = dict({name: super(NameSpace, self).get_SpaceSystem()}) if name else dict({})
#
#     def __getitem__(self, key: str):




class BaseType(int, Enum):
    """
    Used by XTCEManager to distinguish what kind of argument or parameter types to add to Space Systems.
    This is especially useful for adding base(or intrinsic) types to a space system.
    """
    INTEGER = 0
    STRUCT = 1
    STRING = 2


class XTCEManager:
    UNKNOWN_TYPE = 'UNKNOWN'  # A type for anything that, for some reason, we don't understand from the database

    def __init__(self, root_space_system: str, file_path: str, sqlite_path: str):
        """
        Instantiates a XTCEManager instance. An XTCEManager is a class that manages an xtce class internally
        and provides utilities such as serialization tools(through the write_to_file method) and functionality
        to add namespaces, BaseType, etc to our root spacesystem. It reads all data(except for base types)
        from the sqlite database at sqlite_path. Beware that the database is assumed to have been generated by
        our juicer tool. You can check out juicer here[1]
        [1]:https://github.com/WindhoverLabs/juicer
        :param root_space_system:
        :param file_path:
        """
        self.root = xtce.SpaceSystemType(name=root_space_system)
        self.telemetry_metadata = xtce.TelemetryMetaDataType()
        self.command_metadata = xtce.CommandMetaDataType()
        self.paramter_type_set = xtce.ParameterTypeSetType()
        self.argument_type_set = xtce.ArgumentTypeSetType()
        self.output_file = open(file_path + '.xml', 'w+')

        self.telemetry_metadata.set_ParameterTypeSet(self.paramter_type_set)
        self.command_metadata.set_ArgumentTypeSet(self.argument_type_set)

        self.root.set_TelemetryMetaData(self.telemetry_metadata)
        self.root.set_CommandMetaData(self.command_metadata)

        self.__namespace_dict = dict({root_space_system: self.root})

        db_handle = sqlite3.connect(sqlite_path)

        self.db_cursor = db_handle.cursor()

        self.base_type_namespace = 'BaseType'

    def __get_endianness(self, bit_size: int, little_endian: bool):
        endianness = '_LE' if little_endian else '_BE'
        return endianness

    def __get_int_argtype(self, bit_size: int, little_endian: bool) -> xtce.IntegerDataType:
        """
        Factory function to construct a IntegerArgumentType.
        :param bit_size:
        :param little_endian:
        :return:
        """
        endianness = self.__get_endianness(bit_size, little_endian)

        base_type_name = 'int' + str(bit_size) + endianness

        arg_type = xtce.IntegerArgumentType(name=base_type_name, signed=True)

        bit_order = xtce.BitOrderType.LEAST_SIGNIFICANT_BIT_FIRST if little_endian else \
            xtce.BitOrderType.MOST_SIGNIFICANT_BIT_FIRST

        byte_order = xtce.ByteOrderCommonType.LEAST_SIGNIFICANT_BYTE_FIRST if little_endian else \
            xtce.ByteOrderCommonType.MOST_SIGNIFICANT_BYTE_FIRST

        if bit_size > 8:
            base_type_data_encoding = xtce.IntegerDataEncodingType(sizeInBits=bit_size,
                                                                   bitOrder=bit_order,
                                                                   byteOrder=byte_order,
                                                                   encoding=xtce.IntegerEncodingType.TWOS_COMPLEMENT
                                                                   )
        else:
            base_type_data_encoding = xtce.IntegerDataEncodingType(sizeInBits=bit_size,
                                                                   bitOrder=bit_order,
                                                                   encoding=xtce.IntegerEncodingType.TWOS_COMPLEMENT
                                                                   )

        arg_type.set_IntegerDataEncoding(base_type_data_encoding)

        return arg_type

    def __get_uint_argtype(self, bit_size: int, little_endian: bool) -> xtce.IntegerDataType:
        """
        Factory function to construct a IntegerArgumentType.
        :param bit_size:
        :param little_endian:
        :return:
        """
        endianness = self.__get_endianness(bit_size, little_endian)

        base_type_name = 'uint' + str(bit_size) + endianness

        arg_type = xtce.IntegerArgumentType(name=base_type_name, signed=False)
        bit_order = xtce.BitOrderType.LEAST_SIGNIFICANT_BIT_FIRST if little_endian else \
            xtce.BitOrderType.MOST_SIGNIFICANT_BIT_FIRST

        byte_order = xtce.ByteOrderCommonType.LEAST_SIGNIFICANT_BYTE_FIRST if little_endian else \
            xtce.ByteOrderCommonType.MOST_SIGNIFICANT_BYTE_FIRST

        if bit_size > 8:
            base_type_data_encoding = xtce.IntegerDataEncodingType(sizeInBits=bit_size,
                                                                   bitOrder=bit_order,
                                                                   byteOrder=byte_order,
                                                                   encoding=xtce.IntegerEncodingType.UNSIGNED
                                                                   )
        else:
            base_type_data_encoding = xtce.IntegerDataEncodingType(sizeInBits=bit_size,
                                                                   bitOrder=bit_order,
                                                                   encoding=xtce.IntegerEncodingType.UNSIGNED
                                                                   )

        arg_type.set_IntegerDataEncoding(base_type_data_encoding)

        return arg_type

    def __get_float_argtype(self, bit_size: int, little_endian: bool) -> xtce.FloatDataType:
        """
        Factory function to construct a IntegerParameterType.
        :param bit_size:
        :param little_endian:
        :return:
        """
        endianness = self.__get_endianness(bit_size, little_endian)

        base_type_name = 'float' + str(bit_size) + endianness

        bit_order = xtce.BitOrderType.LEAST_SIGNIFICANT_BIT_FIRST if little_endian else \
            xtce.BitOrderType.MOST_SIGNIFICANT_BIT_FIRST

        byte_order = xtce.ByteOrderCommonType.LEAST_SIGNIFICANT_BYTE_FIRST if little_endian else \
            xtce.ByteOrderCommonType.MOST_SIGNIFICANT_BYTE_FIRST

        if bit_size > 8:
            encoding = xtce.FloatDataEncodingType(sizeInBits=str(bit_size),
                                                  bitOrder=bit_order,
                                                  byteOrder=byte_order)
        else:
            encoding = xtce.FloatDataEncodingType(sizeInBits=str(bit_size),
                                                  bitOrder=bit_order)

        param_type = xtce.FloatArgumentType(name=base_type_name, sizeInBits=str(bit_size))
        param_type.set_FloatDataEncoding(encoding)

        return param_type

    def __get_int_paramtype(self, bit_size: int, little_endian: bool) -> xtce.IntegerDataType:
        """
        Factory function to construct a IntegerParameterType.
        :param bit_size:
        :param little_endian:
        :return:
        """
        endianness = self.__get_endianness(bit_size, little_endian)

        base_type_name = 'int' + str(bit_size) + endianness

        param_type = xtce.IntegerParameterType(name=base_type_name, signed=True)

        bit_size = bit_size
        bit_order = xtce.BitOrderType.LEAST_SIGNIFICANT_BIT_FIRST if little_endian else \
            xtce.BitOrderType.MOST_SIGNIFICANT_BIT_FIRST

        byte_order = xtce.ByteOrderCommonType.LEAST_SIGNIFICANT_BYTE_FIRST if little_endian else \
            xtce.ByteOrderCommonType.MOST_SIGNIFICANT_BYTE_FIRST

        if bit_size > 8:
            base_type_data_encoding = xtce.IntegerDataEncodingType(sizeInBits=bit_size,
                                                                   bitOrder=bit_order,
                                                                   byteOrder=byte_order,
                                                                   encoding=xtce.IntegerEncodingType.TWOS_COMPLEMENT
                                                                   )
        else:
            base_type_data_encoding = xtce.IntegerDataEncodingType(sizeInBits=bit_size,
                                                                   bitOrder=bit_order,
                                                                   encoding=xtce.IntegerEncodingType.TWOS_COMPLEMENT
                                                                   )

        param_type.set_IntegerDataEncoding(base_type_data_encoding)

        return param_type

    def __get_uint_paramtype(self, bit_size: int, little_endian: bool) -> xtce.IntegerDataType:
        """
        Factory function to construct a IntegerParameterType.
        :param bit_size:
        :param little_endian:
        :return:
        """
        endianness = self.__get_endianness(bit_size, little_endian)

        base_type_name = 'uint' + str(bit_size) + endianness

        param_type = xtce.IntegerParameterType(name=base_type_name, signed=False, sizeInBits=bit_size)

        bit_order = xtce.BitOrderType.LEAST_SIGNIFICANT_BIT_FIRST if little_endian else \
            xtce.BitOrderType.MOST_SIGNIFICANT_BIT_FIRST

        byte_order = xtce.ByteOrderCommonType.LEAST_SIGNIFICANT_BYTE_FIRST if little_endian else \
            xtce.ByteOrderCommonType.MOST_SIGNIFICANT_BYTE_FIRST

        if bit_size > 8:
            base_type_data_encoding = xtce.IntegerDataEncodingType(sizeInBits=bit_size,
                                                                   bitOrder=bit_order,
                                                                   byteOrder=byte_order,
                                                                   encoding=xtce.IntegerEncodingType.UNSIGNED
                                                                   )
        else:
            base_type_data_encoding = xtce.IntegerDataEncodingType(sizeInBits=bit_size,
                                                                   bitOrder=bit_order,
                                                                   encoding=xtce.IntegerEncodingType.UNSIGNED
                                                                   )

        param_type.set_IntegerDataEncoding(base_type_data_encoding)

        return param_type

    def __get_float_paramtype(self, bit_size: int, little_endian: bool) -> xtce.FloatDataType:
        """
        Factory function to construct a IntegerParameterType.
        :param bit_size:
        :param little_endian:
        :return:
        """
        endianness = self.__get_endianness(bit_size, little_endian)

        base_type_name = 'float' + str(bit_size) + endianness

        bit_order = xtce.BitOrderType.LEAST_SIGNIFICANT_BIT_FIRST if little_endian else \
            xtce.BitOrderType.MOST_SIGNIFICANT_BIT_FIRST

        byte_order = xtce.ByteOrderCommonType.LEAST_SIGNIFICANT_BYTE_FIRST if little_endian else \
            xtce.ByteOrderCommonType.MOST_SIGNIFICANT_BYTE_FIRST

        if bit_size > 8:
            encoding = xtce.FloatDataEncodingType(sizeInBits=str(bit_size),
                                                  bitOrder=bit_order,
                                                  byteOrder=byte_order)
        else:
            encoding = xtce.FloatDataEncodingType(sizeInBits=str(bit_size),
                                                  bitOrder=bit_order)

        param_type = xtce.FloatParameterType(name=base_type_name, sizeInBits=str(bit_size))
        param_type.set_FloatDataEncoding(encoding)

        return param_type

    def __add_telemetry_base_types(self):
        """
        Adds all supported base types for our ground system to the TelemetryMetaData element of
        the namespace 'BaseType', which is created to hold all of the base types. Base types are the types tha are not
        user-defined such as int16, int32, etc. Check our docs for more details on base types. Please note that these
        base types are stored as *ParameterTypes on the xtce.
        :return:
        """
        base_set = xtce.ParameterTypeSetType()
        base_space_system = self[self.base_type_namespace]
        # base_space_system.set_TelemetryMetaData(xtce.TelemetryMetaDataType())

        # Add int types
        for bit in range(1, 65):
            if bit > 1:
                base_set.add_IntegerParameterType(self.__get_int_paramtype(bit, True))
                base_set.add_IntegerParameterType(self.__get_int_paramtype(bit, False))

            base_set.add_IntegerParameterType(self.__get_uint_paramtype(bit, True))
            base_set.add_IntegerParameterType(self.__get_uint_paramtype(bit, False))

        # NOTE: For right now, only singed 32-bit floating types are supported
        # Add floating types
        base_set.add_FloatParameterType(self.__get_float_paramtype(32, True))
        base_set.add_FloatParameterType(self.__get_float_paramtype(32, False))
        base_set.add_IntegerParameterType(
            xtce.IntegerParameterType(name=XTCEManager.UNKNOWN_TYPE, signed=False, sizeInBits='32'))
        base_set.add_BooleanParameterType(xtce.BooleanParameterType(name='boolean8_LE'))

        # Add char types
        # #FIXME: We have to decide what to do about strings
        # for bit in range(1, 160):
        #     # Add big Endian
        #     base_type_name = 'char' + str(bit)
        #     param_type = xtce.StringParameterType(name=base_type_name, signed=True)
        #     bit_size = bit
        #
        #     base_type_data_encoding = xtce.StringDataEncodingType(
        #         byteOrder=xtce.ByteOrderCommonType.MOST_SIGNIFICANT_BYTE_FIRST
        #         if bit < 8
        #         else xtce.ByteOrderCommonType.LEAST_SIGNIFICANT_BYTE_FIRST,
        #         SizeInBits=xtce.SizeInBitsType(Fixed=xtce.FixedType(FixedValue=bit)))
        #
        #     param_type.set_StringDataEncoding(base_type_data_encoding)
        #
        #     base_set.add_IntegerParameterType(param_type)

        base_space_system.get_TelemetryMetaData().set_ParameterTypeSet(base_set)

    def __add_commands_base_types(self):
        """
        Adds all supported base types for our ground system to the CommandMetaData element of
        the namespace 'BaseType', which is created to hold all of the base types. Base types are the types tha are not
        user-defined such as int16, int32, etc. Check our docs for more details on base types. Please note that these
        base types are stored as *ArgumentTypes on the xtce.
        :return:
        """
        base_set = xtce.ArgumentTypeSetType()
        base_space_system = self[self.base_type_namespace]
        # base_space_system.set_CommandMetaData(xtce.CommandMetaDataType())

        # Add int types
        for bit in range(1, 65):
            if bit > 1:
                base_set.add_IntegerArgumentType(self.__get_int_argtype(bit, True))
                base_set.add_IntegerArgumentType(self.__get_int_argtype(bit, False))

            base_set.add_IntegerArgumentType(self.__get_uint_argtype(bit, True))
            base_set.add_IntegerArgumentType(self.__get_uint_argtype(bit, False))

        # NOTE: For right now, only singed little-endian 32-bit floating types are supported
        base_set.add_FloatArgumentType(self.__get_float_argtype(32, True))
        base_set.add_FloatArgumentType(self.__get_float_argtype(32, False))
        base_set.add_IntegerArgumentType(xtce.IntegerParameterType(name='UNKNOWN', signed=False, sizeInBits='32'))
        base_set.add_BooleanArgumentType(xtce.BooleanParameterType(name='boolean8_LE'))

        # Add char types
        # #FIXME: We have to decide what to do about strings
        # for bit in range(1, 160):
        #     # Add big Endian
        #     base_type_name = 'char' + str(bit)
        #     param_type = xtce.StringParameterType(name=base_type_name, signed=True)
        #     bit_size = bit
        #
        #     base_type_data_encoding = xtce.StringDataEncodingType(
        #         byteOrder=xtce.ByteOrderCommonType.MOST_SIGNIFICANT_BYTE_FIRST
        #         if bit < 8
        #         else xtce.ByteOrderCommonType.LEAST_SIGNIFICANT_BYTE_FIRST,
        #         SizeInBits=xtce.SizeInBitsType(Fixed=xtce.FixedType(FixedValue=bit)))
        #
        #     param_type.set_StringDataEncoding(base_type_data_encoding)
        #
        #     base_set.add_IntegerParameterType(param_type)

        base_space_system.get_CommandMetaData().set_ArgumentTypeSet(base_set)

    def add_base_types(self, namespace: str = 'BaseType'):
        """
        Create a namespace BaseType and add all base types to it. Please refer to the docs for how we define a base type
        in our ground system.
        :return:
        """
        self.base_type_namespace = namespace
        self.add_namespace(self.base_type_namespace)
        self.__add_telemetry_base_types()
        self.__add_commands_base_types()

    def __get_all_basetypes(self):
        # Maybe I should opt for a more readable solution (?)
        return set([name.get_name() for name in
                    self[
                        self.base_type_namespace].get_TelemetryMetaData().get_ParameterTypeSet().get_IntegerParameterType() +
                    self[
                        self.base_type_namespace].get_CommandMetaData().get_ArgumentTypeSet().get_IntegerArgumentType() +
                    self[
                        self.base_type_namespace].get_TelemetryMetaData().get_ParameterTypeSet().get_FloatParameterType() +
                    self[self.base_type_namespace].get_CommandMetaData().get_ArgumentTypeSet().get_FloatArgumentType() +
                    self[
                        self.base_type_namespace].get_TelemetryMetaData().get_ParameterTypeSet().get_BooleanParameterType() +
                    self[self.base_type_namespace].get_CommandMetaData().get_ArgumentTypeSet().get_BooleanArgumentType()
                    ])

    def __get_basetype_name(self, basename: str, bit_size: int, little_endian: bool):
        """
        A factory function that constructs the base type name.
        :param basename: The basename of this type. Please note that we mean by this is a name like 'int'. NOT 'int32',
        'int32_t', etc. The caller should pass just 'int' for basetype and pass in the bit size as a separate argument
        to bit_size.
        :param bit_size: How many bits does this base type contain.
        :param little_endian: A bool describing whether the type is encoded using Little Endian or big Endian.
        :return: The full basetype name. Note that this function DOES check the BaseType namesapce of our root SpaceSystem
        . We return the fully-constructed basetype name even if we don't find it in out BaseType namespace. However,
        we do warn the user that this base type name was not found.
        """
        typename = basename + str(bit_size) + '_LE' if little_endian else '_BE'
        all_basetypes = self.__get_all_basetypes()
        logging.debug(f'all base types-->{all_basetypes}')
        logging.debug(f'basename:{basename}')
        if typename in all_basetypes:
            # TODO: I think the BaseType string should be stored on its own variable.
            return 'BaseType/' + typename
        else:
            logging.warning(f'{typename} is being used as a type, but it was not found in the BaseType namespace. ')
            return 'BaseType/' + typename

    def is_little_endian(self, elf_id: str):
        return self.db_cursor.execute('SELECT little_endian FROM elfs where id=?',
                                      (elf_id,)).fetchone()[0] == 1

    # FIXME: Finish implementation
    def __handle_array(self, symbol_record: tuple, multiplicity):
        for index in range(multiplicity):
            self.__get_aggregate_paramtype()

    def __is_base_type(self, type_name: str) -> tuple:
        """
        Checks if type_name is a base type as it appears in the database.
        :return: A tuple of the form (bool, str), where the bool is whether this is a basetype or not and what the
        base type maps to in our BaseType namespace. Please note that this function does not pre-append the BaseType
        namespace to the type, that is the responsibility of the caller.
        """
        out_base_type = (False, '')

        if type_name == 'int64' \
                or type_name == 'int32' \
                or type_name == 'int16' \
                or type_name == 'int8' \
                or type_name == 'int':
            out_base_type = (True, 'int')
        elif type_name == 'uint8' \
                or type_name == 'uint16' \
                or type_name == 'uint32' \
                or type_name == 'uint64':
            out_base_type = (True, 'uint')
        # FIXME: char types need to be handled properly
        elif type_name == 'char':
            out_base_type = (True, 'int')
        elif type_name == 'boolean':
            out_base_type = (True, 'boolean')

        return out_base_type

    def __aggrregate_paramtype_exists(self, type_name: str, namespace: str):
        """
        Checks if the aggregate type with type_name exists in the telemetry child of our root space system.
        :return:
        """
        does_aggregate_exist = False

        if namespace in self.__namespace_dict:
            if self[namespace].get_TelemetryMetaData().get_ParameterTypeSet():
                types = [aggregate_name.get_name for aggregate_name in
                         self[namespace].get_TelemetryMetaData().get_ParameterTypeSet().get_AggregateParameterType() if
                         aggregate_name.get_name() == type_name]

                if len(types) > 0:
                    does_aggregate_exist = True

        return does_aggregate_exist

    def __get_aggregate_paramtype(self, symbol_record: tuple, module_name: str, header_present: bool = True) -> xtce.AggregateParameterType:
        """
        A factory function to create an aggregateParamType type pointed to by symbol_id.
        :param symbol_record: A tuple containing the symbol record of the database in the form of
        (id, elf, name, byte_size)
        :return: If the symbol is processed successfully, an AggregateParameterType representing that symbol(struct) is returned.
        If the symbol already exists, then None is returned. Beware that if this function finds a field of the symbol record
        whose type does not exist(such as a field that has a struct type not defined in our xtce), then this function takes
        the liberty of adding it to the telemetry object in the xtce object.
        """

        out_param = xtce.AggregateParameterType(name=symbol_record[2])

        # If the symbol exists already in our xtce, we don't need to explore it any further
        if self.__aggrregate_paramtype_exists(symbol_record[2], module_name):
            return None

        logging.debug(f'symbol record-->{symbol_record}')

        symbol_id = str(symbol_record[0])

        if header_present:
            fields = sorted(self.db_cursor.execute('SELECT * FROM fields where symbol=?',
                                            (symbol_id,)).fetchall())[1:]
        else:
            fields = self.db_cursor.execute('SELECT * FROM fields where symbol=?',
                                            (symbol_id,)).fetchall()

        logging.debug(f'root fields-->{fields}')

        type_ref_name = None

        member_list = xtce.MemberListType()
        out_param.set_MemberList(member_list)
        symbol_id = str(symbol_record[0])
        for field_id, field_symbol, field_name, field_byte_offset, field_type, field_multiplicity, field_little_endian in fields:
            if field_type == field_symbol:
                continue
            elif field_multiplicity > 0 and field_type != field_symbol:

                logging.debug(f'comparing{field_type} and {field_symbol}')

                symbol_type = self.db_cursor.execute('SELECT * FROM symbols where id=?',
                                                     (field_type,)).fetchone()
                # The symbol_type is expected, as per our schema, to have the form of (id, elf ,name, byte_size)
                if symbol_type:
                    logging.debug(f'symbol_type$$$$-->{symbol_type}')
                    base_type_val = self.__is_base_type(symbol_type[2])
                    if base_type_val[0]:
                        #     TODO: Make a distinction between unsigned and int types
                        type_ref_name = self.__get_basetype_name(base_type_val[1], symbol_type[3] * 8,
                                                                 self.is_little_endian(symbol_type[1]))
                    else:
                        logging.debug(f'field type-->{field_type}')
                        child_symbol = self.db_cursor.execute('SELECT * FROM symbols where id=?',
                                                              (field_type,)).fetchone()

                        logging.debug(f'field_symbol id:{field_symbol}')
                        logging.debug(f'child symbol-->{child_symbol}')
                        child = self.__get_aggregate_paramtype(child_symbol, module_name)
                        # If the symbol did not exists in our xtce, we add it to our telemetry types
                        if child:
                            self[module_name].get_TelemetryMetaData().get_ParameterTypeSet().add_AggregateParameterType(
                                child)
                            type_ref_name = child.get_name()
                        # If the symbol does exist in our telemetry in our telemetry object, all we need
                        # is its name
                        else:
                            type_ref_name = child_symbol[2]
                else:
                    type_ref_name = 'BaseType/UNKNOWN'
                    logging.warning('BaseType/UNKNOWN is being used as array type')

                for index in range(field_multiplicity):
                    child_symbol = self.db_cursor.execute('SELECT * FROM symbols where id=?',
                                                          (field_type,)).fetchone()

                    # FIXME: This entire function needs to be decoupled (?)
                    logging.debug(f'field_symbol id on array:{field_symbol}')
                    logging.debug(f'child symbol-->{child_symbol}')

                    member = xtce.MemberType()
                    member.set_name(f'{field_name}[{index}]')
                    member.set_typeRef(type_ref_name)
                    member_list.add_Member(member)

            else:
                logging.debug('else block')
                member = xtce.MemberType()
                member.set_name(field_name)
                symbol_type = self.db_cursor.execute('SELECT * FROM symbols where id=?',
                                                     (field_type,)).fetchone()
                # The symbol_type is expected, as per our schema, to have the form of (id, elf ,name, byte_size)
                if symbol_type:
                    logging.debug(f'symbol_type$$$$-->{symbol_type}')
                    base_type_val = self.__is_base_type(symbol_type[2])
                    if base_type_val[0]:
                        #     TODO: Make a distinction between unsigned and int types
                        type_ref_name = self.__get_basetype_name(base_type_val[1], symbol_type[3] * 8,
                                                                 self.is_little_endian(symbol_type[1]))
                    else:
                        logging.debug(f'field type-->{field_type}')
                        child_symbol = self.db_cursor.execute('SELECT * FROM symbols where id=?',
                                                              (field_type,)).fetchone()

                        logging.debug(f'field_symbol id:{field_symbol}')
                        logging.debug(f'child symbol-->{child_symbol}')
                        logging.debug(f'field id-->{field_id})')
                        child = self.__get_aggregate_paramtype(child_symbol, module_name)

                        # If the symbol did not exists in our xtce, we add it to our telemetry types
                        if child:
                            self[module_name].get_TelemetryMetaData().get_ParameterTypeSet().add_AggregateParameterType(
                                child)
                            type_ref_name = child.get_name()
                        # If the symbol does exist in our telemetry in our telemetry object, we all we need
                        # is its name
                        else:
                            logging.debug(f'symbol exists for {child_symbol[2]}')
                            type_ref_name = child_symbol[2]

                else:
                    type_ref_name = 'BaseType/UNKNOWN'

                member.set_typeRef(type_ref_name)
                member_list.add_Member(member)

        logging.debug(f'out_param--> {out_param.get_name()}')
        return out_param

    def __aggrregate_argtype_exists(self, type_name: str, namespace: str):
        """
        Checks if the aggregate type with type_name exists in the telemetry child of our root space system.
        :return:
        """
        does_aggregate_exist = False
        types = [aggregate_name.get_name for aggregate_name in
                 self[namespace].get_CommandMetaData().get_ArgumentTypeSet().get_AggregateArgumentType() if
                 aggregate_name.get_name() == type_name]

        if len(types) > 0:
            does_aggregate_exist = True

        return does_aggregate_exist

    def __get_aggregate_argtype(self, symbol_record: tuple, namespace: str) -> xtce.AggregateArgumentType:
        """
        A factory function to create an aggregateArgumentType type pointed to by symbol_id.
        :param symbol_record: A tuple containing the symbol record of the database in the form of
        (id, elf, name, byte_size)
        :return: If the symbol is processed successfully, an aggregateArgumentType representing that symbol(struct) is returned.
        If the symbol already exists, then None is returned. Beware that if this function finds a field of the symbol record
        whose type does not exist(sucha as a field that has a struct type not defined in our xtce), then function takes
        the liberty of adding it to the telemetry object in the xtce object.
        """

        out_param = xtce.AggregateParameterType(name=symbol_record[2])

        # If the symbol exists already in our xtce, we don't need to explore it any further
        if self.__aggrregate_argtype_exists(symbol_record[2]):
            return None

        logging.debug(f'symbol record-->{symbol_record}')

        symbol_id = str(symbol_record[0])

        fields = self.db_cursor.execute('SELECT * FROM fields where symbol=?',
                                        (symbol_id,)).fetchall()

        logging.debug(f'root fields-->{fields}')

        type_ref_name = None

        member_list = xtce.MemberListType()
        out_param.set_MemberList(member_list)
        symbol_id = str(symbol_record[0])
        for field_id, field_symbol, field_name, field_byte_offset, field_type, field_multiplicity, field_little_endian in fields:
            if field_type == field_symbol:
                continue
            elif field_multiplicity > 0 and field_type != field_symbol:

                logging.debug(f'comparing{field_type} and {field_symbol}')

                symbol_type = self.db_cursor.execute('SELECT * FROM symbols where id=?',
                                                     (field_type,)).fetchone()
                # The symbol_type is expected, as per our schema, to have the form of (id, elf ,name, byte_size)
                if symbol_type:
                    logging.debug(f'symbol_type$$$$-->{symbol_type}')
                    base_type_val = self.__is_base_type(symbol_type[2])
                    if base_type_val[0]:
                        #     TODO: Make a distinction between unsigned and int types
                        type_ref_name = self.__get_basetype_name(base_type_val[1], symbol_type[3] * 8,
                                                                 self.is_little_endian(symbol_type[1]))
                    else:
                        logging.debug(f'field type-->{field_type}')
                        child_symbol = self.db_cursor.execute('SELECT * FROM symbols where id=?',
                                                              (field_type,)).fetchone()

                        logging.debug(f'field_symbol id:{field_symbol}')
                        logging.debug(f'child symbol-->{child_symbol}')
                        child = self.__get_aggregate_argtype(child_symbol)
                        # If the symbol did not exists in our xtce, we add it to our telemetry types
                        if child:
                            self[namespace].get_CommandMetaData().get_ArgumentTypeSet().add_AggregateArgumentType(
                                child)
                            type_ref_name = child.get_name()
                        # If the symbol does exist in our telemetry in our telemetry object, all we need
                        # is its name
                        else:
                            type_ref_name = child_symbol[2]
                else:
                    type_ref_name = 'BaseType/UNKNOWN'
                    logging.warning('BaseType/UNKNOWN is being used as array type')

                for index in range(field_multiplicity):
                    child_symbol = self.db_cursor.execute('SELECT * FROM symbols where id=?',
                                                          (field_type,)).fetchone()

                    # FIXME: This entire function needs to be decoupled (?)
                    logging.debug(f'field_symbol id on array:{field_symbol}')
                    logging.debug(f'child symbol-->{child_symbol}')

                    member = xtce.MemberType()
                    member.set_name(f'{field_name}[{index}]')
                    member.set_typeRef(type_ref_name)
                    member_list.add_Member(member)

            else:
                logging.debug('else block')
                member = xtce.MemberType()
                member.set_name(field_name)
                symbol_type = self.db_cursor.execute('SELECT * FROM symbols where id=?',
                                                     (field_type,)).fetchone()
                # The symbol_type is expected, as per our schema, to have the form of (id, elf ,name, byte_size)
                if symbol_type:
                    logging.debug(f'symbol_type$$$$-->{symbol_type}')
                    base_type_val = self.__is_base_type(symbol_type[2])
                    if base_type_val[0]:
                        #     TODO: Make a distinction between unsigned and int types
                        type_ref_name = self.__get_basetype_name(base_type_val[1], symbol_type[3] * 8,
                                                                 self.is_little_endian(symbol_type[1]))
                    else:
                        logging.debug(f'field type-->{field_type}')
                        child_symbol = self.db_cursor.execute('SELECT * FROM symbols where id=?',
                                                              (field_type,)).fetchone()

                        logging.debug(f'field_symbol id:{field_symbol}')
                        logging.debug(f'child symbol-->{child_symbol}')
                        logging.debug(f'field id-->{field_id})')
                        child = self.__get_aggregate_argtype(child_symbol)

                        # If the symbol did not exists in our xtce, we add it to our telemetry types
                        if child:
                            self[namespace].get_CommandMetaData().get_ArgumentTypeSet().add_AggregateArgumentType(
                                child)
                            type_ref_name = child.get_name()
                        # If the symbol does exist in our telemetry in our command object, we all we need
                        # is its name
                        else:
                            logging.debug(f'symbol exists for {child_symbol[2]}')
                            type_ref_name = child_symbol[2]

                else:
                    type_ref_name = 'BaseType/UNKNOWN'

                member.set_typeRef(type_ref_name)
                member_list.add_Member(member)

        logging.debug(f'out_param--> {out_param.get_name()}')
        return out_param

    def add_namespace(self, namespace_name: str):
        """
        Add a namespace to the root SpaceSystem. Please note that namespace is a synonym for SpaceSystem;
        they are the same thing in xtce-speak.
        :param namespace_name: The name of the new namespace.
        :return:
        """
        new_namespace = xtce.SpaceSystemType(name=namespace_name)
        self.root.add_SpaceSystem(new_namespace)
        new_namespace.set_TelemetryMetaData(xtce.TelemetryMetaDataType())
        new_namespace.set_CommandMetaData(xtce.CommandMetaDataType())

        self.__namespace_dict[namespace_name] = new_namespace

    def __get_telemetry_header_length(self, symblold_id):
        """
        Calculate the the size of the telemetry header inside of the struct with id of symbol_id in the database.
        :return: The size of the telemetry header in bits.
        """
        offsets = self.db_cursor.execute('select byte_offset from fields where symbol=?',(symblold_id,)).fetchall()
        offsets.sort()
        return offsets[1]

    def __get_apid(self, message_id: int, offset: int = 11):
        bits = bin(message_id)
        apid = int(bits[len(bits) - offset: len(bits)], 2)
        return apid

    def add_telemetry_containers(self, module_name: str, module_id: int, parent_container: str = None):
        """
        Iterate through all of the rows of telemetry and build our containers for each message in the database.
        :return:
        """
        module_space_system = self[module_name]
        container_set = xtce.ContainerSetType()
        base_paramtype_set = xtce.ParameterTypeSetType()
        module_space_system.get_TelemetryMetaData().set_ParameterTypeSet(base_paramtype_set)
        base_param_set = xtce.ParameterSetType()
        module_space_system.get_TelemetryMetaData().set_ParameterSet(base_param_set)
        module_space_system.get_TelemetryMetaData().set_ContainerSet(container_set)

        for tlm in self.db_cursor.execute('select * from telemetry where module=?',
                                          (module_id,)).fetchall():
            tlm_name = tlm[1]
            tlm_message_id = tlm[2]
            tlm_macro = tlm[3]
            tlm_symbol_id = tlm[4]
            tlm_module = tlm[5]

            seq_container = xtce.SequenceContainerType(name=str(tlm_name))
            container_entry_list = xtce.EntryListType()
            seq_container.set_EntryList(container_entry_list)

            logging.debug(f'message id:{tlm_message_id}')

            for symbol in self.db_cursor.execute('select * from symbols where id=?',
                                                 (tlm_symbol_id,)).fetchall():
                logging.debug(f'symbol{symbol} for tlm:{tlm_name}')

                aggregeate_type = self.__get_aggregate_paramtype(symbol, module_name)

                self.__get_telemetry_header_length(tlm_symbol_id)

                if aggregeate_type:
                    base_paramtype_set.add_AggregateParameterType(aggregeate_type)
                    telemetry_param = xtce.ParameterType(name=aggregeate_type.get_name() + '_param',
                                                         parameterTypeRef=aggregeate_type.get_name())

                    container_param_ref = xtce.ParameterRefEntryType(parameterRef=telemetry_param.get_name())

                    base_param_set.add_Parameter(telemetry_param)
                    container_entry_list.add_ParameterRefEntry(container_param_ref)
                    if parent_container:
                        seq_container.set_BaseContainer(xtce.BaseContainerType(containerRef=parent_container + '/cfs-tlm-hdr'))
                        comparison = xtce.ComparisonType()
                        comparison.set_parameterRef(parent_container + '/ccsds-apid')
                        comparison.set_value(self.__get_apid(tlm_message_id))
                        base_container_restriction = xtce.RestrictionCriteriaType()
                        comparison_list = xtce.ComparisonListType()
                        comparison_list.add_Comparison(comparison)
                        base_container_restriction.set_ComparisonList(comparison_list)
                        seq_container.get_BaseContainer().set_RestrictionCriteria(base_container_restriction)

                    container_set.add_SequenceContainer(seq_container)

    # FIXME: Ask Matt how we handle base containers; do we get from those at this step from the database or at a later step?
    def add_command_containers(self, namespace: str):
        """
        Iterate through all of the rows of the commands table and build our containers for each command in the database.
        :return:
        """
        meta_command_set = xtce.MetaCommandSetType()
        base_argtype_set = self[namespace].get_CommandMetaData().get_ArgumentTypeSet()
        # self[namespace].get_CommandMetaData().set_ArgumentTypeSet(base_arg_set)
        self[namespace].get_CommandMetaData().set_MetaCommandSet(meta_command_set)

        for command in self.db_cursor.execute('select * from commands').fetchall():
            command_name = command[1]
            command_code = command[2]
            command_message_id = command[3]
            command_macro = command[4]
            command_symbol_id = command[5]
            command_module = command[6]

            meta_command = xtce.MetaCommandType(name=command_name + '-' + str(command_message_id))
            command_container = xtce.CommandContainerType(name=command_name + '-' + str(command_message_id) + '-container')
            container_entry_list = xtce.EntryListType()
            # command_container.set_EntryList(container_entry_list)

            base_arg_set = xtce.ArgumentListType()
            logging.debug(f'message id:{command_message_id}')

            for symbol in self.db_cursor.execute('select * from symbols where id=?',
                                                 (command_symbol_id,)).fetchall():
                logging.debug(f'symbol{symbol} for tlm:{command_name}')

                aggregeate_type = self.__get_aggregate_argtype(symbol)

                if aggregeate_type:
                    base_argtype_set.add_AggregateArgumentType(aggregeate_type)
                    command_arg = xtce.ArgumentType(name=aggregeate_type.get_name() + '_arg',
                                                    argumentTypeRef=aggregeate_type.get_name())

                    # container_arg_ref = xtcparameterRef=command_arg.get_name())

                    base_arg_set.add_Argument(command_arg)
                    # container_entry_list.setA('container_arg_ref')
                    meta_command.set_CommandContainer(command_container)
                    meta_command_set.add_MetaCommand(meta_command)

    def add_symbols(self):
        """
        Iterate through all of the symbols in the database and add them to the TelemetryMetaDataType and
        CommandMetaDataType children of our root SpaceSystem.
        :return:
        """
        for module_id in set(self.db_cursor.execute('select module from telemetry').fetchall()):
            module = self.db_cursor.execute('select id, name from modules where id=?', (module_id[0],)).fetchone()
            # logging.debug()
            self.add_telemetry_containers(module[1], module[0], 'cfs-ccsds')
        # self.add_command_containers()

    def __get_namespace(self, namespace_name: str) -> xtce.SpaceSystemType:
        """
        Returns a namespace SpaceSystemType object that has the name of namespace_name.
        :param namespace_name:
        :return:
        """
        return self.__namespace_dict[namespace_name]

    def __getitem__(self, key: str) -> xtce.SpaceSystemType:
        """
        Returns a reference to the namespace with the name of key. If the namespace does not exist, then a new namespace
        with the name of key is created. New namespaces are guaranteed to have an empty CommandMetaDataType object and
        an empty TelemetryMetaDataType object.
        :param key: The name of the namespace.
        :return:
        """
        if key not in self.__namespace_dict:
            # self.__namespace_dict[key] = xtce.SpaceSystemType(name=key)
            # self.__get_namespace(key).set_CommandMetaData(xtce.CommandMetaDataType())
            # self.__get_namespace(key).set_TelemetryMetaData(xtce.TelemetryMetaDataType())
            self.add_namespace(key)

        return self.__get_namespace(key)

    def write_to_file(self, namespace: str):
        """
        Writes the current xtce spacesystem to a file.
        :return:
        """
        self[namespace].export(self.output_file, 0, namespacedef_='xmlns:xml="http://www.w3.org/XML/1998/namespace" '
                                                            'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" '
                                                            'xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" '
                                                            'xsi:schemaLocation="http://www.omg.org/spec/XTCE/20180204 SpaceSystem.xsd "',
                         namespaceprefix_='xtce:')


def parse_cli() -> argparse.Namespace:
    """
    Parses cli argyments.
    :return: The namespace that has all of the arguments that have been parsed.
    """

    parser = argparse.ArgumentParser(description='Takes in path to sqlite database.')
    parser.add_argument('--sqlite_path', type=str,
                        help='The file path to the sqlite database', required=True)
    parser.add_argument('--spacesystem', type=str, default='airliner',
                        help='The name of the root spacesystem of the xtce file. Note that spacesystem is a synonym '
                             'for namespace')
    parser.add_argument('--log_level', type=str, default='DEBUG', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR',
                                                                           'CRITICAL', 'SILENT'],
                        help='The name of the root spacesystem of the xtce file. Note that spacesystem is a synonym '
                             'for namespace')

    return parser.parse_args()


logging_map = {'DEBUG': logging.DEBUG,
               'INFO': logging.INFO,
               'WARNING': logging.WARNING,
               'ERROR': logging.ERROR,
               'CRITICAL': logging.CRITICAL,
               }


def main():
    logging.info('Parsing CLI arguments...')
    args = parse_cli()

    if args.log_level == 'SILENT':
        for key, level in logging_map.items():
            logging.disable(level)
    else:
        logging.getLogger().setLevel(logging_map[args.log_level])

    logging.info('Building xtce object...')
    xtce_obj = XTCEManager(args.spacesystem, args.spacesystem, args.sqlite_path)

    logging.info('Adding base_types to xtce...')
    xtce_obj.add_base_types()

    # FIXME:add_symbols is not complete yet.
    logging.info('Adding symbols...')
    xtce_obj.add_symbols()

    logging.info('Writing xtce object to file...')
    xtce_obj.write_to_file(namespace=args.spacesystem)


if __name__ == '__main__':
    main()
