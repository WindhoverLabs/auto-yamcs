"""
Copyright (c) 2022 Windhover Labs, L.L.C. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the
 distribution.
3. Neither the name Windhover Labs nor the names of its
 contributors may be used to endorse or promote products derived
 from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

"""
#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Sep 14 16:23:36 2020 by generateDS.py version 2.36.2.
# Python 3.5.2 (default, Jul 17 2020, 14:04:10)  [GCC 5.4.0 20160609]
#
# Command line options:
#   ('-o', 'xtce.py')
#
# Command line arguments:
#   /home/vagrant/SpaceSystem.xsd
#
# Command line:
#   /home/vagrant/.local/bin/generateDS -o "xtce.py" /home/vagrant/SpaceSystem.xsd
#
# Current working directory (os.getcwd()):
#   xtce_classes
#

from six.moves import zip_longest
import os
import sys
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_

try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_

Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc


def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element


#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ImportError:

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))

#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')

        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name

            def utcoffset(self, dt):
                return self.__offset

            def tzname(self, dt):
                return self.__name

            def dst(self, dt):
                return None

        def gds_format_string(self, input_data, input_name=''):
            return input_data

        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data

        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data

        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)

        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data

        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival

        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value

        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values

        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')

        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_

        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value

        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values

        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value

        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value

        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value

        def gds_format_decimal_list(self, input_data, input_name=''):
            return ' '.join([self.gds_format_decimal(item) for item in input_data])

        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values

        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data

        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_

        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value

        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values

        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()

        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval

        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0,):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data

        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0,):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values

        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue

        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"),)
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt

        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue

        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()

        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue

        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1

        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()

        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None:
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))

        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))

        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))

        def gds_str_lower(self, instring):
            return instring.lower()

        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path

        Tag_strip_pattern_ = re_.compile(r'\{.*\}')

        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)

        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1

        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content

        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))

        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring

        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result

        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')

            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))

        def __ne__(self, other):
            return not self.__eq__(other)

        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass

        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass

        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None

        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass

        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""


    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None

#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None


#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name,))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline,)
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8

    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value

    def getCategory(self):
        return self.category

    def getContenttype(self, content_type):
        return self.content_type

    def getValue(self):
        return self.value

    def getName(self):
        return self.name

    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:  # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)

    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))

    def to_etree(self, element, mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:  # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)

    def to_etree_simple(self, mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
              self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
              self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text

    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:  # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
                 optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional

    def set_name(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def set_data_type(self, data_type):
        self.data_type = data_type

    def get_data_type_chain(self):
        return self.data_type

    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type

    def set_container(self, container):
        self.container = container

    def get_container(self):
        return self.container

    def set_child_attrs(self, child_attrs):
        self.child_attrs = child_attrs

    def get_child_attrs(self):
        return self.child_attrs

    def set_choice(self, choice):
        self.choice = choice

    def get_choice(self):
        return self.choice

    def set_optional(self, optional):
        self.optional = optional

    def get_optional(self):
        return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Data representation classes.
#


class BasisType(str, Enum):
    """Defines to type of update rates: perSecond and perContainerUpdate. See
    RateInStreamType."""
    PER_SECOND = 'perSecond'
    PER_CONTAINER_UPDATE = 'perContainerUpdate'


class BitOrderType(str, Enum):
    """Defines two bit-order types: most significant bit first and least
    significant bit first. See DataEncodingType."""
    LEAST_SIGNIFICANT_BIT_FIRST = 'leastSignificantBitFirst'
    MOST_SIGNIFICANT_BIT_FIRST = 'mostSignificantBitFirst'


class ByteOrderCommonType(str, Enum):
    """Common byte orderings: most significant byte first (also known as big
    endian) and least significant byte first (also known as little
    endian)."""
    MOST_SIGNIFICANT_BYTE_FIRST = 'mostSignificantByteFirst'
    LEAST_SIGNIFICANT_BYTE_FIRST = 'leastSignificantByteFirst'


class ChangeBasisType(str, Enum):
    """Defines absoluteChange and percentageChange for use in rate of change
    alarms. Used by ChangeAlarmRangesType."""
    ABSOLUTE_CHANGE = 'absoluteChange'
    PERCENTAGE_CHANGE = 'percentageChange'


class ChangeSpanType(str, Enum):
    """Defines a changePerSecond and changePerSample for use in rate of change
    alarms. Used by ChangeAlarmRangesType."""
    CHANGE_PER_SECOND = 'changePerSecond'
    CHANGE_PER_SAMPLE = 'changePerSample'


class CharacterWidthType(str, Enum):
    _8 = '8'
    _1_6 = '16'


class ComparisonOperatorsType(str, Enum):
    """Operators to use when testing a boolean condition for a validity
    check"""
    _ = '=='
    __1 = '!='
    __2 = '<'
    __3 = '<='
    __4 = '>'
    __5 = '>='


class ConcernLevelsType(str, Enum):
    """Defines six levels: Normal, Watch, Warning, Distress, Critical and
    Severe. Typical implementations color the "normal" level as green,
    "warning" level as yellow, and "critical" level as red. These level
    definitions are used throughout the alarm definitions. Some systems
    provide a greater fidelity with the additional levels provided here.
    The "normal" level is not typically needed because "normal" should be
    construed as none of the concern levels evaluating to true. For cases
    where definiing "normal" is needed, refer to the specific alarm
    definition types."""
    NORMAL = 'normal'
    WATCH = 'watch'
    WARNING = 'warning'
    DISTRESS = 'distress'
    CRITICAL = 'critical'
    SEVERE = 'severe'


class ConsequenceLevelType(str, Enum):
    """Defines the criticality level of a command. Criticality levels follow
    ISO 14950."""
    NORMAL = 'normal'  # Normal command. Corresponds to ISO 14950 Level D telecommand criticality.
    VITAL = 'vital'  # Command that is not a critical command but is essential to the success of the mission and, if sent at the wrong time, could cause momentary loss of the mission. Corresponds to ISO 14950 Level C telecommand criticality.
    CRITICAL = 'critical'  # Command that, if executed at the wrong time or in the wrong configuration, could cause irreversible loss or damage for the mission. Corresponds to ISO 14950 Level B telecommand criticality. Some space programs have called this "restricted" and may be implemented with a secondary confirmation before transmission.
    FORBIDDEN = 'forbidden'  # Command that is not expected to be used for nominal or foreseeable contingency operations, that is included for unforeseen contingency operations, and that could cause irreversible damage if executed at the wrong time or in the wrong configuration. Corresponds to ISO 14950 Level A telecommand criticality. Some space programs have called this "prohibited".
    USER_1 = 'user1'  # In the event that a program uses this value, that program will need to define the meaning of this value to their system.
    USER_2 = 'user2'  # In the event that a program uses this value, that program will need to define the meaning of this value to their system.


class EpochTimeEnumsType(str, Enum):
    """Union values of common epoch definitions for document convenience."""
    TAI = 'TAI'
    J_2000 = 'J2000'
    UNIX = 'UNIX'
    GPS = 'GPS'


class FlagBitType(str, Enum):
    ZEROS = 'zeros'
    ONES = 'ones'


class FloatEncodingSizeInBitsType(str, Enum):
    _1_6 = '16'  # At the time of this writing, 16 bit encoding size is only valid in cases of IEEE754 and vendor specific MILSTD_1750A variation that is not a part of the standard. This is not meant to preclude use in the event that future floating point formats may also define this value.
    _3_2 = '32'  # At the time of this writing, 32 bit encoding size is only valid in cases of IEEE754_1985, IEEE754, MILSTD_1750A, DEC, IBM, and TI. This is not meant to preclude use in the event that future floating point formats may also define this value. The IEEE754 enumeration and the IEEE754_1985 enumeration are allowed in this case and the interpretation is the same.
    _4_0 = '40'  # At the time of this writing, 40 bit encoding size is only valid in the case of TI. This is not meant to preclude use in the event that future floating point formats may also define this value.
    _4_8 = '48'  # At the time of this writing, 48 bit encoding size is only valid in the case of MILSTD_1750A. This is not meant to preclude use in the event that future floating point formats may also define this value.
    _6_4 = '64'  # At the time of this writing, 64 bit encoding size is only valid in cases of IEEE754_1985, IEEE754, DEC, and IBM. This is not meant to preclude use in the event that future floating point formats may also define this value. The IEEE754 enumeration and the IEEE754_1985 enumeration are allowed in this case and the interpretation is the same.
    _8_0 = '80'  # At the time of this writing, 80 bit encoding size is only valid in the case of IEEE754_1985. This is not meant to preclude use in the event that future floating point formats may also define this value.
    _1_28 = '128'  # At the time of this writing, 128 bit encoding size is only valid in the case of IEEE754_1985 and IEEE754. This is not meant to preclude use in the event that future floating point formats may also define this value. The IEEE754 enumeration and the IEEE754_1985 enumeration are allowed in this case and the interpretation is the same.


class FloatEncodingType(str, Enum):
    IEEE_754__1985 = 'IEEE754_1985'
    IEEE_754 = 'IEEE754'
    MILSTD__1750_A = 'MILSTD_1750A'
    DEC = 'DEC'
    IBM = 'IBM'
    TI = 'TI'


class FloatSizeInBitsType(str, Enum):
    _3_2 = '32'
    _6_4 = '64'
    _1_28 = '128'


class FloatingPointNotationType(str, Enum):
    NORMAL = 'normal'
    SCIENTIFIC = 'scientific'
    ENGINEERING = 'engineering'


class IntegerEncodingType(str, Enum):
    UNSIGNED = 'unsigned'
    SIGN_MAGNITUDE = 'signMagnitude'
    TWOS_COMPLEMENT = 'twosComplement'
    ONES_COMPLEMENT = 'onesComplement'
    BCD = 'BCD'
    PACKED_BCD = 'packedBCD'


class MathOperatorsType(str, Enum):
    """Mathematical operators used in the math operation. Behavior of each
    operator on the stack is described using notation (before -- after),
    where "before" represents the stack before execution of the operator
    and "after" represent the stack after execution."""
    _ = '+'  # addition (x1 x2 -- x1+x2)
    __1 = '-'  # subtraction (x1 x2 -- x1-x2)
    __2 = '*'  # multiplication (x1 x2 -- x1*x2)
    __3 = '/'  # division (x1 x2 -- x1/x2)
    __4 = '%'  # modulo (x1 x2 -- x3) Divide x1 by x2, giving the modulo x3
    __5 = '^'  # power function (x1 x2 -- x1**x2)
    YX = 'y^x'  # reverse power function (x1 x2 -- x2**x1)
    LN = 'ln'  # natural (base e) logarithm (x -- ln(x))
    LOG = 'log'  # base-10 logarithm (x-- log(x))
    EX = 'e^x'  # exponentiation (x -- exp(x))
    _1X = '1/x'  # inversion (x -- 1/x)
    X = 'x!'  # factorial (x -- x!)
    TAN = 'tan'  # tangent (x -- tan(x)) radians
    COS = 'cos'  # cosine (x -- cos(x)) radians
    SIN = 'sin'  # sine (x -- sin(x)) radians
    ATAN = 'atan'  # arctangent (x -- atan(x)) radians
    ATAN_2 = 'atan2'  # arctangent (x1 x2 -- atan2(x2, x1)) radians
    ACOS = 'acos'  # arccosine (x -- acos(x)) radians
    ASIN = 'asin'  # arcsine (x -- asin(x)) radians
    TANH = 'tanh'  # hyperbolic tangent (x -- tanh(x))
    COSH = 'cosh'  # hyperbolic cosine (x -- cosh(x))
    SINH = 'sinh'  # hyperbolic sine (x -- sinh(x))
    ATANH = 'atanh'  # hyperbolic arctangent (x -- atanh(x))
    ACOSH = 'acosh'  # hyperbolic arccosine (x -- acosh(x))
    ASINH = 'asinh'  # hyperbolic arcsine (x -- asinh(x))
    SWAP = 'swap'  # swap the top two stack items (x1 x2 -- x2 x1)
    DROP = 'drop'  # Remove top item from the stack (x -- )
    DUP = 'dup'  # Duplicate top item on the stack (x -- x x)
    OVER = 'over'  # Duplicate top item on the stack (x1 x2 -- x1 x2 x1)
    __6 = '<<'  # signed bitwise left shift (x1 x2 -- x1 << x2)
    __7 = '>>'  # signed bitwise right shift (x1 x2 -- x1 >> x2)
    __8 = '&'  # bitwise and (x1 x2 -- x1 & x2)
    __9 = '|'  # bitwise or (x1 x2 -- x1 | x2)
    __10 = '&&'  # logical and (x1 x2 -- x1 && x2)
    __11 = '||'  # logical or (x1 x2 -- x1 || x2)
    __12 = '!'  # logical not (x1 x2 -- x1 ! x2)
    ABS = 'abs'  # absolute value (x1 -- abs(x1))
    DIV = 'div'  # Euclidean division quotient (x1 -- div(x1))
    INT = 'int'  # integer part (x1 -- int(x1))
    __13 = '>'  # greater than x,y (x1 x2 -- x1 > x2)
    __14 = '>='  # greater than or equal x,y (x1 x2 -- x1 >= x2)
    __15 = '<'  # less than x,y (x1 x2 -- x1 < x2)
    __16 = '<='  # less than or equal x,y (x1 x2 -- x1 <= x2)
    __17 = '=='  # equal x,y (x1 x2 -- x1 == x2)
    __18 = '!='  # not equal x,y (x1 x2 -- x1 != x2)
    MIN = 'min'  # minimum of x,y (x1 x2 -- min(x1, x2))
    MAX = 'max'  # maximum of x,y (x1 x2 -- max(x1, x2))
    XOR = 'xor'  # Bitwise exclusive or (XOR) (x1 x2 -- x1 xor x2)
    __19 = '~'  # Bitwise not operation (x1 x2 -- x1 ~ x2) The result of this can only be 0 or 1


class PCMType(str, Enum):
    NRZL = 'NRZL'
    NRZM = 'NRZM'
    NRZS = 'NRZS'
    BI_PHASE_L = 'BiPhaseL'
    BI_PHASE_M = 'BiPhaseM'
    BI_PHASE_S = 'BiPhaseS'


class ParityFormType(str, Enum):
    EVEN = 'Even'
    ODD = 'Odd'


class RadixType(str, Enum):
    """Specifies the number base"""
    DECIMAL = 'Decimal'
    HEXADECIMAL = 'Hexadecimal'
    OCTAL = 'Octal'
    BINARY = 'Binary'


class RangeFormType(str, Enum):
    """Defines whether the defined range between the minimum and maximum is the
    outside or inside the range being defined. The default, outside matches
    values less than the minimum and greater than the maximum. Inside
    matches values between the minimum and maximum."""
    OUTSIDE = 'outside'
    INSIDE = 'inside'


class ReferenceLocationType(str, Enum):
    """The location may be relative to the start of the container
    (containerStart), relative to the end of the previous entry
    (previousEntry), relative to the end of the container (containerEnd),
    or relative to the entry that follows this one (nextEntry). If going
    forward (containerStart and previousEntry) then the location refers to
    the start of the Entry. If going backwards (containerEnd and nextEntry)
    then, the location refers to the end of the entry."""
    CONTAINER_START = 'containerStart'
    CONTAINER_END = 'containerEnd'
    PREVIOUS_ENTRY = 'previousEntry'
    NEXT_ENTRY = 'nextEntry'


class ReferencePointType(str, Enum):
    START = 'start'
    END = 'end'


class StringEncodingType(str, Enum):
    """Defines string encodings. US-ASCII (7-bit), ISO-8859-1 (8-bit Extended
    ASCII), Windows-1252 (8-bit Extended ASCII), UTF-8 (Unicode), UTF-16
    (Unicode with Byte Order Mark), UTF-16LE (Unicode Little Endian),
    UTF-16BE (Unicode Big Endian). See StringDataEncodingType."""
    USASCII = 'US-ASCII'
    ISO_8859_1 = 'ISO-8859-1'
    WINDOWS_1252 = 'Windows-1252'
    UTF_8 = 'UTF-8'
    UTF_16 = 'UTF-16'  # With UTF-16, encoded bits must be prepended with a Byte Order Mark. This mark indicates whether the data is encoded in big or little endian.
    UTF_16_LE = 'UTF-16LE'  # With UTF-16LE, encoded bits will always be represented as little endian. Bits are not prepended with a Byte Order Mark.
    UTF_16_BE = 'UTF-16BE'  # With UTF-16BE, encoded bits will always be represented as big endian. Bits are not prepended with a Byte Order Mark.
    UTF_32 = 'UTF-32'  # With UTF-32, encoded bits must be prepended with a Byte Order Mark. This mark indicates whether the data is encoded in big or little endian.
    UTF_32_LE = 'UTF-32LE'  # With UTF-32LE, encoded bits will always be represented as little endian. Bits are not prepended with a Byte Order Mark.
    UTF_32_BE = 'UTF-32BE'  # With UTF-32BE, encoded bits will always be represented as big endian. Bits are not prepended with a Byte Order Mark.


class TelemetryDataSourceType(str, Enum):
    """A telemetered Parameter is one that will have values in telemetry. A
    derived Parameter is one that is calculated, usually by an Algorithm. A
    constant Parameter is one that is used as a constant in the system
    (e.g. a vehicle id). A local Parameter is one that is used purely by
    the software locally (e.g. a ground command counter). A ground
    Parameter is one that is generated by an asset which is not the
    spacecraft."""
    TELEMETERED = 'telemetered'
    DERIVED = 'derived'
    CONSTANT = 'constant'
    LOCAL = 'local'
    GROUND = 'ground'


class TimeAssociationUnitType(str, Enum):
    """Time units the time association decimal value is in."""
    SI_NANOSECOND = 'si_nanosecond'
    SI_MICROSECOND = 'si_microsecond'
    SI_MILLSECOND = 'si_millsecond'
    SI_SECOND = 'si_second'
    MINUTE = 'minute'
    DAY = 'day'
    JULIAN_YEAR = 'julianYear'


class TimeUnitsType(str, Enum):
    """base time units. days, months, years have obvoius ambiguity and should
    be avoided"""
    SECONDS = 'seconds'
    PICO_SECONDS = 'picoSeconds'
    DAYS = 'days'
    MONTHS = 'months'
    YEARS = 'years'


class TimeWindowIsRelativeToType(str, Enum):
    COMMAND_RELEASE = 'commandRelease'
    TIME_LAST_VERIFIER_PASSED = 'timeLastVerifierPassed'


class UnitFormType(str, Enum):
    """Optionally specify if this information pertains to something other than
    the calibrated/engineering value."""
    CALIBRATED = 'calibrated'
    UNCALIBRATED = 'uncalibrated'
    RAW = 'raw'


class ValidationStatusType(str, Enum):
    UNKNOWN = 'Unknown'
    WORKING = 'Working'
    DRAFT = 'Draft'
    TEST = 'Test'
    VALIDATED = 'Validated'
    RELEASED = 'Released'
    WITHDRAWN = 'Withdrawn'


class VerifierEnumerationType(str, Enum):
    """An enumerated list of verifier types"""
    RELEASE = 'release'
    TRANSFERRED_TO_RANGE = 'transferredToRange'
    SENT_FROM_RANGE = 'sentFromRange'
    RECEIVED = 'received'
    ACCEPTED = 'accepted'
    QUEUED = 'queued'
    EXECUTING = 'executing'
    COMPLETE = 'complete'
    FAILED = 'failed'


class nameType(str, Enum):
    """Qualified list of name checksum algorithms. If custom is chosen,
    InputAlgorithm must be set."""
    UNIX_SUM = 'unix_sum'
    SUM_8 = 'sum8'
    SUM_16 = 'sum16'
    SUM_24 = 'sum24'
    SUM_32 = 'sum32'
    FLETCHER_4 = 'fletcher4'
    FLETCHER_8 = 'fletcher8'
    FLETCHER_16 = 'fletcher16'
    FLETCHER_32 = 'fletcher32'
    ADLER_32 = 'adler32'
    LUHN = 'luhn'
    VERHOEFF = 'verhoeff'
    DAMM = 'damm'
    CUSTOM = 'custom'  # Document a custom checksum algorithm


class CommandMetaDataType(GeneratedsSuper):
    """Describe command related metadata. Items defined in this area may refer
    to items defined in TelemetryMetaData. See TelemetryMetaDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ParameterTypeSet=None, ParameterSet=None, ArgumentTypeSet=None, MetaCommandSet=None,
                 CommandContainerSet=None, StreamSet=None, AlgorithmSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ParameterTypeSet = ParameterTypeSet
        self.ParameterTypeSet_nsprefix_ = None
        self.ParameterSet = ParameterSet
        self.ParameterSet_nsprefix_ = None
        self.ArgumentTypeSet = ArgumentTypeSet
        self.ArgumentTypeSet_nsprefix_ = None
        self.MetaCommandSet = MetaCommandSet
        self.MetaCommandSet_nsprefix_ = None
        self.CommandContainerSet = CommandContainerSet
        self.CommandContainerSet_nsprefix_ = None
        self.StreamSet = StreamSet
        self.StreamSet_nsprefix_ = None
        self.AlgorithmSet = AlgorithmSet
        self.AlgorithmSet_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommandMetaDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommandMetaDataType.subclass:
            return CommandMetaDataType.subclass(*args_, **kwargs_)
        else:
            return CommandMetaDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ParameterTypeSet(self):
        return self.ParameterTypeSet

    def set_ParameterTypeSet(self, ParameterTypeSet):
        self.ParameterTypeSet = ParameterTypeSet

    def get_ParameterSet(self):
        return self.ParameterSet

    def set_ParameterSet(self, ParameterSet):
        self.ParameterSet = ParameterSet

    def get_ArgumentTypeSet(self)->'ArgumentTypeSetType':
        return self.ArgumentTypeSet

    def set_ArgumentTypeSet(self, ArgumentTypeSet):
        self.ArgumentTypeSet = ArgumentTypeSet

    def get_MetaCommandSet(self) -> 'MetaCommandSetType':
        return self.MetaCommandSet

    def set_MetaCommandSet(self, MetaCommandSet):
        self.MetaCommandSet = MetaCommandSet

    def get_CommandContainerSet(self):
        return self.CommandContainerSet

    def set_CommandContainerSet(self, CommandContainerSet):
        self.CommandContainerSet = CommandContainerSet

    def get_StreamSet(self):
        return self.StreamSet

    def set_StreamSet(self, StreamSet):
        self.StreamSet = StreamSet

    def get_AlgorithmSet(self):
        return self.AlgorithmSet

    def set_AlgorithmSet(self, AlgorithmSet):
        self.AlgorithmSet = AlgorithmSet

    def hasContent_(self):
        if (
                self.ParameterTypeSet is not None or
                self.ParameterSet is not None or
                self.ArgumentTypeSet is not None or
                self.MetaCommandSet is not None or
                self.CommandContainerSet is not None or
                self.StreamSet is not None or
                self.AlgorithmSet is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='CommandMetaDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CommandMetaDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CommandMetaDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CommandMetaDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CommandMetaDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CommandMetaDataType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='CommandMetaDataType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ParameterTypeSet is not None:
            namespaceprefix_ = self.ParameterTypeSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterTypeSet_nsprefix_) else ''
            self.ParameterTypeSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ParameterTypeSet',
                                         pretty_print=pretty_print)
        if self.ParameterSet is not None:
            namespaceprefix_ = self.ParameterSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterSet_nsprefix_) else ''
            self.ParameterSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ParameterSet',
                                     pretty_print=pretty_print)
        if self.ArgumentTypeSet is not None:
            namespaceprefix_ = self.ArgumentTypeSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ArgumentTypeSet_nsprefix_) else ''
            self.ArgumentTypeSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ArgumentTypeSet',
                                        pretty_print=pretty_print)
        if self.MetaCommandSet is not None:
            namespaceprefix_ = self.MetaCommandSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MetaCommandSet_nsprefix_) else ''
            self.MetaCommandSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MetaCommandSet',
                                       pretty_print=pretty_print)
        if self.CommandContainerSet is not None:
            namespaceprefix_ = self.CommandContainerSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CommandContainerSet_nsprefix_) else ''
            self.CommandContainerSet.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='CommandContainerSet', pretty_print=pretty_print)
        if self.StreamSet is not None:
            namespaceprefix_ = self.StreamSet_nsprefix_ + ':' if (UseCapturedNS_ and self.StreamSet_nsprefix_) else ''
            self.StreamSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StreamSet',
                                  pretty_print=pretty_print)
        if self.AlgorithmSet is not None:
            namespaceprefix_ = self.AlgorithmSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AlgorithmSet_nsprefix_) else ''
            self.AlgorithmSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AlgorithmSet',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ParameterTypeSet':
            obj_ = ParameterTypeSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterTypeSet = obj_
            obj_.original_tagname_ = 'ParameterTypeSet'
        elif nodeName_ == 'ParameterSet':
            obj_ = ParameterSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterSet = obj_
            obj_.original_tagname_ = 'ParameterSet'
        elif nodeName_ == 'ArgumentTypeSet':
            obj_ = ArgumentTypeSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ArgumentTypeSet = obj_
            obj_.original_tagname_ = 'ArgumentTypeSet'
        elif nodeName_ == 'MetaCommandSet':
            obj_ = MetaCommandSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MetaCommandSet = obj_
            obj_.original_tagname_ = 'MetaCommandSet'
        elif nodeName_ == 'CommandContainerSet':
            obj_ = CommandContainerSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CommandContainerSet = obj_
            obj_.original_tagname_ = 'CommandContainerSet'
        elif nodeName_ == 'StreamSet':
            obj_ = StreamSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StreamSet = obj_
            obj_.original_tagname_ = 'StreamSet'
        elif nodeName_ == 'AlgorithmSet':
            obj_ = AlgorithmSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AlgorithmSet = obj_
            obj_.original_tagname_ = 'AlgorithmSet'


# end class CommandMetaDataType


class TelemetryMetaDataType(GeneratedsSuper):
    """All the data about telemetry is contained in TelemetryMetaData"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ParameterTypeSet=None, ParameterSet=None, ContainerSet=None, MessageSet=None, StreamSet=None,
                 AlgorithmSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ParameterTypeSet = ParameterTypeSet
        self.ParameterTypeSet_nsprefix_ = None
        self.ParameterSet = ParameterSet
        self.ParameterSet_nsprefix_ = None
        self.ContainerSet = ContainerSet
        self.ContainerSet_nsprefix_ = None
        self.MessageSet = MessageSet
        self.MessageSet_nsprefix_ = None
        self.StreamSet = StreamSet
        self.StreamSet_nsprefix_ = None
        self.AlgorithmSet = AlgorithmSet
        self.AlgorithmSet_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TelemetryMetaDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TelemetryMetaDataType.subclass:
            return TelemetryMetaDataType.subclass(*args_, **kwargs_)
        else:
            return TelemetryMetaDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ParameterTypeSet(self)->'ParameterTypeSetType':
        return self.ParameterTypeSet

    def set_ParameterTypeSet(self, ParameterTypeSet):
        self.ParameterTypeSet = ParameterTypeSet

    def get_ParameterSet(self)->'ParameterSetType':
        return self.ParameterSet

    def set_ParameterSet(self, ParameterSet):
        self.ParameterSet = ParameterSet

    def get_ContainerSet(self) -> 'ContainerSetType':
        return self.ContainerSet

    def set_ContainerSet(self, ContainerSet):
        self.ContainerSet = ContainerSet

    def get_MessageSet(self):
        return self.MessageSet

    def set_MessageSet(self, MessageSet):
        self.MessageSet = MessageSet

    def get_StreamSet(self):
        return self.StreamSet

    def set_StreamSet(self, StreamSet):
        self.StreamSet = StreamSet

    def get_AlgorithmSet(self):
        return self.AlgorithmSet

    def set_AlgorithmSet(self, AlgorithmSet):
        self.AlgorithmSet = AlgorithmSet

    def hasContent_(self):
        if (
                self.ParameterTypeSet is not None or
                self.ParameterSet is not None or
                self.ContainerSet is not None or
                self.MessageSet is not None or
                self.StreamSet is not None or
                self.AlgorithmSet is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='TelemetryMetaDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TelemetryMetaDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TelemetryMetaDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TelemetryMetaDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TelemetryMetaDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TelemetryMetaDataType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='TelemetryMetaDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ParameterTypeSet is not None:
            namespaceprefix_ = self.ParameterTypeSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterTypeSet_nsprefix_) else ''
            self.ParameterTypeSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ParameterTypeSet',
                                         pretty_print=pretty_print)
        if self.ParameterSet is not None:
            namespaceprefix_ = self.ParameterSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterSet_nsprefix_) else ''
            self.ParameterSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ParameterSet',
                                     pretty_print=pretty_print)
        if self.ContainerSet is not None:
            namespaceprefix_ = self.ContainerSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContainerSet_nsprefix_) else ''
            self.ContainerSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContainerSet',
                                     pretty_print=pretty_print)
        if self.MessageSet is not None:
            namespaceprefix_ = self.MessageSet_nsprefix_ + ':' if (UseCapturedNS_ and self.MessageSet_nsprefix_) else ''
            self.MessageSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MessageSet',
                                   pretty_print=pretty_print)
        if self.StreamSet is not None:
            namespaceprefix_ = self.StreamSet_nsprefix_ + ':' if (UseCapturedNS_ and self.StreamSet_nsprefix_) else ''
            self.StreamSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StreamSet',
                                  pretty_print=pretty_print)
        if self.AlgorithmSet is not None:
            namespaceprefix_ = self.AlgorithmSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AlgorithmSet_nsprefix_) else ''
            self.AlgorithmSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AlgorithmSet',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ParameterTypeSet':
            obj_ = ParameterTypeSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterTypeSet = obj_
            obj_.original_tagname_ = 'ParameterTypeSet'
        elif nodeName_ == 'ParameterSet':
            obj_ = ParameterSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterSet = obj_
            obj_.original_tagname_ = 'ParameterSet'
        elif nodeName_ == 'ContainerSet':
            obj_ = ContainerSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContainerSet = obj_
            obj_.original_tagname_ = 'ContainerSet'
        elif nodeName_ == 'MessageSet':
            obj_ = MessageSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MessageSet = obj_
            obj_.original_tagname_ = 'MessageSet'
        elif nodeName_ == 'StreamSet':
            obj_ = StreamSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StreamSet = obj_
            obj_.original_tagname_ = 'StreamSet'
        elif nodeName_ == 'AlgorithmSet':
            obj_ = AlgorithmSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AlgorithmSet = obj_
            obj_.original_tagname_ = 'AlgorithmSet'


# end class TelemetryMetaDataType


class BaseAlarmType(GeneratedsSuper):
    """Supplies an optional non-reference-able name and short description for
    alarms. Also includes an optional ancillary data for any special local
    flags, note that these may not necessarily transfer to another
    recipient of an instance document.The alarm definition may be named.An
    optional brief description of this alarm definition."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.shortDescription = _cast(None, shortDescription)
        self.shortDescription_nsprefix_ = None
        self.AncillaryDataSet = AncillaryDataSet
        self.AncillaryDataSet_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseAlarmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseAlarmType.subclass:
            return BaseAlarmType.subclass(*args_, **kwargs_)
        else:
            return BaseAlarmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AncillaryDataSet(self):
        return self.AncillaryDataSet

    def set_AncillaryDataSet(self, AncillaryDataSet):
        self.AncillaryDataSet = AncillaryDataSet

    def get_name(self):
        return self.name

    def set_name(self, name):
        self.name = name

    def get_shortDescription(self):
        return self.shortDescription

    def set_shortDescription(self, shortDescription):
        self.shortDescription = shortDescription

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_ShortDescriptionType(self, value):
        # Validate type xtce:ShortDescriptionType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            pass

    def hasContent_(self):
        if (
                self.AncillaryDataSet is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BaseAlarmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseAlarmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BaseAlarmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseAlarmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseAlarmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseAlarmType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(
                ' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')),))
        if self.shortDescription is not None and 'shortDescription' not in already_processed:
            already_processed.add('shortDescription')
            outfile.write(' shortDescription=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.shortDescription), input_name='shortDescription')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BaseAlarmType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AncillaryDataSet is not None:
            namespaceprefix_ = self.AncillaryDataSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AncillaryDataSet_nsprefix_) else ''
            self.AncillaryDataSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AncillaryDataSet',
                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('shortDescription', node)
        if value is not None and 'shortDescription' not in already_processed:
            already_processed.add('shortDescription')
            self.shortDescription = value
            self.validate_ShortDescriptionType(self.shortDescription)  # validate type ShortDescriptionType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AncillaryDataSet':
            obj_ = AncillaryDataSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AncillaryDataSet = obj_
            obj_.original_tagname_ = 'AncillaryDataSet'


# end class BaseAlarmType


class BaseContainerType(GeneratedsSuper):
    """Describe a child/parent container inheritance relationship. Describe
    constraints with RestrictionCriteria, conditions that must be true for
    this container to be an extension of the parent container. A constraint
    can be used to convey the identifying features of the telemetry format
    such as the CCSDS application id or minor-frame id. See
    RestrictionCriteriaType and SequenceContainerType.Reference to the
    container that this container extends."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, containerRef=None, RestrictionCriteria=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.containerRef = _cast(None, containerRef)
        self.containerRef_nsprefix_ = None
        self.RestrictionCriteria = RestrictionCriteria
        self.RestrictionCriteria_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseContainerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseContainerType.subclass:
            return BaseContainerType.subclass(*args_, **kwargs_)
        else:
            return BaseContainerType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_RestrictionCriteria(self):
        return self.RestrictionCriteria

    def set_RestrictionCriteria(self, RestrictionCriteria):
        self.RestrictionCriteria = RestrictionCriteria

    def get_containerRef(self):
        return self.containerRef

    def set_containerRef(self, containerRef):
        self.containerRef = containerRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                self.RestrictionCriteria is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BaseContainerType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseContainerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BaseContainerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseContainerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseContainerType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseContainerType'):
        if self.containerRef is not None and 'containerRef' not in already_processed:
            already_processed.add('containerRef')
            outfile.write(' containerRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.containerRef), input_name='containerRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BaseContainerType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RestrictionCriteria is not None:
            namespaceprefix_ = self.RestrictionCriteria_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.RestrictionCriteria_nsprefix_) else ''
            self.RestrictionCriteria.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='RestrictionCriteria', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('containerRef', node)
        if value is not None and 'containerRef' not in already_processed:
            already_processed.add('containerRef')
            self.containerRef = value
            self.validate_NameReferenceType(self.containerRef)  # validate type NameReferenceType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RestrictionCriteria':
            obj_ = RestrictionCriteriaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RestrictionCriteria = obj_
            obj_.original_tagname_ = 'RestrictionCriteria'


# end class BaseContainerType


class ContainerRefSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ContainerRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ContainerRef is None:
            self.ContainerRef = []
        else:
            self.ContainerRef = ContainerRef
        self.ContainerRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContainerRefSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContainerRefSetType.subclass:
            return ContainerRefSetType.subclass(*args_, **kwargs_)
        else:
            return ContainerRefSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContainerRef(self):
        return self.ContainerRef

    def set_ContainerRef(self, ContainerRef):
        self.ContainerRef = ContainerRef

    def add_ContainerRef(self, value):
        self.ContainerRef.append(value)

    def insert_ContainerRef_at(self, index, value):
        self.ContainerRef.insert(index, value)

    def replace_ContainerRef_at(self, index, value):
        self.ContainerRef[index] = value

    def hasContent_(self):
        if (
                self.ContainerRef
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ContainerRefSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContainerRefSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContainerRefSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContainerRefSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContainerRefSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContainerRefSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ContainerRefSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContainerRef_ in self.ContainerRef:
            namespaceprefix_ = self.ContainerRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContainerRef_nsprefix_) else ''
            ContainerRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContainerRef',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContainerRef':
            obj_ = ContainerRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContainerRef.append(obj_)
            obj_.original_tagname_ = 'ContainerRef'


# end class ContainerRefSetType


class ContainerRefType(GeneratedsSuper):
    """Holds a reference to a containername of container"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, containerRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.containerRef = _cast(None, containerRef)
        self.containerRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContainerRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContainerRefType.subclass:
            return ContainerRefType.subclass(*args_, **kwargs_)
        else:
            return ContainerRefType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_containerRef(self):
        return self.containerRef

    def set_containerRef(self, containerRef):
        self.containerRef = containerRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ContainerRefType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContainerRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContainerRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContainerRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContainerRefType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContainerRefType'):
        if self.containerRef is not None and 'containerRef' not in already_processed:
            already_processed.add('containerRef')
            outfile.write(' containerRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.containerRef), input_name='containerRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ContainerRefType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('containerRef', node)
        if value is not None and 'containerRef' not in already_processed:
            already_processed.add('containerRef')
            self.containerRef = value
            self.validate_NameReferenceType(self.containerRef)  # validate type NameReferenceType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ContainerRefType


class ContainerSetType(GeneratedsSuper):
    """Unordered Set of Containers"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, SequenceContainer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SequenceContainer is None:
            self.SequenceContainer = []
        else:
            self.SequenceContainer = SequenceContainer
        self.SequenceContainer_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContainerSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContainerSetType.subclass:
            return ContainerSetType.subclass(*args_, **kwargs_)
        else:
            return ContainerSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SequenceContainer(self)  -> ['SequenceContainer']:
        return self.SequenceContainer

    def set_SequenceContainer(self, SequenceContainer):
        self.SequenceContainer = SequenceContainer

    def add_SequenceContainer(self, value):
        self.SequenceContainer.append(value)

    def insert_SequenceContainer_at(self, index, value):
        self.SequenceContainer.insert(index, value)

    def replace_SequenceContainer_at(self, index, value):
        self.SequenceContainer[index] = value

    def hasContent_(self):
        if (
                self.SequenceContainer
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ContainerSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContainerSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContainerSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContainerSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContainerSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContainerSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ContainerSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SequenceContainer_ in self.SequenceContainer:
            namespaceprefix_ = self.SequenceContainer_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SequenceContainer_nsprefix_) else ''
            SequenceContainer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SequenceContainer',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SequenceContainer':
            obj_ = SequenceContainerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SequenceContainer.append(obj_)
            obj_.original_tagname_ = 'SequenceContainer'


# end class ContainerSetType


class EntryListType(GeneratedsSuper):
    """Contains an ordered list of Entries. Used in Sequence Container"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ParameterRefEntry=None, ParameterSegmentRefEntry=None, ContainerRefEntry=None,
                 ContainerSegmentRefEntry=None, StreamSegmentEntry=None, IndirectParameterRefEntry=None,
                 ArrayParameterRefEntry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ParameterRefEntry is None:
            self.ParameterRefEntry = []
        else:
            self.ParameterRefEntry = ParameterRefEntry
        self.ParameterRefEntry_nsprefix_ = None
        if ParameterSegmentRefEntry is None:
            self.ParameterSegmentRefEntry = []
        else:
            self.ParameterSegmentRefEntry = ParameterSegmentRefEntry
        self.ParameterSegmentRefEntry_nsprefix_ = None
        if ContainerRefEntry is None:
            self.ContainerRefEntry = []
        else:
            self.ContainerRefEntry = ContainerRefEntry
        self.ContainerRefEntry_nsprefix_ = None
        if ContainerSegmentRefEntry is None:
            self.ContainerSegmentRefEntry = []
        else:
            self.ContainerSegmentRefEntry = ContainerSegmentRefEntry
        self.ContainerSegmentRefEntry_nsprefix_ = None
        if StreamSegmentEntry is None:
            self.StreamSegmentEntry = []
        else:
            self.StreamSegmentEntry = StreamSegmentEntry
        self.StreamSegmentEntry_nsprefix_ = None
        if IndirectParameterRefEntry is None:
            self.IndirectParameterRefEntry = []
        else:
            self.IndirectParameterRefEntry = IndirectParameterRefEntry
        self.IndirectParameterRefEntry_nsprefix_ = None
        if ArrayParameterRefEntry is None:
            self.ArrayParameterRefEntry = []
        else:
            self.ArrayParameterRefEntry = ArrayParameterRefEntry
        self.ArrayParameterRefEntry_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntryListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntryListType.subclass:
            return EntryListType.subclass(*args_, **kwargs_)
        else:
            return EntryListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ParameterRefEntry(self) -> '[ParameterRefEntryType]':
        return self.ParameterRefEntry

    def set_ParameterRefEntry(self, ParameterRefEntry):
        self.ParameterRefEntry = ParameterRefEntry

    def add_ParameterRefEntry(self, value):
        self.ParameterRefEntry.append(value)

    def insert_ParameterRefEntry_at(self, index, value):
        self.ParameterRefEntry.insert(index, value)

    def replace_ParameterRefEntry_at(self, index, value):
        self.ParameterRefEntry[index] = value

    def get_ParameterSegmentRefEntry(self):
        return self.ParameterSegmentRefEntry

    def set_ParameterSegmentRefEntry(self, ParameterSegmentRefEntry):
        self.ParameterSegmentRefEntry = ParameterSegmentRefEntry

    def add_ParameterSegmentRefEntry(self, value):
        self.ParameterSegmentRefEntry.append(value)

    def insert_ParameterSegmentRefEntry_at(self, index, value):
        self.ParameterSegmentRefEntry.insert(index, value)

    def replace_ParameterSegmentRefEntry_at(self, index, value):
        self.ParameterSegmentRefEntry[index] = value

    def get_ContainerRefEntry(self):
        return self.ContainerRefEntry

    def set_ContainerRefEntry(self, ContainerRefEntry):
        self.ContainerRefEntry = ContainerRefEntry

    def add_ContainerRefEntry(self, value):
        self.ContainerRefEntry.append(value)

    def insert_ContainerRefEntry_at(self, index, value):
        self.ContainerRefEntry.insert(index, value)

    def replace_ContainerRefEntry_at(self, index, value):
        self.ContainerRefEntry[index] = value

    def get_ContainerSegmentRefEntry(self):
        return self.ContainerSegmentRefEntry

    def set_ContainerSegmentRefEntry(self, ContainerSegmentRefEntry):
        self.ContainerSegmentRefEntry = ContainerSegmentRefEntry

    def add_ContainerSegmentRefEntry(self, value):
        self.ContainerSegmentRefEntry.append(value)

    def insert_ContainerSegmentRefEntry_at(self, index, value):
        self.ContainerSegmentRefEntry.insert(index, value)

    def replace_ContainerSegmentRefEntry_at(self, index, value):
        self.ContainerSegmentRefEntry[index] = value

    def get_StreamSegmentEntry(self):
        return self.StreamSegmentEntry

    def set_StreamSegmentEntry(self, StreamSegmentEntry):
        self.StreamSegmentEntry = StreamSegmentEntry

    def add_StreamSegmentEntry(self, value):
        self.StreamSegmentEntry.append(value)

    def insert_StreamSegmentEntry_at(self, index, value):
        self.StreamSegmentEntry.insert(index, value)

    def replace_StreamSegmentEntry_at(self, index, value):
        self.StreamSegmentEntry[index] = value

    def get_IndirectParameterRefEntry(self):
        return self.IndirectParameterRefEntry

    def set_IndirectParameterRefEntry(self, IndirectParameterRefEntry):
        self.IndirectParameterRefEntry = IndirectParameterRefEntry

    def add_IndirectParameterRefEntry(self, value):
        self.IndirectParameterRefEntry.append(value)

    def insert_IndirectParameterRefEntry_at(self, index, value):
        self.IndirectParameterRefEntry.insert(index, value)

    def replace_IndirectParameterRefEntry_at(self, index, value):
        self.IndirectParameterRefEntry[index] = value

    def get_ArrayParameterRefEntry(self):
        return self.ArrayParameterRefEntry

    def set_ArrayParameterRefEntry(self, ArrayParameterRefEntry):
        self.ArrayParameterRefEntry = ArrayParameterRefEntry

    def add_ArrayParameterRefEntry(self, value):
        self.ArrayParameterRefEntry.append(value)

    def insert_ArrayParameterRefEntry_at(self, index, value):
        self.ArrayParameterRefEntry.insert(index, value)

    def replace_ArrayParameterRefEntry_at(self, index, value):
        self.ArrayParameterRefEntry[index] = value

    def hasContent_(self):
        if (
                self.ParameterRefEntry or
                self.ParameterSegmentRefEntry or
                self.ContainerRefEntry or
                self.ContainerSegmentRefEntry or
                self.StreamSegmentEntry or
                self.IndirectParameterRefEntry or
                self.ArrayParameterRefEntry
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='EntryListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntryListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntryListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntryListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EntryListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EntryListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='EntryListType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ParameterRefEntry_ in self.ParameterRefEntry:
            namespaceprefix_ = self.ParameterRefEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterRefEntry_nsprefix_) else ''
            ParameterRefEntry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ParameterRefEntry',
                                      pretty_print=pretty_print)
        for ParameterSegmentRefEntry_ in self.ParameterSegmentRefEntry:
            namespaceprefix_ = self.ParameterSegmentRefEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterSegmentRefEntry_nsprefix_) else ''
            ParameterSegmentRefEntry_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='ParameterSegmentRefEntry', pretty_print=pretty_print)
        for ContainerRefEntry_ in self.ContainerRefEntry:
            namespaceprefix_ = self.ContainerRefEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContainerRefEntry_nsprefix_) else ''
            ContainerRefEntry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContainerRefEntry',
                                      pretty_print=pretty_print)
        for ContainerSegmentRefEntry_ in self.ContainerSegmentRefEntry:
            namespaceprefix_ = self.ContainerSegmentRefEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContainerSegmentRefEntry_nsprefix_) else ''
            ContainerSegmentRefEntry_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='ContainerSegmentRefEntry', pretty_print=pretty_print)
        for StreamSegmentEntry_ in self.StreamSegmentEntry:
            namespaceprefix_ = self.StreamSegmentEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.StreamSegmentEntry_nsprefix_) else ''
            StreamSegmentEntry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StreamSegmentEntry',
                                       pretty_print=pretty_print)
        for IndirectParameterRefEntry_ in self.IndirectParameterRefEntry:
            namespaceprefix_ = self.IndirectParameterRefEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.IndirectParameterRefEntry_nsprefix_) else ''
            IndirectParameterRefEntry_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                              name_='IndirectParameterRefEntry', pretty_print=pretty_print)
        for ArrayParameterRefEntry_ in self.ArrayParameterRefEntry:
            namespaceprefix_ = self.ArrayParameterRefEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ArrayParameterRefEntry_nsprefix_) else ''
            ArrayParameterRefEntry_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='ArrayParameterRefEntry', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ParameterRefEntry':
            obj_ = ParameterRefEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterRefEntry.append(obj_)
            obj_.original_tagname_ = 'ParameterRefEntry'
        elif nodeName_ == 'ParameterSegmentRefEntry':
            obj_ = ParameterSegmentRefEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterSegmentRefEntry.append(obj_)
            obj_.original_tagname_ = 'ParameterSegmentRefEntry'
        elif nodeName_ == 'ContainerRefEntry':
            obj_ = ContainerRefEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContainerRefEntry.append(obj_)
            obj_.original_tagname_ = 'ContainerRefEntry'
        elif nodeName_ == 'ContainerSegmentRefEntry':
            obj_ = ContainerSegmentRefEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContainerSegmentRefEntry.append(obj_)
            obj_.original_tagname_ = 'ContainerSegmentRefEntry'
        elif nodeName_ == 'StreamSegmentEntry':
            obj_ = StreamSegmentEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StreamSegmentEntry.append(obj_)
            obj_.original_tagname_ = 'StreamSegmentEntry'
        elif nodeName_ == 'IndirectParameterRefEntry':
            obj_ = IndirectParameterRefEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IndirectParameterRefEntry.append(obj_)
            obj_.original_tagname_ = 'IndirectParameterRefEntry'
        elif nodeName_ == 'ArrayParameterRefEntry':
            obj_ = ArrayParameterRefEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ArrayParameterRefEntry.append(obj_)
            obj_.original_tagname_ = 'ArrayParameterRefEntry'


# end class EntryListType


class MessageRefType(GeneratedsSuper):
    """Holds a reference to a messagename of message"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, messageRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.messageRef = _cast(None, messageRef)
        self.messageRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageRefType.subclass:
            return MessageRefType.subclass(*args_, **kwargs_)
        else:
            return MessageRefType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_messageRef(self):
        return self.messageRef

    def set_messageRef(self, messageRef):
        self.messageRef = messageRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MessageRefType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MessageRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MessageRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessageRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MessageRefType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MessageRefType'):
        if self.messageRef is not None and 'messageRef' not in already_processed:
            already_processed.add('messageRef')
            outfile.write(' messageRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.messageRef), input_name='messageRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MessageRefType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('messageRef', node)
        if value is not None and 'messageRef' not in already_processed:
            already_processed.add('messageRef')
            self.messageRef = value
            self.validate_NameReferenceType(self.messageRef)  # validate type NameReferenceType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class MessageRefType


class SequenceEntryType(GeneratedsSuper):
    """Defines an abstract schema type used to create other entry types.
    Describe an entry’s location in the container (See
    LocationInContainerInBitsType). The location may be fixed or dynamic,
    absolute or relative. Entries may be included depending on the value of
    a condition (See IncludeConditionType), and entries may also repeat
    (see RepeatEntryType). The entry’s IncludeCondition resolves to true,
    it is fully-resolved when its size is computable after RepeatEntry has
    been accounted for and then offset by LocationInContainer. See
    EntryListType, IncludeConditionType, RepeatEntryType and
    LocationInContainerInBitsType.Optional short description for this entry
    element."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 TimeAssociation=None, AncillaryDataSet=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.shortDescription = _cast(None, shortDescription)
        self.shortDescription_nsprefix_ = None
        self.LocationInContainerInBits = LocationInContainerInBits
        self.LocationInContainerInBits_nsprefix_ = None
        self.RepeatEntry = RepeatEntry
        self.RepeatEntry_nsprefix_ = None
        self.IncludeCondition = IncludeCondition
        self.IncludeCondition_nsprefix_ = None
        self.TimeAssociation = TimeAssociation
        self.TimeAssociation_nsprefix_ = None
        self.AncillaryDataSet = AncillaryDataSet
        self.AncillaryDataSet_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SequenceEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SequenceEntryType.subclass:
            return SequenceEntryType.subclass(*args_, **kwargs_)
        else:
            return SequenceEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocationInContainerInBits(self):
        return self.LocationInContainerInBits

    def set_LocationInContainerInBits(self, LocationInContainerInBits):
        self.LocationInContainerInBits = LocationInContainerInBits

    def get_RepeatEntry(self):
        return self.RepeatEntry

    def set_RepeatEntry(self, RepeatEntry):
        self.RepeatEntry = RepeatEntry

    def get_IncludeCondition(self):
        return self.IncludeCondition

    def set_IncludeCondition(self, IncludeCondition):
        self.IncludeCondition = IncludeCondition

    def get_TimeAssociation(self):
        return self.TimeAssociation

    def set_TimeAssociation(self, TimeAssociation):
        self.TimeAssociation = TimeAssociation

    def get_AncillaryDataSet(self):
        return self.AncillaryDataSet

    def set_AncillaryDataSet(self, AncillaryDataSet):
        self.AncillaryDataSet = AncillaryDataSet

    def get_shortDescription(self):
        return self.shortDescription

    def set_shortDescription(self, shortDescription):
        self.shortDescription = shortDescription

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_ShortDescriptionType(self, value):
        # Validate type xtce:ShortDescriptionType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            pass

    def hasContent_(self):
        if (
                self.LocationInContainerInBits is not None or
                self.RepeatEntry is not None or
                self.IncludeCondition is not None or
                self.TimeAssociation is not None or
                self.AncillaryDataSet is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='SequenceEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SequenceEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SequenceEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SequenceEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SequenceEntryType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SequenceEntryType'):
        if self.shortDescription is not None and 'shortDescription' not in already_processed:
            already_processed.add('shortDescription')
            outfile.write(' shortDescription=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.shortDescription), input_name='shortDescription')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='SequenceEntryType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LocationInContainerInBits is not None:
            namespaceprefix_ = self.LocationInContainerInBits_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.LocationInContainerInBits_nsprefix_) else ''
            self.LocationInContainerInBits.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                  name_='LocationInContainerInBits', pretty_print=pretty_print)
        if self.RepeatEntry is not None:
            namespaceprefix_ = self.RepeatEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.RepeatEntry_nsprefix_) else ''
            self.RepeatEntry.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RepeatEntry',
                                    pretty_print=pretty_print)
        if self.IncludeCondition is not None:
            namespaceprefix_ = self.IncludeCondition_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.IncludeCondition_nsprefix_) else ''
            self.IncludeCondition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IncludeCondition',
                                         pretty_print=pretty_print)
        if self.TimeAssociation is not None:
            namespaceprefix_ = self.TimeAssociation_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TimeAssociation_nsprefix_) else ''
            self.TimeAssociation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeAssociation',
                                        pretty_print=pretty_print)
        if self.AncillaryDataSet is not None:
            namespaceprefix_ = self.AncillaryDataSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AncillaryDataSet_nsprefix_) else ''
            self.AncillaryDataSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AncillaryDataSet',
                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('shortDescription', node)
        if value is not None and 'shortDescription' not in already_processed:
            already_processed.add('shortDescription')
            self.shortDescription = value
            self.validate_ShortDescriptionType(self.shortDescription)  # validate type ShortDescriptionType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LocationInContainerInBits':
            obj_ = LocationInContainerInBitsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocationInContainerInBits = obj_
            obj_.original_tagname_ = 'LocationInContainerInBits'
        elif nodeName_ == 'RepeatEntry':
            obj_ = RepeatType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RepeatEntry = obj_
            obj_.original_tagname_ = 'RepeatEntry'
        elif nodeName_ == 'IncludeCondition':
            class_obj_ = self.get_class_obj_(child_, MatchCriteriaType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IncludeCondition = obj_
            obj_.original_tagname_ = 'IncludeCondition'
        elif nodeName_ == 'TimeAssociation':
            obj_ = TimeAssociationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeAssociation = obj_
            obj_.original_tagname_ = 'TimeAssociation'
        elif nodeName_ == 'AncillaryDataSet':
            obj_ = AncillaryDataSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AncillaryDataSet = obj_
            obj_.original_tagname_ = 'AncillaryDataSet'


# end class SequenceEntryType


class ArgumentSequenceEntryType(GeneratedsSuper):
    """Identical to a SequenceEntryType but supports argument instance
    references.Optional short description for this entry element."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 AncillaryDataSet=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.shortDescription = _cast(None, shortDescription)
        self.shortDescription_nsprefix_ = None
        self.LocationInContainerInBits = LocationInContainerInBits
        self.LocationInContainerInBits_nsprefix_ = None
        self.RepeatEntry = RepeatEntry
        self.RepeatEntry_nsprefix_ = None
        self.IncludeCondition = IncludeCondition
        self.IncludeCondition_nsprefix_ = None
        self.AncillaryDataSet = AncillaryDataSet
        self.AncillaryDataSet_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentSequenceEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentSequenceEntryType.subclass:
            return ArgumentSequenceEntryType.subclass(*args_, **kwargs_)
        else:
            return ArgumentSequenceEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LocationInContainerInBits(self):
        return self.LocationInContainerInBits

    def set_LocationInContainerInBits(self, LocationInContainerInBits):
        self.LocationInContainerInBits = LocationInContainerInBits

    def get_RepeatEntry(self):
        return self.RepeatEntry

    def set_RepeatEntry(self, RepeatEntry):
        self.RepeatEntry = RepeatEntry

    def get_IncludeCondition(self):
        return self.IncludeCondition

    def set_IncludeCondition(self, IncludeCondition):
        self.IncludeCondition = IncludeCondition

    def get_AncillaryDataSet(self):
        return self.AncillaryDataSet

    def set_AncillaryDataSet(self, AncillaryDataSet):
        self.AncillaryDataSet = AncillaryDataSet

    def get_shortDescription(self):
        return self.shortDescription

    def set_shortDescription(self, shortDescription):
        self.shortDescription = shortDescription

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_ShortDescriptionType(self, value):
        # Validate type xtce:ShortDescriptionType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            pass

    def hasContent_(self):
        if (
                self.LocationInContainerInBits is not None or
                self.RepeatEntry is not None or
                self.IncludeCondition is not None or
                self.AncillaryDataSet is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentSequenceEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentSequenceEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentSequenceEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentSequenceEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentSequenceEntryType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentSequenceEntryType'):
        if self.shortDescription is not None and 'shortDescription' not in already_processed:
            already_processed.add('shortDescription')
            outfile.write(' shortDescription=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.shortDescription), input_name='shortDescription')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ArgumentSequenceEntryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LocationInContainerInBits is not None:
            namespaceprefix_ = self.LocationInContainerInBits_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.LocationInContainerInBits_nsprefix_) else ''
            self.LocationInContainerInBits.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                  name_='LocationInContainerInBits', pretty_print=pretty_print)
        if self.RepeatEntry is not None:
            namespaceprefix_ = self.RepeatEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.RepeatEntry_nsprefix_) else ''
            self.RepeatEntry.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RepeatEntry',
                                    pretty_print=pretty_print)
        if self.IncludeCondition is not None:
            namespaceprefix_ = self.IncludeCondition_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.IncludeCondition_nsprefix_) else ''
            self.IncludeCondition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IncludeCondition',
                                         pretty_print=pretty_print)
        if self.AncillaryDataSet is not None:
            namespaceprefix_ = self.AncillaryDataSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AncillaryDataSet_nsprefix_) else ''
            self.AncillaryDataSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AncillaryDataSet',
                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('shortDescription', node)
        if value is not None and 'shortDescription' not in already_processed:
            already_processed.add('shortDescription')
            self.shortDescription = value
            self.validate_ShortDescriptionType(self.shortDescription)  # validate type ShortDescriptionType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LocationInContainerInBits':
            obj_ = ArgumentLocationInContainerInBitsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocationInContainerInBits = obj_
            obj_.original_tagname_ = 'LocationInContainerInBits'
        elif nodeName_ == 'RepeatEntry':
            obj_ = ArgumentRepeatType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RepeatEntry = obj_
            obj_.original_tagname_ = 'RepeatEntry'
        elif nodeName_ == 'IncludeCondition':
            class_obj_ = self.get_class_obj_(child_, ArgumentMatchCriteriaType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IncludeCondition = obj_
            obj_.original_tagname_ = 'IncludeCondition'
        elif nodeName_ == 'AncillaryDataSet':
            obj_ = AncillaryDataSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AncillaryDataSet = obj_
            obj_.original_tagname_ = 'AncillaryDataSet'


# end class ArgumentSequenceEntryType


class StreamSegmentEntryType(SequenceEntryType):
    """An entry that is a portion of a stream (streams are by definition,
    assumed continuous) It is assumed that stream segments happen
    sequentially in time, that is the first part if a steam first, however,
    if this is not the case the order of the stream segments may be
    supplied with the order attribute where the first segment order="0"."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 TimeAssociation=None, AncillaryDataSet=None, streamRef=None, order=None, sizeInBits=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(StreamSegmentEntryType, self).__init__(shortDescription, LocationInContainerInBits, RepeatEntry,
                                                     IncludeCondition, TimeAssociation, AncillaryDataSet, **kwargs_)
        self.streamRef = _cast(None, streamRef)
        self.streamRef_nsprefix_ = None
        self.order = _cast(int, order)
        self.order_nsprefix_ = None
        self.sizeInBits = _cast(int, sizeInBits)
        self.sizeInBits_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreamSegmentEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreamSegmentEntryType.subclass:
            return StreamSegmentEntryType.subclass(*args_, **kwargs_)
        else:
            return StreamSegmentEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_streamRef(self):
        return self.streamRef

    def set_streamRef(self, streamRef):
        self.streamRef = streamRef

    def get_order(self):
        return self.order

    def set_order(self, order):
        self.order = order

    def get_sizeInBits(self):
        return self.sizeInBits

    def set_sizeInBits(self, sizeInBits):
        self.sizeInBits = sizeInBits

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(StreamSegmentEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='StreamSegmentEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StreamSegmentEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StreamSegmentEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StreamSegmentEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StreamSegmentEntryType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StreamSegmentEntryType'):
        super(StreamSegmentEntryType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                             name_='StreamSegmentEntryType')
        if self.streamRef is not None and 'streamRef' not in already_processed:
            already_processed.add('streamRef')
            outfile.write(' streamRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.streamRef), input_name='streamRef')),))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order="%s"' % self.gds_format_integer(self.order, input_name='order'))
        if self.sizeInBits is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            outfile.write(' sizeInBits="%s"' % self.gds_format_integer(self.sizeInBits, input_name='sizeInBits'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='StreamSegmentEntryType', fromsubclass_=False, pretty_print=True):
        super(StreamSegmentEntryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                           pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('streamRef', node)
        if value is not None and 'streamRef' not in already_processed:
            already_processed.add('streamRef')
            self.streamRef = value
            self.validate_NameReferenceType(self.streamRef)  # validate type NameReferenceType
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            self.order = self.gds_parse_integer(value, node, 'order')
            self.validate_PositiveLongType(self.order)  # validate type PositiveLongType
        value = find_attr_value_('sizeInBits', node)
        if value is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            self.sizeInBits = self.gds_parse_integer(value, node, 'sizeInBits')
            self.validate_PositiveLongType(self.sizeInBits)  # validate type PositiveLongType
        super(StreamSegmentEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(StreamSegmentEntryType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class StreamSegmentEntryType


class RateInStreamSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, RateInStream=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if RateInStream is None:
            self.RateInStream = []
        else:
            self.RateInStream = RateInStream
        self.RateInStream_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateInStreamSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateInStreamSetType.subclass:
            return RateInStreamSetType.subclass(*args_, **kwargs_)
        else:
            return RateInStreamSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_RateInStream(self):
        return self.RateInStream

    def set_RateInStream(self, RateInStream):
        self.RateInStream = RateInStream

    def add_RateInStream(self, value):
        self.RateInStream.append(value)

    def insert_RateInStream_at(self, index, value):
        self.RateInStream.insert(index, value)

    def replace_RateInStream_at(self, index, value):
        self.RateInStream[index] = value

    def hasContent_(self):
        if (
                self.RateInStream
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='RateInStreamSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RateInStreamSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RateInStreamSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RateInStreamSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RateInStreamSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RateInStreamSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='RateInStreamSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RateInStream_ in self.RateInStream:
            namespaceprefix_ = self.RateInStream_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.RateInStream_nsprefix_) else ''
            RateInStream_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RateInStream',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RateInStream':
            obj_ = RateInStreamWithStreamNameType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RateInStream.append(obj_)
            obj_.original_tagname_ = 'RateInStream'


# end class RateInStreamSetType


class RateInStreamType(GeneratedsSuper):
    """Define the expected appearance (rate) of a container in a stream where
    the rate is defined on either a perSecond or perContainer update basis.
    Many programs and platforms have variable reporting rates for
    containers and these can be commanded. As a result, this element is
    only useful to some users and generally does not affect the processing
    of the received containers themselves. See ContainerType.The
    measurement unit basis for the minimum and maximum appearance count
    values.The minimum rate for the specified basis for which this
    container should appear in the stream.The maximum rate for the
    specified basis for which this container should appear in the
    stream."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, basis='perSecond', minimumValue=None, maximumValue=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.basis = _cast(None, basis)
        self.basis_nsprefix_ = None
        self.minimumValue = _cast(float, minimumValue)
        self.minimumValue_nsprefix_ = None
        self.maximumValue = _cast(float, maximumValue)
        self.maximumValue_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateInStreamType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateInStreamType.subclass:
            return RateInStreamType.subclass(*args_, **kwargs_)
        else:
            return RateInStreamType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_basis(self):
        return self.basis

    def set_basis(self, basis):
        self.basis = basis

    def get_minimumValue(self):
        return self.minimumValue

    def set_minimumValue(self, minimumValue):
        self.minimumValue = minimumValue

    def get_maximumValue(self):
        return self.maximumValue

    def set_maximumValue(self, maximumValue):
        self.maximumValue = maximumValue

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_BasisType(self, value):
        # Validate type xtce:BasisType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['perSecond', 'perContainerUpdate']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BasisType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='RateInStreamType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RateInStreamType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RateInStreamType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RateInStreamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RateInStreamType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RateInStreamType'):
        if self.basis != "perSecond" and 'basis' not in already_processed:
            already_processed.add('basis')
            outfile.write(
                ' basis=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.basis), input_name='basis')),))
        if self.minimumValue is not None and 'minimumValue' not in already_processed:
            already_processed.add('minimumValue')
            outfile.write(' minimumValue="%s"' % self.gds_format_double(self.minimumValue, input_name='minimumValue'))
        if self.maximumValue is not None and 'maximumValue' not in already_processed:
            already_processed.add('maximumValue')
            outfile.write(' maximumValue="%s"' % self.gds_format_double(self.maximumValue, input_name='maximumValue'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='RateInStreamType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('basis', node)
        if value is not None and 'basis' not in already_processed:
            already_processed.add('basis')
            self.basis = value
            self.validate_BasisType(self.basis)  # validate type BasisType
        value = find_attr_value_('minimumValue', node)
        if value is not None and 'minimumValue' not in already_processed:
            already_processed.add('minimumValue')
            value = self.gds_parse_double(value, node, 'minimumValue')
            self.minimumValue = value
        value = find_attr_value_('maximumValue', node)
        if value is not None and 'maximumValue' not in already_processed:
            already_processed.add('maximumValue')
            value = self.gds_parse_double(value, node, 'maximumValue')
            self.maximumValue = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class RateInStreamType


class RateInStreamWithStreamNameType(RateInStreamType):
    """Define the expected appearance (rate) of a container in a named stream
    where the rate is defined on either a perSecond or perContainer update
    basis. Many programs and platforms have variable reporting rates for
    containers and these can be commanded. As a result, this element is
    only useful to some users and generally does not affect the processing
    of the received containers themselves. See ContainerType and
    RateInStreamType.Reference to a named stream for which this rate
    specification applies."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RateInStreamType

    def __init__(self, basis='perSecond', minimumValue=None, maximumValue=None, streamRef=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RateInStreamWithStreamNameType, self).__init__(basis, minimumValue, maximumValue, **kwargs_)
        self.streamRef = _cast(None, streamRef)
        self.streamRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateInStreamWithStreamNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateInStreamWithStreamNameType.subclass:
            return RateInStreamWithStreamNameType.subclass(*args_, **kwargs_)
        else:
            return RateInStreamWithStreamNameType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_streamRef(self):
        return self.streamRef

    def set_streamRef(self, streamRef):
        self.streamRef = streamRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                super(RateInStreamWithStreamNameType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
               name_='RateInStreamWithStreamNameType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RateInStreamWithStreamNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RateInStreamWithStreamNameType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='RateInStreamWithStreamNameType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='RateInStreamWithStreamNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='RateInStreamWithStreamNameType'):
        super(RateInStreamWithStreamNameType, self).exportAttributes(outfile, level, already_processed,
                                                                     namespaceprefix_,
                                                                     name_='RateInStreamWithStreamNameType')
        if self.streamRef is not None and 'streamRef' not in already_processed:
            already_processed.add('streamRef')
            outfile.write(' streamRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.streamRef), input_name='streamRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='RateInStreamWithStreamNameType', fromsubclass_=False, pretty_print=True):
        super(RateInStreamWithStreamNameType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_,
                                                                   name_, True, pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('streamRef', node)
        if value is not None and 'streamRef' not in already_processed:
            already_processed.add('streamRef')
            self.streamRef = value
            self.validate_NameReferenceType(self.streamRef)  # validate type NameReferenceType
        super(RateInStreamWithStreamNameType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(RateInStreamWithStreamNameType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class RateInStreamWithStreamNameType


class EnumerationContextAlarmListType(GeneratedsSuper):
    """Describe an ordered collection of context enumeration alarms, duplicates
    are valid. Process the contexts in list order. See
    EnumerationContextAlarmType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ContextAlarm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ContextAlarm is None:
            self.ContextAlarm = []
        else:
            self.ContextAlarm = ContextAlarm
        self.ContextAlarm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnumerationContextAlarmListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnumerationContextAlarmListType.subclass:
            return EnumerationContextAlarmListType.subclass(*args_, **kwargs_)
        else:
            return EnumerationContextAlarmListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextAlarm(self):
        return self.ContextAlarm

    def set_ContextAlarm(self, ContextAlarm):
        self.ContextAlarm = ContextAlarm

    def add_ContextAlarm(self, value):
        self.ContextAlarm.append(value)

    def insert_ContextAlarm_at(self, index, value):
        self.ContextAlarm.insert(index, value)

    def replace_ContextAlarm_at(self, index, value):
        self.ContextAlarm[index] = value

    def hasContent_(self):
        if (
                self.ContextAlarm
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
               name_='EnumerationContextAlarmListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnumerationContextAlarmListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EnumerationContextAlarmListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='EnumerationContextAlarmListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='EnumerationContextAlarmListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='EnumerationContextAlarmListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='EnumerationContextAlarmListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContextAlarm_ in self.ContextAlarm:
            namespaceprefix_ = self.ContextAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextAlarm_nsprefix_) else ''
            ContextAlarm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextAlarm',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextAlarm':
            obj_ = EnumerationContextAlarmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextAlarm.append(obj_)
            obj_.original_tagname_ = 'ContextAlarm'


# end class EnumerationContextAlarmListType


class MessageRefSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, MessageRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if MessageRef is None:
            self.MessageRef = []
        else:
            self.MessageRef = MessageRef
        self.MessageRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageRefSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageRefSetType.subclass:
            return MessageRefSetType.subclass(*args_, **kwargs_)
        else:
            return MessageRefSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MessageRef(self):
        return self.MessageRef

    def set_MessageRef(self, MessageRef):
        self.MessageRef = MessageRef

    def add_MessageRef(self, value):
        self.MessageRef.append(value)

    def insert_MessageRef_at(self, index, value):
        self.MessageRef.insert(index, value)

    def replace_MessageRef_at(self, index, value):
        self.MessageRef[index] = value

    def hasContent_(self):
        if (
                self.MessageRef
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MessageRefSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MessageRefSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MessageRefSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessageRefSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MessageRefSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MessageRefSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MessageRefSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MessageRef_ in self.MessageRef:
            namespaceprefix_ = self.MessageRef_nsprefix_ + ':' if (UseCapturedNS_ and self.MessageRef_nsprefix_) else ''
            MessageRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MessageRef',
                               pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MessageRef':
            obj_ = MessageRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MessageRef.append(obj_)
            obj_.original_tagname_ = 'MessageRef'


# end class MessageRefSetType


class NumericContextAlarmListType(GeneratedsSuper):
    """An ordered collection of numeric alarms associated with a context. A
    context is an alarm definition on a parameter which is valid only in
    the case of a test on the value of other parameters. Process the
    contexts in list order. Used by both FloatParameterType and
    IntegerParameterType. See NumericContextAlarmType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ContextAlarm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ContextAlarm is None:
            self.ContextAlarm = []
        else:
            self.ContextAlarm = ContextAlarm
        self.ContextAlarm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumericContextAlarmListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumericContextAlarmListType.subclass:
            return NumericContextAlarmListType.subclass(*args_, **kwargs_)
        else:
            return NumericContextAlarmListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextAlarm(self):
        return self.ContextAlarm

    def set_ContextAlarm(self, ContextAlarm):
        self.ContextAlarm = ContextAlarm

    def add_ContextAlarm(self, value):
        self.ContextAlarm.append(value)

    def insert_ContextAlarm_at(self, index, value):
        self.ContextAlarm.insert(index, value)

    def replace_ContextAlarm_at(self, index, value):
        self.ContextAlarm[index] = value

    def hasContent_(self):
        if (
                self.ContextAlarm
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='NumericContextAlarmListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumericContextAlarmListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NumericContextAlarmListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumericContextAlarmListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='NumericContextAlarmListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='NumericContextAlarmListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='NumericContextAlarmListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContextAlarm_ in self.ContextAlarm:
            namespaceprefix_ = self.ContextAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextAlarm_nsprefix_) else ''
            ContextAlarm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextAlarm',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextAlarm':
            obj_ = NumericContextAlarmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextAlarm.append(obj_)
            obj_.original_tagname_ = 'ContextAlarm'


# end class NumericContextAlarmListType


class ParameterPropertiesType(GeneratedsSuper):
    """Describes extended properties/attributes of Parameter definitions.This
    attribute describes the nature of the source entity for which this
    parameter receives a value. Implementations assign different
    attributes/properties internally to a parameter based on the
    anticipated data source.A Parameter marked as 'readOnly' true is non-
    settable by users and applications/services that do not represent the
    data source itself. Note that a slight conceptual overlap exists here
    between the 'dataSource' attribute and this attribute when the data
    source is 'constant'. For a constant data source, then 'readOnly'
    should be 'true'. Application implementations may choose to implicitly
    enforce this. Some implementations have both concepts of a Parameter
    that is settable or non-settable and a Constant in different parts of
    their internal data model.A Parameter marked to persist should retain
    the latest value through resets/restarts to the extent that is possible
    or defined in the implementation. The net effect is that the
    initial/default value on a Parameter is only seen once or when the
    system has a reset to revert to initial/default values."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, dataSource=None, readOnly=False, persistence=True, SystemName=None, ValidityCondition=None,
                 PhysicalAddressSet=None, TimeAssociation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dataSource = _cast(None, dataSource)
        self.dataSource_nsprefix_ = None
        self.readOnly = _cast(bool, readOnly)
        self.readOnly_nsprefix_ = None
        self.persistence = _cast(bool, persistence)
        self.persistence_nsprefix_ = None
        self.SystemName = SystemName
        self.SystemName_nsprefix_ = None
        self.ValidityCondition = ValidityCondition
        self.ValidityCondition_nsprefix_ = None
        self.PhysicalAddressSet = PhysicalAddressSet
        self.PhysicalAddressSet_nsprefix_ = None
        self.TimeAssociation = TimeAssociation
        self.TimeAssociation_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterPropertiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterPropertiesType.subclass:
            return ParameterPropertiesType.subclass(*args_, **kwargs_)
        else:
            return ParameterPropertiesType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SystemName(self):
        return self.SystemName

    def set_SystemName(self, SystemName):
        self.SystemName = SystemName

    def get_ValidityCondition(self):
        return self.ValidityCondition

    def set_ValidityCondition(self, ValidityCondition):
        self.ValidityCondition = ValidityCondition

    def get_PhysicalAddressSet(self):
        return self.PhysicalAddressSet

    def set_PhysicalAddressSet(self, PhysicalAddressSet):
        self.PhysicalAddressSet = PhysicalAddressSet

    def get_TimeAssociation(self):
        return self.TimeAssociation

    def set_TimeAssociation(self, TimeAssociation):
        self.TimeAssociation = TimeAssociation

    def get_dataSource(self):
        return self.dataSource

    def set_dataSource(self, dataSource):
        self.dataSource = dataSource

    def get_readOnly(self):
        return self.readOnly

    def set_readOnly(self, readOnly):
        self.readOnly = readOnly

    def get_persistence(self):
        return self.persistence

    def set_persistence(self, persistence):
        self.persistence = persistence

    def validate_TelemetryDataSourceType(self, value):
        # Validate type xtce:TelemetryDataSourceType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['telemetered', 'derived', 'constant', 'local', 'ground']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TelemetryDataSourceType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.SystemName is not None or
                self.ValidityCondition is not None or
                self.PhysicalAddressSet is not None or
                self.TimeAssociation is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
               name_='ParameterPropertiesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterPropertiesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterPropertiesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterPropertiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParameterPropertiesType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParameterPropertiesType'):
        if self.dataSource is not None and 'dataSource' not in already_processed:
            already_processed.add('dataSource')
            outfile.write(' dataSource=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.dataSource), input_name='dataSource')),))
        if self.readOnly and 'readOnly' not in already_processed:
            already_processed.add('readOnly')
            outfile.write(' readOnly="%s"' % self.gds_format_boolean(self.readOnly, input_name='readOnly'))
        if not self.persistence and 'persistence' not in already_processed:
            already_processed.add('persistence')
            outfile.write(' persistence="%s"' % self.gds_format_boolean(self.persistence, input_name='persistence'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
                       name_='ParameterPropertiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SystemName is not None:
            namespaceprefix_ = self.SystemName_nsprefix_ + ':' if (UseCapturedNS_ and self.SystemName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSystemName>%s</%sSystemName>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.SystemName), input_name='SystemName')), namespaceprefix_, eol_))
        if self.ValidityCondition is not None:
            namespaceprefix_ = self.ValidityCondition_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ValidityCondition_nsprefix_) else ''
            self.ValidityCondition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ValidityCondition',
                                          pretty_print=pretty_print)
        if self.PhysicalAddressSet is not None:
            namespaceprefix_ = self.PhysicalAddressSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.PhysicalAddressSet_nsprefix_) else ''
            self.PhysicalAddressSet.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='PhysicalAddressSet', pretty_print=pretty_print)
        if self.TimeAssociation is not None:
            namespaceprefix_ = self.TimeAssociation_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TimeAssociation_nsprefix_) else ''
            self.TimeAssociation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeAssociation',
                                        pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataSource', node)
        if value is not None and 'dataSource' not in already_processed:
            already_processed.add('dataSource')
            self.dataSource = value
            self.validate_TelemetryDataSourceType(self.dataSource)  # validate type TelemetryDataSourceType
        value = find_attr_value_('readOnly', node)
        if value is not None and 'readOnly' not in already_processed:
            already_processed.add('readOnly')
            if value in ('true', '1'):
                self.readOnly = True
            elif value in ('false', '0'):
                self.readOnly = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('persistence', node)
        if value is not None and 'persistence' not in already_processed:
            already_processed.add('persistence')
            if value in ('true', '1'):
                self.persistence = True
            elif value in ('false', '0'):
                self.persistence = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SystemName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SystemName')
            value_ = self.gds_validate_string(value_, node, 'SystemName')
            self.SystemName = value_
            self.SystemName_nsprefix_ = child_.prefix
        elif nodeName_ == 'ValidityCondition':
            class_obj_ = self.get_class_obj_(child_, MatchCriteriaType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValidityCondition = obj_
            obj_.original_tagname_ = 'ValidityCondition'
        elif nodeName_ == 'PhysicalAddressSet':
            obj_ = PhysicalAddressSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalAddressSet = obj_
            obj_.original_tagname_ = 'PhysicalAddressSet'
        elif nodeName_ == 'TimeAssociation':
            obj_ = TimeAssociationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeAssociation = obj_
            obj_.original_tagname_ = 'TimeAssociation'


# end class ParameterPropertiesType


class ParameterTypeSetType(GeneratedsSuper):
    """Describe an unordered collection of parameter type definitions. These
    types named for the engineering/calibrated type of the parameter. See
    BaseDataType and BaseTimeDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, StringParameterType=None, EnumeratedParameterType=None, IntegerParameterType=None,
                 BinaryParameterType=None, FloatParameterType=None, BooleanParameterType=None,
                 RelativeTimeParameterType=None, AbsoluteTimeParameterType=None, ArrayParameterType=None,
                 AggregateParameterType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if StringParameterType is None:
            self.StringParameterType = []
        else:
            self.StringParameterType = StringParameterType
        self.StringParameterType_nsprefix_ = None
        if EnumeratedParameterType is None:
            self.EnumeratedParameterType = []
        else:
            self.EnumeratedParameterType = EnumeratedParameterType
        self.EnumeratedParameterType_nsprefix_ = None
        if IntegerParameterType is None:
            self.IntegerParameterType = []
        else:
            self.IntegerParameterType = IntegerParameterType
        self.IntegerParameterType_nsprefix_ = None
        if BinaryParameterType is None:
            self.BinaryParameterType = []
        else:
            self.BinaryParameterType = BinaryParameterType
        self.BinaryParameterType_nsprefix_ = None
        if FloatParameterType is None:
            self.FloatParameterType = []
        else:
            self.FloatParameterType = FloatParameterType
        self.FloatParameterType_nsprefix_ = None
        if BooleanParameterType is None:
            self.BooleanParameterType = []
        else:
            self.BooleanParameterType = BooleanParameterType
        self.BooleanParameterType_nsprefix_ = None
        if RelativeTimeParameterType is None:
            self.RelativeTimeParameterType = []
        else:
            self.RelativeTimeParameterType = RelativeTimeParameterType
        self.RelativeTimeParameterType_nsprefix_ = None
        if AbsoluteTimeParameterType is None:
            self.AbsoluteTimeParameterType = []
        else:
            self.AbsoluteTimeParameterType = AbsoluteTimeParameterType
        self.AbsoluteTimeParameterType_nsprefix_ = None
        if ArrayParameterType is None:
            self.ArrayParameterType = []
        else:
            self.ArrayParameterType = ArrayParameterType
        self.ArrayParameterType_nsprefix_ = None
        if AggregateParameterType is None:
            self.AggregateParameterType = []
        else:
            self.AggregateParameterType = AggregateParameterType
        self.AggregateParameterType_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterTypeSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterTypeSetType.subclass:
            return ParameterTypeSetType.subclass(*args_, **kwargs_)
        else:
            return ParameterTypeSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_StringParameterType(self):
        return self.StringParameterType

    def set_StringParameterType(self, StringParameterType):
        self.StringParameterType = StringParameterType

    def add_StringParameterType(self, value):
        self.StringParameterType.append(value)

    def insert_StringParameterType_at(self, index, value):
        self.StringParameterType.insert(index, value)

    def replace_StringParameterType_at(self, index, value):
        self.StringParameterType[index] = value

    def get_EnumeratedParameterType(self):
        return self.EnumeratedParameterType

    def set_EnumeratedParameterType(self, EnumeratedParameterType):
        self.EnumeratedParameterType = EnumeratedParameterType

    def add_EnumeratedParameterType(self, value):
        self.EnumeratedParameterType.append(value)

    def insert_EnumeratedParameterType_at(self, index, value):
        self.EnumeratedParameterType.insert(index, value)

    def replace_EnumeratedParameterType_at(self, index, value):
        self.EnumeratedParameterType[index] = value

    def get_IntegerParameterType(self):
        return self.IntegerParameterType

    def set_IntegerParameterType(self, IntegerParameterType):
        self.IntegerParameterType = IntegerParameterType

    def add_IntegerParameterType(self, value):
        self.IntegerParameterType.append(value)

    def insert_IntegerParameterType_at(self, index, value):
        self.IntegerParameterType.insert(index, value)

    def replace_IntegerParameterType_at(self, index, value):
        self.IntegerParameterType[index] = value

    def get_BinaryParameterType(self):
        return self.BinaryParameterType

    def set_BinaryParameterType(self, BinaryParameterType):
        self.BinaryParameterType = BinaryParameterType

    def add_BinaryParameterType(self, value):
        self.BinaryParameterType.append(value)

    def insert_BinaryParameterType_at(self, index, value):
        self.BinaryParameterType.insert(index, value)

    def replace_BinaryParameterType_at(self, index, value):
        self.BinaryParameterType[index] = value

    def get_FloatParameterType(self):
        return self.FloatParameterType

    def set_FloatParameterType(self, FloatParameterType):
        self.FloatParameterType = FloatParameterType

    def add_FloatParameterType(self, value):
        self.FloatParameterType.append(value)

    def insert_FloatParameterType_at(self, index, value):
        self.FloatParameterType.insert(index, value)

    def replace_FloatParameterType_at(self, index, value):
        self.FloatParameterType[index] = value

    def get_BooleanParameterType(self):
        return self.BooleanParameterType

    def set_BooleanParameterType(self, BooleanParameterType):
        self.BooleanParameterType = BooleanParameterType

    def add_BooleanParameterType(self, value):
        self.BooleanParameterType.append(value)

    def insert_BooleanParameterType_at(self, index, value):
        self.BooleanParameterType.insert(index, value)

    def replace_BooleanParameterType_at(self, index, value):
        self.BooleanParameterType[index] = value

    def get_RelativeTimeParameterType(self):
        return self.RelativeTimeParameterTypeF

    def set_RelativeTimeParameterType(self, RelativeTimeParameterType):
        self.RelativeTimeParameterType = RelativeTimeParameterType

    def add_RelativeTimeParameterType(self, value):
        self.RelativeTimeParameterType.append(value)

    def insert_RelativeTimeParameterType_at(self, index, value):
        self.RelativeTimeParameterType.insert(index, value)

    def replace_RelativeTimeParameterType_at(self, index, value):
        self.RelativeTimeParameterType[index] = value

    def get_AbsoluteTimeParameterType(self):
        return self.AbsoluteTimeParameterType

    def set_AbsoluteTimeParameterType(self, AbsoluteTimeParameterType):
        self.AbsoluteTimeParameterType = AbsoluteTimeParameterType

    def add_AbsoluteTimeParameterType(self, value):
        self.AbsoluteTimeParameterType.append(value)

    def insert_AbsoluteTimeParameterType_at(self, index, value):
        self.AbsoluteTimeParameterType.insert(index, value)

    def replace_AbsoluteTimeParameterType_at(self, index, value):
        self.AbsoluteTimeParameterType[index] = value

    def get_ArrayParameterType(self):
        return self.ArrayParameterType

    def set_ArrayParameterType(self, ArrayParameterType):
        self.ArrayParameterType = ArrayParameterType

    def add_ArrayParameterType(self, value):
        self.ArrayParameterType.append(value)

    def insert_ArrayParameterType_at(self, index, value):
        self.ArrayParameterType.insert(index, value)

    def replace_ArrayParameterType_at(self, index, value):
        self.ArrayParameterType[index] = value

    def get_AggregateParameterType(self) -> list:
        return self.AggregateParameterType

    def set_AggregateParameterType(self, AggregateParameterType):
        self.AggregateParameterType = AggregateParameterType

    def add_AggregateParameterType(self, value):
        self.AggregateParameterType.append(value)

    def insert_AggregateParameterType_at(self, index, value):
        self.AggregateParameterType.insert(index, value)

    def replace_AggregateParameterType_at(self, index, value):
        self.AggregateParameterType[index] = value

    def hasContent_(self):
        if (
                self.StringParameterType or
                self.EnumeratedParameterType or
                self.IntegerParameterType or
                self.BinaryParameterType or
                self.FloatParameterType or
                self.BooleanParameterType or
                self.RelativeTimeParameterType or
                self.AbsoluteTimeParameterType or
                self.ArrayParameterType or
                self.AggregateParameterType
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ParameterTypeSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterTypeSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterTypeSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterTypeSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParameterTypeSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParameterTypeSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ParameterTypeSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for StringParameterType_ in self.StringParameterType:
            namespaceprefix_ = self.StringParameterType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.StringParameterType_nsprefix_) else ''
            StringParameterType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StringParameterType',
                                        pretty_print=pretty_print)
        for EnumeratedParameterType_ in self.EnumeratedParameterType:
            namespaceprefix_ = self.EnumeratedParameterType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.EnumeratedParameterType_nsprefix_) else ''
            EnumeratedParameterType_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='EnumeratedParameterType', pretty_print=pretty_print)
        for IntegerParameterType_ in self.IntegerParameterType:
            namespaceprefix_ = self.IntegerParameterType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.IntegerParameterType_nsprefix_) else ''
            IntegerParameterType_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                         name_='IntegerParameterType', pretty_print=pretty_print)
        for BinaryParameterType_ in self.BinaryParameterType:
            namespaceprefix_ = self.BinaryParameterType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BinaryParameterType_nsprefix_) else ''
            BinaryParameterType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BinaryParameterType',
                                        pretty_print=pretty_print)
        for FloatParameterType_ in self.FloatParameterType:
            namespaceprefix_ = self.FloatParameterType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.FloatParameterType_nsprefix_) else ''
            FloatParameterType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FloatParameterType',
                                       pretty_print=pretty_print)
        for BooleanParameterType_ in self.BooleanParameterType:
            namespaceprefix_ = self.BooleanParameterType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BooleanParameterType_nsprefix_) else ''
            BooleanParameterType_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                         name_='BooleanParameterType', pretty_print=pretty_print)
        for RelativeTimeParameterType_ in self.RelativeTimeParameterType:
            namespaceprefix_ = self.RelativeTimeParameterType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.RelativeTimeParameterType_nsprefix_) else ''
            RelativeTimeParameterType_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                              name_='RelativeTimeParameterType', pretty_print=pretty_print)
        for AbsoluteTimeParameterType_ in self.AbsoluteTimeParameterType:
            namespaceprefix_ = self.AbsoluteTimeParameterType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AbsoluteTimeParameterType_nsprefix_) else ''
            AbsoluteTimeParameterType_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                              name_='AbsoluteTimeParameterType', pretty_print=pretty_print)
        for ArrayParameterType_ in self.ArrayParameterType:
            namespaceprefix_ = self.ArrayParameterType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ArrayParameterType_nsprefix_) else ''
            ArrayParameterType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ArrayParameterType',
                                       pretty_print=pretty_print)
        for AggregateParameterType_ in self.AggregateParameterType:
            namespaceprefix_ = self.AggregateParameterType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AggregateParameterType_nsprefix_) else ''
            AggregateParameterType_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='AggregateParameterType', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'StringParameterType':
            obj_ = StringParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StringParameterType.append(obj_)
            obj_.original_tagname_ = 'StringParameterType'
        elif nodeName_ == 'EnumeratedParameterType':
            obj_ = EnumeratedParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnumeratedParameterType.append(obj_)
            obj_.original_tagname_ = 'EnumeratedParameterType'
        elif nodeName_ == 'IntegerParameterType':
            obj_ = IntegerParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IntegerParameterType.append(obj_)
            obj_.original_tagname_ = 'IntegerParameterType'
        elif nodeName_ == 'BinaryParameterType':
            obj_ = BinaryParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BinaryParameterType.append(obj_)
            obj_.original_tagname_ = 'BinaryParameterType'
        elif nodeName_ == 'FloatParameterType':
            obj_ = FloatParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FloatParameterType.append(obj_)
            obj_.original_tagname_ = 'FloatParameterType'
        elif nodeName_ == 'BooleanParameterType':
            obj_ = BooleanParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BooleanParameterType.append(obj_)
            obj_.original_tagname_ = 'BooleanParameterType'
        elif nodeName_ == 'RelativeTimeParameterType':
            obj_ = RelativeTimeParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RelativeTimeParameterType.append(obj_)
            obj_.original_tagname_ = 'RelativeTimeParameterType'
        elif nodeName_ == 'AbsoluteTimeParameterType':
            obj_ = AbsoluteTimeParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AbsoluteTimeParameterType.append(obj_)
            obj_.original_tagname_ = 'AbsoluteTimeParameterType'
        elif nodeName_ == 'ArrayParameterType':
            obj_ = ArrayParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ArrayParameterType.append(obj_)
            obj_.original_tagname_ = 'ArrayParameterType'
        elif nodeName_ == 'AggregateParameterType':
            obj_ = AggregateParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AggregateParameterType.append(obj_)
            obj_.original_tagname_ = 'AggregateParameterType'


# end class ParameterTypeSetType


class ParameterRefType(GeneratedsSuper):
    """A reference to a Parameter. Uses Unix ‘like’ naming across the
    SpaceSystem Tree (e.g., SimpleSat/Bus/EPDS/BatteryOne/Voltage). To
    reference an individual member of an array use the zero based bracket
    notation commonly used in languages like C, C++, and Java."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, parameterRef=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.parameterRef = _cast(None, parameterRef)
        self.parameterRef_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterRefType.subclass:
            return ParameterRefType.subclass(*args_, **kwargs_)
        else:
            return ParameterRefType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_parameterRef(self):
        return self.parameterRef

    def set_parameterRef(self, parameterRef):
        self.parameterRef = parameterRef

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ParameterRefType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParameterRefType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParameterRefType'):
        if self.parameterRef is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            outfile.write(' parameterRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.parameterRef), input_name='parameterRef')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ParameterRefType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameterRef', node)
        if value is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            self.parameterRef = value
            self.validate_NameReferenceType(self.parameterRef)  # validate type NameReferenceType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ParameterRefType


class PhysicalAddressSetType(GeneratedsSuper):
    """One or more physical addresses may be associated with each Parameter.
    Examples of physical addresses include a location on the spacecraft or
    a location on a data collection bus."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, PhysicalAddress=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if PhysicalAddress is None:
            self.PhysicalAddress = []
        else:
            self.PhysicalAddress = PhysicalAddress
        self.PhysicalAddress_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalAddressSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalAddressSetType.subclass:
            return PhysicalAddressSetType.subclass(*args_, **kwargs_)
        else:
            return PhysicalAddressSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_PhysicalAddress(self):
        return self.PhysicalAddress

    def set_PhysicalAddress(self, PhysicalAddress):
        self.PhysicalAddress = PhysicalAddress

    def add_PhysicalAddress(self, value):
        self.PhysicalAddress.append(value)

    def insert_PhysicalAddress_at(self, index, value):
        self.PhysicalAddress.insert(index, value)

    def replace_PhysicalAddress_at(self, index, value):
        self.PhysicalAddress[index] = value

    def hasContent_(self):
        if (
                self.PhysicalAddress
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='PhysicalAddressSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PhysicalAddressSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PhysicalAddressSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PhysicalAddressSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PhysicalAddressSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PhysicalAddressSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='PhysicalAddressSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PhysicalAddress_ in self.PhysicalAddress:
            namespaceprefix_ = self.PhysicalAddress_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.PhysicalAddress_nsprefix_) else ''
            PhysicalAddress_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PhysicalAddress',
                                    pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PhysicalAddress':
            obj_ = PhysicalAddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhysicalAddress.append(obj_)
            obj_.original_tagname_ = 'PhysicalAddress'


# end class PhysicalAddressSetType


class PhysicalAddressType(GeneratedsSuper):
    """Describe the physical address(s) that this parameter is collected from.
    Examples of physical addresses include a memory location on the
    spacecraft or a location on a data collection bus, with the source
    identified with a descriptive name for the region of memory, such as
    RAM, Flash, EEPROM, and other possibilities that can be adapted for
    program specific usage.A descriptive name for the location, such as a
    memory type, where this address is located.The address within the
    memory location. This specification does not specify program and
    hardware specific attributes, such as address size and address region
    starting location. These are part of the spacecraft hardware
    properties."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, sourceName=None, sourceAddress=None, SubAddress=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sourceName = _cast(None, sourceName)
        self.sourceName_nsprefix_ = None
        self.sourceAddress = _cast(None, sourceAddress)
        self.sourceAddress_nsprefix_ = None
        self.SubAddress = SubAddress
        self.SubAddress_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalAddressType.subclass:
            return PhysicalAddressType.subclass(*args_, **kwargs_)
        else:
            return PhysicalAddressType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SubAddress(self):
        return self.SubAddress

    def set_SubAddress(self, SubAddress):
        self.SubAddress = SubAddress

    def get_sourceName(self):
        return self.sourceName

    def set_sourceName(self, sourceName):
        self.sourceName = sourceName

    def get_sourceAddress(self):
        return self.sourceAddress

    def set_sourceAddress(self, sourceAddress):
        self.sourceAddress = sourceAddress

    def hasContent_(self):
        if (
                self.SubAddress is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='PhysicalAddressType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PhysicalAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PhysicalAddressType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PhysicalAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PhysicalAddressType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PhysicalAddressType'):
        if self.sourceName is not None and 'sourceName' not in already_processed:
            already_processed.add('sourceName')
            outfile.write(' sourceName=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.sourceName), input_name='sourceName')),))
        if self.sourceAddress is not None and 'sourceAddress' not in already_processed:
            already_processed.add('sourceAddress')
            outfile.write(' sourceAddress=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.sourceAddress), input_name='sourceAddress')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='PhysicalAddressType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SubAddress is not None:
            namespaceprefix_ = self.SubAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.SubAddress_nsprefix_) else ''
            self.SubAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SubAddress',
                                   pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sourceName', node)
        if value is not None and 'sourceName' not in already_processed:
            already_processed.add('sourceName')
            self.sourceName = value
        value = find_attr_value_('sourceAddress', node)
        if value is not None and 'sourceAddress' not in already_processed:
            already_processed.add('sourceAddress')
            self.sourceAddress = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SubAddress':
            obj_ = PhysicalAddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SubAddress = obj_
            obj_.original_tagname_ = 'SubAddress'


# end class PhysicalAddressType


class ServiceSetType(GeneratedsSuper):
    """A service is a logical grouping of container and/or messages."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Service=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Service is None:
            self.Service = []
        else:
            self.Service = Service
        self.Service_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceSetType.subclass:
            return ServiceSetType.subclass(*args_, **kwargs_)
        else:
            return ServiceSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Service(self):
        return self.Service

    def set_Service(self, Service):
        self.Service = Service

    def add_Service(self, value):
        self.Service.append(value)

    def insert_Service_at(self, index, value):
        self.Service.insert(index, value)

    def replace_Service_at(self, index, value):
        self.Service[index] = value

    def hasContent_(self):
        if (
                self.Service
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ServiceSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ServiceSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ServiceSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Service_ in self.Service:
            namespaceprefix_ = self.Service_nsprefix_ + ':' if (UseCapturedNS_ and self.Service_nsprefix_) else ''
            Service_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Service',
                            pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Service':
            obj_ = ServiceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Service.append(obj_)
            obj_.original_tagname_ = 'Service'


# end class ServiceSetType


class ArgumentAssignmentListType(GeneratedsSuper):
    """Argument Assignments specialize a MetaCommand or BlockMetaCommand when
    inheriting from another MetaCommand. General argument values can be
    restricted to specific values to further specialize the MetaCommand.
    Use it to ‘narrow’ a MetaCommand from its base MetaCommand by
    specifying values of arguments for example, a power command may be
    narrowed to a power on’ command by assigning the value of an argument
    to ‘on’. See ArgumentAssignmentType and MetaCommandType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ArgumentAssignment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ArgumentAssignment is None:
            self.ArgumentAssignment = []
        else:
            self.ArgumentAssignment = ArgumentAssignment
        self.ArgumentAssignment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentAssignmentListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentAssignmentListType.subclass:
            return ArgumentAssignmentListType.subclass(*args_, **kwargs_)
        else:
            return ArgumentAssignmentListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ArgumentAssignment(self):
        return self.ArgumentAssignment

    def set_ArgumentAssignment(self, ArgumentAssignment):
        self.ArgumentAssignment = ArgumentAssignment

    def add_ArgumentAssignment(self, value):
        self.ArgumentAssignment.append(value)

    def insert_ArgumentAssignment_at(self, index, value):
        self.ArgumentAssignment.insert(index, value)

    def replace_ArgumentAssignment_at(self, index, value):
        self.ArgumentAssignment[index] = value

    def hasContent_(self):
        if (
                self.ArgumentAssignment
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentAssignmentListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentAssignmentListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentAssignmentListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentAssignmentListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentAssignmentListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentAssignmentListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ArgumentAssignmentListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ArgumentAssignment_ in self.ArgumentAssignment:
            namespaceprefix_ = self.ArgumentAssignment_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ArgumentAssignment_nsprefix_) else ''
            ArgumentAssignment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ArgumentAssignment',
                                       pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ArgumentAssignment':
            obj_ = ArgumentAssignmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ArgumentAssignment.append(obj_)
            obj_.original_tagname_ = 'ArgumentAssignment'


# end class ArgumentAssignmentListType


class ArgumentAssignmentType(GeneratedsSuper):
    """Describe an assignment of an argument with a calibrated/engineering
    value. See ArgumentAssignmentListType.The named argument from the base
    MetaCommand to assign/restrict with a value.Specify value as a string
    compliant with the XML schema (xs) type specified for each XTCE type:
    integer=xs:integer; float=xs:double; string=xs:string;
    boolean=xs:boolean; binary=xs:hexBinary; enum=xs:string from
    EnumerationList; relative time=xs:duration; absolute time=xs:dateTime.
    Supplied value must be within the ValidRange specified for the type."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, argumentName=None, argumentValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.argumentName = _cast(None, argumentName)
        self.argumentName_nsprefix_ = None
        self.argumentValue = _cast(None, argumentValue)
        self.argumentValue_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentAssignmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentAssignmentType.subclass:
            return ArgumentAssignmentType.subclass(*args_, **kwargs_)
        else:
            return ArgumentAssignmentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_argumentName(self):
        return self.argumentName

    def set_argumentName(self, argumentName):
        self.argumentName = argumentName

    def get_argumentValue(self):
        return self.argumentValue

    def set_argumentValue(self, argumentValue):
        self.argumentValue = argumentValue

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentAssignmentType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentAssignmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentAssignmentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentAssignmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentAssignmentType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArgumentAssignmentType'):
        if self.argumentName is not None and 'argumentName' not in already_processed:
            already_processed.add('argumentName')
            outfile.write(' argumentName=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.argumentName), input_name='argumentName')),))
        if self.argumentValue is not None and 'argumentValue' not in already_processed:
            already_processed.add('argumentValue')
            outfile.write(' argumentValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.argumentValue), input_name='argumentValue')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ArgumentAssignmentType', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('argumentName', node)
        if value is not None and 'argumentName' not in already_processed:
            already_processed.add('argumentName')
            self.argumentName = value
            self.validate_NameReferenceType(self.argumentName)  # validate type NameReferenceType
        value = find_attr_value_('argumentValue', node)
        if value is not None and 'argumentValue' not in already_processed:
            already_processed.add('argumentValue')
            self.argumentValue = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ArgumentAssignmentType


class ArgumentComparisonType(GeneratedsSuper):
    """Identical to ComparisonType but supports argument instance
    references.Comparison operator to use with equality being the common
    default.Specify as: integer data type using xs:integer, float data type
    using xs:double, string data type using xs:string, boolean data type
    using xs:boolean, binary data type using xs:hexBinary, enum data type
    using label name, relative time data type using xs:duration, absolute
    time data type using xs:dateTime. Values must not exceed the
    characteristics for the data type or this is a validation error. Takes
    precedence over an initial value given in the data type. Values are
    calibrated unless there is an option to override it."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, comparisonOperator='==', value=None, ParameterInstanceRef=None, ArgumentInstanceRef=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.comparisonOperator = _cast(None, comparisonOperator)
        self.comparisonOperator_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.ParameterInstanceRef = ParameterInstanceRef
        self.ParameterInstanceRef_nsprefix_ = None
        self.ArgumentInstanceRef = ArgumentInstanceRef
        self.ArgumentInstanceRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentComparisonType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentComparisonType.subclass:
            return ArgumentComparisonType.subclass(*args_, **kwargs_)
        else:
            return ArgumentComparisonType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ParameterInstanceRef(self):
        return self.ParameterInstanceRef

    def set_ParameterInstanceRef(self, ParameterInstanceRef):
        self.ParameterInstanceRef = ParameterInstanceRef

    def get_ArgumentInstanceRef(self):
        return self.ArgumentInstanceRef

    def set_ArgumentInstanceRef(self, ArgumentInstanceRef):
        self.ArgumentInstanceRef = ArgumentInstanceRef

    def get_comparisonOperator(self):
        return self.comparisonOperator

    def set_comparisonOperator(self, comparisonOperator):
        self.comparisonOperator = comparisonOperator

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def validate_ComparisonOperatorsType(self, value):
        # Validate type xtce:ComparisonOperatorsType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['==', '!=', '<', '<=', '>', '>=']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ComparisonOperatorsType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.ParameterInstanceRef is not None or
                self.ArgumentInstanceRef is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentComparisonType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentComparisonType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentComparisonType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentComparisonType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentComparisonType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArgumentComparisonType'):
        if self.comparisonOperator != "==" and 'comparisonOperator' not in already_processed:
            already_processed.add('comparisonOperator')
            outfile.write(' comparisonOperator=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.comparisonOperator), input_name='comparisonOperator')),))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(
                ' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ArgumentComparisonType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ParameterInstanceRef is not None:
            namespaceprefix_ = self.ParameterInstanceRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterInstanceRef_nsprefix_) else ''
            self.ParameterInstanceRef.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='ParameterInstanceRef', pretty_print=pretty_print)
        if self.ArgumentInstanceRef is not None:
            namespaceprefix_ = self.ArgumentInstanceRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ArgumentInstanceRef_nsprefix_) else ''
            self.ArgumentInstanceRef.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='ArgumentInstanceRef', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('comparisonOperator', node)
        if value is not None and 'comparisonOperator' not in already_processed:
            already_processed.add('comparisonOperator')
            self.comparisonOperator = value
            self.validate_ComparisonOperatorsType(self.comparisonOperator)  # validate type ComparisonOperatorsType
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ParameterInstanceRef':
            class_obj_ = self.get_class_obj_(child_, ParameterInstanceRefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterInstanceRef = obj_
            obj_.original_tagname_ = 'ParameterInstanceRef'
        elif nodeName_ == 'ArgumentInstanceRef':
            obj_ = ArgumentInstanceRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ArgumentInstanceRef = obj_
            obj_.original_tagname_ = 'ArgumentInstanceRef'


# end class ArgumentComparisonType


class ArgumentComparisonListType(GeneratedsSuper):
    """Identical to ComparisonListType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Comparison=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Comparison is None:
            self.Comparison = []
        else:
            self.Comparison = Comparison
        self.Comparison_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentComparisonListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentComparisonListType.subclass:
            return ArgumentComparisonListType.subclass(*args_, **kwargs_)
        else:
            return ArgumentComparisonListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Comparison(self):
        return self.Comparison

    def set_Comparison(self, Comparison):
        self.Comparison = Comparison

    def add_Comparison(self, value):
        self.Comparison.append(value)

    def insert_Comparison_at(self, index, value):
        self.Comparison.insert(index, value)

    def replace_Comparison_at(self, index, value):
        self.Comparison[index] = value

    def hasContent_(self):
        if (
                self.Comparison
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentComparisonListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentComparisonListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentComparisonListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentComparisonListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentComparisonListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentComparisonListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ArgumentComparisonListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Comparison_ in self.Comparison:
            namespaceprefix_ = self.Comparison_nsprefix_ + ':' if (UseCapturedNS_ and self.Comparison_nsprefix_) else ''
            Comparison_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comparison',
                               pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Comparison':
            obj_ = ArgumentComparisonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comparison.append(obj_)
            obj_.original_tagname_ = 'Comparison'


# end class ArgumentComparisonListType


class ArgumentDiscreteLookupListType(GeneratedsSuper):
    """Identical to DiscreteLookupListType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, DiscreteLookup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DiscreteLookup is None:
            self.DiscreteLookup = []
        else:
            self.DiscreteLookup = DiscreteLookup
        self.DiscreteLookup_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentDiscreteLookupListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentDiscreteLookupListType.subclass:
            return ArgumentDiscreteLookupListType.subclass(*args_, **kwargs_)
        else:
            return ArgumentDiscreteLookupListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DiscreteLookup(self):
        return self.DiscreteLookup

    def set_DiscreteLookup(self, DiscreteLookup):
        self.DiscreteLookup = DiscreteLookup

    def add_DiscreteLookup(self, value):
        self.DiscreteLookup.append(value)

    def insert_DiscreteLookup_at(self, index, value):
        self.DiscreteLookup.insert(index, value)

    def replace_DiscreteLookup_at(self, index, value):
        self.DiscreteLookup[index] = value

    def hasContent_(self):
        if (
                self.DiscreteLookup
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
               name_='ArgumentDiscreteLookupListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentDiscreteLookupListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentDiscreteLookupListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='ArgumentDiscreteLookupListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentDiscreteLookupListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentDiscreteLookupListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ArgumentDiscreteLookupListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DiscreteLookup_ in self.DiscreteLookup:
            namespaceprefix_ = self.DiscreteLookup_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DiscreteLookup_nsprefix_) else ''
            DiscreteLookup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DiscreteLookup',
                                   pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DiscreteLookup':
            obj_ = ArgumentDiscreteLookupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DiscreteLookup.append(obj_)
            obj_.original_tagname_ = 'DiscreteLookup'


# end class ArgumentDiscreteLookupListType


class ArgumentDynamicValueType(GeneratedsSuper):
    """Identical to DynamicValueType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ArgumentInstanceRef=None, ParameterInstanceRef=None, LinearAdjustment=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ArgumentInstanceRef = ArgumentInstanceRef
        self.ArgumentInstanceRef_nsprefix_ = None
        self.ParameterInstanceRef = ParameterInstanceRef
        self.ParameterInstanceRef_nsprefix_ = None
        self.LinearAdjustment = LinearAdjustment
        self.LinearAdjustment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentDynamicValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentDynamicValueType.subclass:
            return ArgumentDynamicValueType.subclass(*args_, **kwargs_)
        else:
            return ArgumentDynamicValueType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ArgumentInstanceRef(self):
        return self.ArgumentInstanceRef

    def set_ArgumentInstanceRef(self, ArgumentInstanceRef):
        self.ArgumentInstanceRef = ArgumentInstanceRef

    def get_ParameterInstanceRef(self):
        return self.ParameterInstanceRef

    def set_ParameterInstanceRef(self, ParameterInstanceRef):
        self.ParameterInstanceRef = ParameterInstanceRef

    def get_LinearAdjustment(self):
        return self.LinearAdjustment

    def set_LinearAdjustment(self, LinearAdjustment):
        self.LinearAdjustment = LinearAdjustment

    def hasContent_(self):
        if (
                self.ArgumentInstanceRef is not None or
                self.ParameterInstanceRef is not None or
                self.LinearAdjustment is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentDynamicValueType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentDynamicValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentDynamicValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentDynamicValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentDynamicValueType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentDynamicValueType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ArgumentDynamicValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ArgumentInstanceRef is not None:
            namespaceprefix_ = self.ArgumentInstanceRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ArgumentInstanceRef_nsprefix_) else ''
            self.ArgumentInstanceRef.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='ArgumentInstanceRef', pretty_print=pretty_print)
        if self.ParameterInstanceRef is not None:
            namespaceprefix_ = self.ParameterInstanceRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterInstanceRef_nsprefix_) else ''
            self.ParameterInstanceRef.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='ParameterInstanceRef', pretty_print=pretty_print)
        if self.LinearAdjustment is not None:
            namespaceprefix_ = self.LinearAdjustment_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.LinearAdjustment_nsprefix_) else ''
            self.LinearAdjustment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LinearAdjustment',
                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ArgumentInstanceRef':
            obj_ = ArgumentInstanceRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ArgumentInstanceRef = obj_
            obj_.original_tagname_ = 'ArgumentInstanceRef'
        elif nodeName_ == 'ParameterInstanceRef':
            class_obj_ = self.get_class_obj_(child_, ParameterInstanceRefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterInstanceRef = obj_
            obj_.original_tagname_ = 'ParameterInstanceRef'
        elif nodeName_ == 'LinearAdjustment':
            obj_ = LinearAdjustmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LinearAdjustment = obj_
            obj_.original_tagname_ = 'LinearAdjustment'


# end class ArgumentDynamicValueType


class ArgumentInputSetType(GeneratedsSuper):
    """Identical to InputSetType but supports argument instance references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, InputParameterInstanceRef=None, InputArgumentInstanceRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if InputParameterInstanceRef is None:
            self.InputParameterInstanceRef = []
        else:
            self.InputParameterInstanceRef = InputParameterInstanceRef
        self.InputParameterInstanceRef_nsprefix_ = None
        if InputArgumentInstanceRef is None:
            self.InputArgumentInstanceRef = []
        else:
            self.InputArgumentInstanceRef = InputArgumentInstanceRef
        self.InputArgumentInstanceRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentInputSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentInputSetType.subclass:
            return ArgumentInputSetType.subclass(*args_, **kwargs_)
        else:
            return ArgumentInputSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_InputParameterInstanceRef(self):
        return self.InputParameterInstanceRef

    def set_InputParameterInstanceRef(self, InputParameterInstanceRef):
        self.InputParameterInstanceRef = InputParameterInstanceRef

    def add_InputParameterInstanceRef(self, value):
        self.InputParameterInstanceRef.append(value)

    def insert_InputParameterInstanceRef_at(self, index, value):
        self.InputParameterInstanceRef.insert(index, value)

    def replace_InputParameterInstanceRef_at(self, index, value):
        self.InputParameterInstanceRef[index] = value

    def get_InputArgumentInstanceRef(self):
        return self.InputArgumentInstanceRef

    def set_InputArgumentInstanceRef(self, InputArgumentInstanceRef):
        self.InputArgumentInstanceRef = InputArgumentInstanceRef

    def add_InputArgumentInstanceRef(self, value):
        self.InputArgumentInstanceRef.append(value)

    def insert_InputArgumentInstanceRef_at(self, index, value):
        self.InputArgumentInstanceRef.insert(index, value)

    def replace_InputArgumentInstanceRef_at(self, index, value):
        self.InputArgumentInstanceRef[index] = value

    def hasContent_(self):
        if (
                self.InputParameterInstanceRef or
                self.InputArgumentInstanceRef
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentInputSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentInputSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentInputSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentInputSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentInputSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArgumentInputSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentInputSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for InputParameterInstanceRef_ in self.InputParameterInstanceRef:
            namespaceprefix_ = self.InputParameterInstanceRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.InputParameterInstanceRef_nsprefix_) else ''
            InputParameterInstanceRef_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                              name_='InputParameterInstanceRef', pretty_print=pretty_print)
        for InputArgumentInstanceRef_ in self.InputArgumentInstanceRef:
            namespaceprefix_ = self.InputArgumentInstanceRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.InputArgumentInstanceRef_nsprefix_) else ''
            InputArgumentInstanceRef_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='InputArgumentInstanceRef', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'InputParameterInstanceRef':
            obj_ = InputParameterInstanceRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InputParameterInstanceRef.append(obj_)
            obj_.original_tagname_ = 'InputParameterInstanceRef'
        elif nodeName_ == 'InputArgumentInstanceRef':
            obj_ = ArgumentInstanceRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InputArgumentInstanceRef.append(obj_)
            obj_.original_tagname_ = 'InputArgumentInstanceRef'


# end class ArgumentInputSetType


class ArgumentInstanceRefType(GeneratedsSuper):
    """An argument instance is the name of an argument as the reference is
    always resolved locally to the metacommand.Give the name of the
    argument. There is no path, this is a local reference.Typically the
    calibrated/engineering value is used and that is the default."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, argumentRef=None, useCalibratedValue=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.argumentRef = _cast(None, argumentRef)
        self.argumentRef_nsprefix_ = None
        self.useCalibratedValue = _cast(bool, useCalibratedValue)
        self.useCalibratedValue_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentInstanceRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentInstanceRefType.subclass:
            return ArgumentInstanceRefType.subclass(*args_, **kwargs_)
        else:
            return ArgumentInstanceRefType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_argumentRef(self):
        return self.argumentRef

    def set_argumentRef(self, argumentRef):
        self.argumentRef = argumentRef

    def get_useCalibratedValue(self):
        return self.useCalibratedValue

    def set_useCalibratedValue(self, useCalibratedValue):
        self.useCalibratedValue = useCalibratedValue

    def validate_NameType(self, value):
        # Validate type xtce:NameType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameType_patterns_,))

    validate_NameType_patterns_ = [['^([^./:\\[\\] ]+)$']]

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentInstanceRefType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentInstanceRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentInstanceRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentInstanceRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentInstanceRefType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArgumentInstanceRefType'):
        if self.argumentRef is not None and 'argumentRef' not in already_processed:
            already_processed.add('argumentRef')
            outfile.write(' argumentRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.argumentRef), input_name='argumentRef')),))
        if not self.useCalibratedValue and 'useCalibratedValue' not in already_processed:
            already_processed.add('useCalibratedValue')
            outfile.write(' useCalibratedValue="%s"' % self.gds_format_boolean(self.useCalibratedValue,
                                                                               input_name='useCalibratedValue'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ArgumentInstanceRefType', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('argumentRef', node)
        if value is not None and 'argumentRef' not in already_processed:
            already_processed.add('argumentRef')
            self.argumentRef = value
            self.validate_NameType(self.argumentRef)  # validate type NameType
        value = find_attr_value_('useCalibratedValue', node)
        if value is not None and 'useCalibratedValue' not in already_processed:
            already_processed.add('useCalibratedValue')
            if value in ('true', '1'):
                self.useCalibratedValue = True
            elif value in ('false', '0'):
                self.useCalibratedValue = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ArgumentInstanceRefType


class ArgumentListType(GeneratedsSuper):
    """Defines a list of Arguments for a command definition."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Argument=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Argument is None:
            self.Argument = []
        else:
            self.Argument = Argument
        self.Argument_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentListType.subclass:
            return ArgumentListType.subclass(*args_, **kwargs_)
        else:
            return ArgumentListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Argument(self):
        return self.Argument

    def set_Argument(self, Argument):
        self.Argument = Argument

    def add_Argument(self, value):
        self.Argument.append(value)

    def insert_Argument_at(self, index, value):
        self.Argument.insert(index, value)

    def replace_Argument_at(self, index, value):
        self.Argument[index] = value

    def hasContent_(self):
        if (
                self.Argument
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArgumentListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentListType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Argument_ in self.Argument:
            namespaceprefix_ = self.Argument_nsprefix_ + ':' if (UseCapturedNS_ and self.Argument_nsprefix_) else ''
            Argument_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Argument',
                             pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Argument':
            obj_ = ArgumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Argument.append(obj_)
            obj_.original_tagname_ = 'Argument'


# end class ArgumentListType


class ArgumentBooleanExpressionType(GeneratedsSuper):
    """Identical to BooleanExpressionType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Condition=None, ANDedConditions=None, ORedConditions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Condition = Condition
        self.Condition_nsprefix_ = None
        self.ANDedConditions = ANDedConditions
        self.ANDedConditions_nsprefix_ = None
        self.ORedConditions = ORedConditions
        self.ORedConditions_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentBooleanExpressionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentBooleanExpressionType.subclass:
            return ArgumentBooleanExpressionType.subclass(*args_, **kwargs_)
        else:
            return ArgumentBooleanExpressionType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Condition(self):
        return self.Condition

    def set_Condition(self, Condition):
        self.Condition = Condition

    def get_ANDedConditions(self):
        return self.ANDedConditions

    def set_ANDedConditions(self, ANDedConditions):
        self.ANDedConditions = ANDedConditions

    def get_ORedConditions(self):
        return self.ORedConditions

    def set_ORedConditions(self, ORedConditions):
        self.ORedConditions = ORedConditions

    def hasContent_(self):
        if (
                self.Condition is not None or
                self.ANDedConditions is not None or
                self.ORedConditions is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
               name_='ArgumentBooleanExpressionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentBooleanExpressionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentBooleanExpressionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='ArgumentBooleanExpressionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentBooleanExpressionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentBooleanExpressionType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ArgumentBooleanExpressionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Condition is not None:
            namespaceprefix_ = self.Condition_nsprefix_ + ':' if (UseCapturedNS_ and self.Condition_nsprefix_) else ''
            self.Condition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Condition',
                                  pretty_print=pretty_print)
        if self.ANDedConditions is not None:
            namespaceprefix_ = self.ANDedConditions_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ANDedConditions_nsprefix_) else ''
            self.ANDedConditions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANDedConditions',
                                        pretty_print=pretty_print)
        if self.ORedConditions is not None:
            namespaceprefix_ = self.ORedConditions_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ORedConditions_nsprefix_) else ''
            self.ORedConditions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ORedConditions',
                                       pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Condition':
            obj_ = ArgumentComparisonCheckType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Condition = obj_
            obj_.original_tagname_ = 'Condition'
        elif nodeName_ == 'ANDedConditions':
            obj_ = ArgumentANDedConditionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANDedConditions = obj_
            obj_.original_tagname_ = 'ANDedConditions'
        elif nodeName_ == 'ORedConditions':
            obj_ = ArgumentORedConditionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ORedConditions = obj_
            obj_.original_tagname_ = 'ORedConditions'


# end class ArgumentBooleanExpressionType


class ArgumentMatchCriteriaType(GeneratedsSuper):
    """Identical to MatchCriteriaType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Comparison=None, ComparisonList=None, BooleanExpression=None, CustomAlgorithm=None,
                 extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Comparison = Comparison
        self.Comparison_nsprefix_ = None
        self.ComparisonList = ComparisonList
        self.ComparisonList_nsprefix_ = None
        self.BooleanExpression = BooleanExpression
        self.BooleanExpression_nsprefix_ = None
        self.CustomAlgorithm = CustomAlgorithm
        self.CustomAlgorithm_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentMatchCriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentMatchCriteriaType.subclass:
            return ArgumentMatchCriteriaType.subclass(*args_, **kwargs_)
        else:
            return ArgumentMatchCriteriaType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Comparison(self):
        return self.Comparison

    def set_Comparison(self, Comparison):
        self.Comparison = Comparison

    def get_ComparisonList(self):
        return self.ComparisonList

    def set_ComparisonList(self, ComparisonList):
        self.ComparisonList = ComparisonList

    def get_BooleanExpression(self):
        return self.BooleanExpression

    def set_BooleanExpression(self, BooleanExpression):
        self.BooleanExpression = BooleanExpression

    def get_CustomAlgorithm(self):
        return self.CustomAlgorithm

    def set_CustomAlgorithm(self, CustomAlgorithm):
        self.CustomAlgorithm = CustomAlgorithm

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.Comparison is not None or
                self.ComparisonList is not None or
                self.BooleanExpression is not None or
                self.CustomAlgorithm is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentMatchCriteriaType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentMatchCriteriaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentMatchCriteriaType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentMatchCriteriaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentMatchCriteriaType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentMatchCriteriaType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ArgumentMatchCriteriaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comparison is not None:
            namespaceprefix_ = self.Comparison_nsprefix_ + ':' if (UseCapturedNS_ and self.Comparison_nsprefix_) else ''
            self.Comparison.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comparison',
                                   pretty_print=pretty_print)
        if self.ComparisonList is not None:
            namespaceprefix_ = self.ComparisonList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ComparisonList_nsprefix_) else ''
            self.ComparisonList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ComparisonList',
                                       pretty_print=pretty_print)
        if self.BooleanExpression is not None:
            namespaceprefix_ = self.BooleanExpression_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BooleanExpression_nsprefix_) else ''
            self.BooleanExpression.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BooleanExpression',
                                          pretty_print=pretty_print)
        if self.CustomAlgorithm is not None:
            namespaceprefix_ = self.CustomAlgorithm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CustomAlgorithm_nsprefix_) else ''
            self.CustomAlgorithm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CustomAlgorithm',
                                        pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Comparison':
            obj_ = ArgumentComparisonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comparison = obj_
            obj_.original_tagname_ = 'Comparison'
        elif nodeName_ == 'ComparisonList':
            obj_ = ArgumentComparisonListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ComparisonList = obj_
            obj_.original_tagname_ = 'ComparisonList'
        elif nodeName_ == 'BooleanExpression':
            obj_ = ArgumentBooleanExpressionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BooleanExpression = obj_
            obj_.original_tagname_ = 'BooleanExpression'
        elif nodeName_ == 'CustomAlgorithm':
            obj_ = ArgumentInputAlgorithmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CustomAlgorithm = obj_
            obj_.original_tagname_ = 'CustomAlgorithm'


# end class ArgumentMatchCriteriaType


class ArgumentTypeSetType(GeneratedsSuper):
    """Describe an unordered collection of argument type definitions. These
    types named for the engineering/calibrated type of the argument. See
    BaseDataType and BaseTimeDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, StringArgumentType=None, EnumeratedArgumentType=None, IntegerArgumentType=None,
                 BinaryArgumentType=None, FloatArgumentType=None, BooleanArgumentType=None,
                 RelativeTimeAgumentType=None, AbsoluteTimeArgumentType=None, ArrayArgumentType=None,
                 AggregateArgumentType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if StringArgumentType is None:
            self.StringArgumentType = []
        else:
            self.StringArgumentType = StringArgumentType
        self.StringArgumentType_nsprefix_ = None
        if EnumeratedArgumentType is None:
            self.EnumeratedArgumentType = []
        else:
            self.EnumeratedArgumentType = EnumeratedArgumentType
        self.EnumeratedArgumentType_nsprefix_ = None
        if IntegerArgumentType is None:
            self.IntegerArgumentType = []
        else:
            self.IntegerArgumentType = IntegerArgumentType
        self.IntegerArgumentType_nsprefix_ = None
        if BinaryArgumentType is None:
            self.BinaryArgumentType = []
        else:
            self.BinaryArgumentType = BinaryArgumentType
        self.BinaryArgumentType_nsprefix_ = None
        if FloatArgumentType is None:
            self.FloatArgumentType = []
        else:
            self.FloatArgumentType = FloatArgumentType
        self.FloatArgumentType_nsprefix_ = None
        if BooleanArgumentType is None:
            self.BooleanArgumentType = []
        else:
            self.BooleanArgumentType = BooleanArgumentType
        self.BooleanArgumentType_nsprefix_ = None
        if RelativeTimeAgumentType is None:
            self.RelativeTimeAgumentType = []
        else:
            self.RelativeTimeAgumentType = RelativeTimeAgumentType
        self.RelativeTimeAgumentType_nsprefix_ = None
        if AbsoluteTimeArgumentType is None:
            self.AbsoluteTimeArgumentType = []
        else:
            self.AbsoluteTimeArgumentType = AbsoluteTimeArgumentType
        self.AbsoluteTimeArgumentType_nsprefix_ = None
        if ArrayArgumentType is None:
            self.ArrayArgumentType = []
        else:
            self.ArrayArgumentType = ArrayArgumentType
        self.ArrayArgumentType_nsprefix_ = None
        if AggregateArgumentType is None:
            self.AggregateArgumentType = []
        else:
            self.AggregateArgumentType = AggregateArgumentType
        self.AggregateArgumentType_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentTypeSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentTypeSetType.subclass:
            return ArgumentTypeSetType.subclass(*args_, **kwargs_)
        else:
            return ArgumentTypeSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_StringArgumentType(self):
        return self.StringArgumentType

    def set_StringArgumentType(self, StringArgumentType):
        self.StringArgumentType = StringArgumentType

    def add_StringArgumentType(self, value):
        self.StringArgumentType.append(value)

    def insert_StringArgumentType_at(self, index, value):
        self.StringArgumentType.insert(index, value)

    def replace_StringArgumentType_at(self, index, value):
        self.StringArgumentType[index] = value

    def get_EnumeratedArgumentType(self):
        return self.EnumeratedArgumentType

    def set_EnumeratedArgumentType(self, EnumeratedArgumentType):
        self.EnumeratedArgumentType = EnumeratedArgumentType

    def add_EnumeratedArgumentType(self, value):
        self.EnumeratedArgumentType.append(value)

    def insert_EnumeratedArgumentType_at(self, index, value):
        self.EnumeratedArgumentType.insert(index, value)

    def replace_EnumeratedArgumentType_at(self, index, value):
        self.EnumeratedArgumentType[index] = value

    def get_IntegerArgumentType(self):
        return self.IntegerArgumentType

    def set_IntegerArgumentType(self, IntegerArgumentType):
        self.IntegerArgumentType = IntegerArgumentType

    def add_IntegerArgumentType(self, value):
        self.IntegerArgumentType.append(value)

    def insert_IntegerArgumentType_at(self, index, value):
        self.IntegerArgumentType.insert(index, value)

    def replace_IntegerArgumentType_at(self, index, value):
        self.IntegerArgumentType[index] = value

    def get_BinaryArgumentType(self):
        return self.BinaryArgumentType

    def set_BinaryArgumentType(self, BinaryArgumentType):
        self.BinaryArgumentType = BinaryArgumentType

    def add_BinaryArgumentType(self, value):
        self.BinaryArgumentType.append(value)

    def insert_BinaryArgumentType_at(self, index, value):
        self.BinaryArgumentType.insert(index, value)

    def replace_BinaryArgumentType_at(self, index, value):
        self.BinaryArgumentType[index] = value

    def get_FloatArgumentType(self):
        return self.FloatArgumentType

    def set_FloatArgumentType(self, FloatArgumentType):
        self.FloatArgumentType = FloatArgumentType

    def add_FloatArgumentType(self, value):
        self.FloatArgumentType.append(value)

    def insert_FloatArgumentType_at(self, index, value):
        self.FloatArgumentType.insert(index, value)

    def replace_FloatArgumentType_at(self, index, value):
        self.FloatArgumentType[index] = value

    def get_BooleanArgumentType(self):
        return self.BooleanArgumentType

    def set_BooleanArgumentType(self, BooleanArgumentType):
        self.BooleanArgumentType = BooleanArgumentType

    def add_BooleanArgumentType(self, value):
        self.BooleanArgumentType.append(value)

    def insert_BooleanArgumentType_at(self, index, value):
        self.BooleanArgumentType.insert(index, value)

    def replace_BooleanArgumentType_at(self, index, value):
        self.BooleanArgumentType[index] = value

    def get_RelativeTimeAgumentType(self):
        return self.RelativeTimeAgumentType

    def set_RelativeTimeAgumentType(self, RelativeTimeAgumentType):
        self.RelativeTimeAgumentType = RelativeTimeAgumentType

    def add_RelativeTimeAgumentType(self, value):
        self.RelativeTimeAgumentType.append(value)

    def insert_RelativeTimeAgumentType_at(self, index, value):
        self.RelativeTimeAgumentType.insert(index, value)

    def replace_RelativeTimeAgumentType_at(self, index, value):
        self.RelativeTimeAgumentType[index] = value

    def get_AbsoluteTimeArgumentType(self):
        return self.AbsoluteTimeArgumentType

    def set_AbsoluteTimeArgumentType(self, AbsoluteTimeArgumentType):
        self.AbsoluteTimeArgumentType = AbsoluteTimeArgumentType

    def add_AbsoluteTimeArgumentType(self, value):
        self.AbsoluteTimeArgumentType.append(value)

    def insert_AbsoluteTimeArgumentType_at(self, index, value):
        self.AbsoluteTimeArgumentType.insert(index, value)

    def replace_AbsoluteTimeArgumentType_at(self, index, value):
        self.AbsoluteTimeArgumentType[index] = value

    def get_ArrayArgumentType(self):
        return self.ArrayArgumentType

    def set_ArrayArgumentType(self, ArrayArgumentType):
        self.ArrayArgumentType = ArrayArgumentType

    def add_ArrayArgumentType(self, value):
        self.ArrayArgumentType.append(value)

    def insert_ArrayArgumentType_at(self, index, value):
        self.ArrayArgumentType.insert(index, value)

    def replace_ArrayArgumentType_at(self, index, value):
        self.ArrayArgumentType[index] = value

    def get_AggregateArgumentType(self):
        return self.AggregateArgumentType

    def set_AggregateArgumentType(self, AggregateArgumentType):
        self.AggregateArgumentType = AggregateArgumentType

    def add_AggregateArgumentType(self, value):
        self.AggregateArgumentType.append(value)

    def insert_AggregateArgumentType_at(self, index, value):
        self.AggregateArgumentType.insert(index, value)

    def replace_AggregateArgumentType_at(self, index, value):
        self.AggregateArgumentType[index] = value

    def hasContent_(self):
        if (
                self.StringArgumentType or
                self.EnumeratedArgumentType or
                self.IntegerArgumentType or
                self.BinaryArgumentType or
                self.FloatArgumentType or
                self.BooleanArgumentType or
                self.RelativeTimeAgumentType or
                self.AbsoluteTimeArgumentType or
                self.ArrayArgumentType or
                self.AggregateArgumentType
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentTypeSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentTypeSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentTypeSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentTypeSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentTypeSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArgumentTypeSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentTypeSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for StringArgumentType_ in self.StringArgumentType:
            namespaceprefix_ = self.StringArgumentType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.StringArgumentType_nsprefix_) else ''
            StringArgumentType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StringArgumentType',
                                       pretty_print=pretty_print)
        for EnumeratedArgumentType_ in self.EnumeratedArgumentType:
            namespaceprefix_ = self.EnumeratedArgumentType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.EnumeratedArgumentType_nsprefix_) else ''
            EnumeratedArgumentType_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='EnumeratedArgumentType', pretty_print=pretty_print)
        for IntegerArgumentType_ in self.IntegerArgumentType:
            namespaceprefix_ = self.IntegerArgumentType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.IntegerArgumentType_nsprefix_) else ''
            IntegerArgumentType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IntegerArgumentType',
                                        pretty_print=pretty_print)
        for BinaryArgumentType_ in self.BinaryArgumentType:
            namespaceprefix_ = self.BinaryArgumentType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BinaryArgumentType_nsprefix_) else ''
            BinaryArgumentType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BinaryArgumentType',
                                       pretty_print=pretty_print)
        for FloatArgumentType_ in self.FloatArgumentType:
            namespaceprefix_ = self.FloatArgumentType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.FloatArgumentType_nsprefix_) else ''
            FloatArgumentType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FloatArgumentType',
                                      pretty_print=pretty_print)
        for BooleanArgumentType_ in self.BooleanArgumentType:
            namespaceprefix_ = self.BooleanArgumentType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BooleanArgumentType_nsprefix_) else ''
            BooleanArgumentType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BooleanArgumentType',
                                        pretty_print=pretty_print)
        for RelativeTimeAgumentType_ in self.RelativeTimeAgumentType:
            namespaceprefix_ = self.RelativeTimeAgumentType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.RelativeTimeAgumentType_nsprefix_) else ''
            RelativeTimeAgumentType_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='RelativeTimeAgumentType', pretty_print=pretty_print)
        for AbsoluteTimeArgumentType_ in self.AbsoluteTimeArgumentType:
            namespaceprefix_ = self.AbsoluteTimeArgumentType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AbsoluteTimeArgumentType_nsprefix_) else ''
            AbsoluteTimeArgumentType_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='AbsoluteTimeArgumentType', pretty_print=pretty_print)
        for ArrayArgumentType_ in self.ArrayArgumentType:
            namespaceprefix_ = self.ArrayArgumentType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ArrayArgumentType_nsprefix_) else ''
            ArrayArgumentType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ArrayArgumentType',
                                      pretty_print=pretty_print)
        for AggregateArgumentType_ in self.AggregateArgumentType:
            namespaceprefix_ = self.AggregateArgumentType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AggregateArgumentType_nsprefix_) else ''
            AggregateArgumentType_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                          name_='AggregateArgumentType', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'StringArgumentType':
            obj_ = StringArgumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StringArgumentType.append(obj_)
            obj_.original_tagname_ = 'StringArgumentType'
        elif nodeName_ == 'EnumeratedArgumentType':
            obj_ = EnumeratedArgumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnumeratedArgumentType.append(obj_)
            obj_.original_tagname_ = 'EnumeratedArgumentType'
        elif nodeName_ == 'IntegerArgumentType':
            obj_ = IntegerArgumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IntegerArgumentType.append(obj_)
            obj_.original_tagname_ = 'IntegerArgumentType'
        elif nodeName_ == 'BinaryArgumentType':
            obj_ = BinaryArgumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BinaryArgumentType.append(obj_)
            obj_.original_tagname_ = 'BinaryArgumentType'
        elif nodeName_ == 'FloatArgumentType':
            obj_ = FloatArgumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FloatArgumentType.append(obj_)
            obj_.original_tagname_ = 'FloatArgumentType'
        elif nodeName_ == 'BooleanArgumentType':
            obj_ = BooleanArgumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BooleanArgumentType.append(obj_)
            obj_.original_tagname_ = 'BooleanArgumentType'
        elif nodeName_ == 'RelativeTimeAgumentType':
            obj_ = RelativeTimeArgumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RelativeTimeAgumentType.append(obj_)
            obj_.original_tagname_ = 'RelativeTimeAgumentType'
        elif nodeName_ == 'AbsoluteTimeArgumentType':
            obj_ = AbsoluteTimeArgumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AbsoluteTimeArgumentType.append(obj_)
            obj_.original_tagname_ = 'AbsoluteTimeArgumentType'
        elif nodeName_ == 'ArrayArgumentType':
            obj_ = ArrayArgumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ArrayArgumentType.append(obj_)
            obj_.original_tagname_ = 'ArrayArgumentType'
        elif nodeName_ == 'AggregateArgumentType':
            obj_ = AggregateArgumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AggregateArgumentType.append(obj_)
            obj_.original_tagname_ = 'AggregateArgumentType'


# end class ArgumentTypeSetType


class BaseMetaCommandType(GeneratedsSuper):
    """When specified, a BaseMetaCommand element identifies that this
    MetaCommand inherits (extends) another MetaCommand. It’s required
    ArgumentAssignmentList narrows or this command from the parent. This is
    typically used when specializing a generic MetaCommand to a specific
    MetaCommand. See MetaCommandType.Reference to the MetaCommand
    definition that this MetaCommand extends."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, metaCommandRef=None, ArgumentAssignmentList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.metaCommandRef = _cast(None, metaCommandRef)
        self.metaCommandRef_nsprefix_ = None
        self.ArgumentAssignmentList = ArgumentAssignmentList
        self.ArgumentAssignmentList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseMetaCommandType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseMetaCommandType.subclass:
            return BaseMetaCommandType.subclass(*args_, **kwargs_)
        else:
            return BaseMetaCommandType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ArgumentAssignmentList(self):
        return self.ArgumentAssignmentList

    def set_ArgumentAssignmentList(self, ArgumentAssignmentList):
        self.ArgumentAssignmentList = ArgumentAssignmentList

    def get_metaCommandRef(self):
        return self.metaCommandRef

    def set_metaCommandRef(self, metaCommandRef):
        self.metaCommandRef = metaCommandRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                self.ArgumentAssignmentList is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BaseMetaCommandType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseMetaCommandType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BaseMetaCommandType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseMetaCommandType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseMetaCommandType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseMetaCommandType'):
        if self.metaCommandRef is not None and 'metaCommandRef' not in already_processed:
            already_processed.add('metaCommandRef')
            outfile.write(' metaCommandRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.metaCommandRef), input_name='metaCommandRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BaseMetaCommandType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ArgumentAssignmentList is not None:
            namespaceprefix_ = self.ArgumentAssignmentList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ArgumentAssignmentList_nsprefix_) else ''
            self.ArgumentAssignmentList.export(outfile, level, namespaceprefix_, namespacedef_='',
                                               name_='ArgumentAssignmentList', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('metaCommandRef', node)
        if value is not None and 'metaCommandRef' not in already_processed:
            already_processed.add('metaCommandRef')
            self.metaCommandRef = value
            self.validate_NameReferenceType(self.metaCommandRef)  # validate type NameReferenceType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ArgumentAssignmentList':
            obj_ = ArgumentAssignmentListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ArgumentAssignmentList = obj_
            obj_.original_tagname_ = 'ArgumentAssignmentList'


# end class BaseMetaCommandType


class CommandContainerEntryListType(GeneratedsSuper):
    """Describe an entry list for a CommandContainer which is associated with a
    MetaCommand. The entry list for a MetaCommand CommandContainer element
    operates in a similar fashion as the entry list element for a
    SequenceContainer element. It adds fixed value and argument entries to
    the entry list not present in sequence containers. See MetaCommandType,
    CommandContainerType and EntryListType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ParameterRefEntry=None, ParameterSegmentRefEntry=None, ContainerRefEntry=None,
                 ContainerSegmentRefEntry=None, StreamSegmentEntry=None, IndirectParameterRefEntry=None,
                 ArrayParameterRefEntry=None, ArgumentRefEntry=None, ArrayArgumentRefEntry=None, FixedValueEntry=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ParameterRefEntry is None:
            self.ParameterRefEntry = []
        else:
            self.ParameterRefEntry = ParameterRefEntry
        self.ParameterRefEntry_nsprefix_ = None
        if ParameterSegmentRefEntry is None:
            self.ParameterSegmentRefEntry = []
        else:
            self.ParameterSegmentRefEntry = ParameterSegmentRefEntry
        self.ParameterSegmentRefEntry_nsprefix_ = None
        if ContainerRefEntry is None:
            self.ContainerRefEntry = []
        else:
            self.ContainerRefEntry = ContainerRefEntry
        self.ContainerRefEntry_nsprefix_ = None
        if ContainerSegmentRefEntry is None:
            self.ContainerSegmentRefEntry = []
        else:
            self.ContainerSegmentRefEntry = ContainerSegmentRefEntry
        self.ContainerSegmentRefEntry_nsprefix_ = None
        if StreamSegmentEntry is None:
            self.StreamSegmentEntry = []
        else:
            self.StreamSegmentEntry = StreamSegmentEntry
        self.StreamSegmentEntry_nsprefix_ = None
        if IndirectParameterRefEntry is None:
            self.IndirectParameterRefEntry = []
        else:
            self.IndirectParameterRefEntry = IndirectParameterRefEntry
        self.IndirectParameterRefEntry_nsprefix_ = None
        if ArrayParameterRefEntry is None:
            self.ArrayParameterRefEntry = []
        else:
            self.ArrayParameterRefEntry = ArrayParameterRefEntry
        self.ArrayParameterRefEntry_nsprefix_ = None
        if ArgumentRefEntry is None:
            self.ArgumentRefEntry = []
        else:
            self.ArgumentRefEntry = ArgumentRefEntry
        self.ArgumentRefEntry_nsprefix_ = None
        if ArrayArgumentRefEntry is None:
            self.ArrayArgumentRefEntry = []
        else:
            self.ArrayArgumentRefEntry = ArrayArgumentRefEntry
        self.ArrayArgumentRefEntry_nsprefix_ = None
        if FixedValueEntry is None:
            self.FixedValueEntry = []
        else:
            self.FixedValueEntry = FixedValueEntry
        self.FixedValueEntry_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommandContainerEntryListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommandContainerEntryListType.subclass:
            return CommandContainerEntryListType.subclass(*args_, **kwargs_)
        else:
            return CommandContainerEntryListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ParameterRefEntry(self):
        return self.ParameterRefEntry

    def set_ParameterRefEntry(self, ParameterRefEntry):
        self.ParameterRefEntry = ParameterRefEntry

    def add_ParameterRefEntry(self, value):
        self.ParameterRefEntry.append(value)

    def insert_ParameterRefEntry_at(self, index, value):
        self.ParameterRefEntry.insert(index, value)

    def replace_ParameterRefEntry_at(self, index, value):
        self.ParameterRefEntry[index] = value

    def get_ParameterSegmentRefEntry(self):
        return self.ParameterSegmentRefEntry

    def set_ParameterSegmentRefEntry(self, ParameterSegmentRefEntry):
        self.ParameterSegmentRefEntry = ParameterSegmentRefEntry

    def add_ParameterSegmentRefEntry(self, value):
        self.ParameterSegmentRefEntry.append(value)

    def insert_ParameterSegmentRefEntry_at(self, index, value):
        self.ParameterSegmentRefEntry.insert(index, value)

    def replace_ParameterSegmentRefEntry_at(self, index, value):
        self.ParameterSegmentRefEntry[index] = value

    def get_ContainerRefEntry(self):
        return self.ContainerRefEntry

    def set_ContainerRefEntry(self, ContainerRefEntry):
        self.ContainerRefEntry = ContainerRefEntry

    def add_ContainerRefEntry(self, value):
        self.ContainerRefEntry.append(value)

    def insert_ContainerRefEntry_at(self, index, value):
        self.ContainerRefEntry.insert(index, value)

    def replace_ContainerRefEntry_at(self, index, value):
        self.ContainerRefEntry[index] = value

    def get_ContainerSegmentRefEntry(self):
        return self.ContainerSegmentRefEntry

    def set_ContainerSegmentRefEntry(self, ContainerSegmentRefEntry):
        self.ContainerSegmentRefEntry = ContainerSegmentRefEntry

    def add_ContainerSegmentRefEntry(self, value):
        self.ContainerSegmentRefEntry.append(value)

    def insert_ContainerSegmentRefEntry_at(self, index, value):
        self.ContainerSegmentRefEntry.insert(index, value)

    def replace_ContainerSegmentRefEntry_at(self, index, value):
        self.ContainerSegmentRefEntry[index] = value

    def get_StreamSegmentEntry(self):
        return self.StreamSegmentEntry

    def set_StreamSegmentEntry(self, StreamSegmentEntry):
        self.StreamSegmentEntry = StreamSegmentEntry

    def add_StreamSegmentEntry(self, value):
        self.StreamSegmentEntry.append(value)

    def insert_StreamSegmentEntry_at(self, index, value):
        self.StreamSegmentEntry.insert(index, value)

    def replace_StreamSegmentEntry_at(self, index, value):
        self.StreamSegmentEntry[index] = value

    def get_IndirectParameterRefEntry(self):
        return self.IndirectParameterRefEntry

    def set_IndirectParameterRefEntry(self, IndirectParameterRefEntry):
        self.IndirectParameterRefEntry = IndirectParameterRefEntry

    def add_IndirectParameterRefEntry(self, value):
        self.IndirectParameterRefEntry.append(value)

    def insert_IndirectParameterRefEntry_at(self, index, value):
        self.IndirectParameterRefEntry.insert(index, value)

    def replace_IndirectParameterRefEntry_at(self, index, value):
        self.IndirectParameterRefEntry[index] = value

    def get_ArrayParameterRefEntry(self):
        return self.ArrayParameterRefEntry

    def set_ArrayParameterRefEntry(self, ArrayParameterRefEntry):
        self.ArrayParameterRefEntry = ArrayParameterRefEntry

    def add_ArrayParameterRefEntry(self, value):
        self.ArrayParameterRefEntry.append(value)

    def insert_ArrayParameterRefEntry_at(self, index, value):
        self.ArrayParameterRefEntry.insert(index, value)

    def replace_ArrayParameterRefEntry_at(self, index, value):
        self.ArrayParameterRefEntry[index] = value

    def get_ArgumentRefEntry(self) -> 'ArgumentArgumentRefEntryType':
        return self.ArgumentRefEntry

    def set_ArgumentRefEntry(self, ArgumentRefEntry):
        self.ArgumentRefEntry = ArgumentRefEntry

    def add_ArgumentRefEntry(self, value):
        self.ArgumentRefEntry.append(value)

    def insert_ArgumentRefEntry_at(self, index, value):
        self.ArgumentRefEntry.insert(index, value)

    def replace_ArgumentRefEntry_at(self, index, value):
        self.ArgumentRefEntry[index] = value

    def get_ArrayArgumentRefEntry(self):
        return self.ArrayArgumentRefEntry

    def set_ArrayArgumentRefEntry(self, ArrayArgumentRefEntry):
        self.ArrayArgumentRefEntry = ArrayArgumentRefEntry

    def add_ArrayArgumentRefEntry(self, value):
        self.ArrayArgumentRefEntry.append(value)

    def insert_ArrayArgumentRefEntry_at(self, index, value):
        self.ArrayArgumentRefEntry.insert(index, value)

    def replace_ArrayArgumentRefEntry_at(self, index, value):
        self.ArrayArgumentRefEntry[index] = value

    def get_FixedValueEntry(self):
        return self.FixedValueEntry

    def set_FixedValueEntry(self, FixedValueEntry):
        self.FixedValueEntry = FixedValueEntry

    def add_FixedValueEntry(self, value):
        self.FixedValueEntry.append(value)

    def insert_FixedValueEntry_at(self, index, value):
        self.FixedValueEntry.insert(index, value)

    def replace_FixedValueEntry_at(self, index, value):
        self.FixedValueEntry[index] = value

    def hasContent_(self):
        if (
                self.ParameterRefEntry or
                self.ParameterSegmentRefEntry or
                self.ContainerRefEntry or
                self.ContainerSegmentRefEntry or
                self.StreamSegmentEntry or
                self.IndirectParameterRefEntry or
                self.ArrayParameterRefEntry or
                self.ArgumentRefEntry or
                self.ArrayArgumentRefEntry or
                self.FixedValueEntry
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
               name_='CommandContainerEntryListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CommandContainerEntryListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CommandContainerEntryListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='CommandContainerEntryListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='CommandContainerEntryListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='CommandContainerEntryListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='CommandContainerEntryListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ParameterRefEntry_ in self.ParameterRefEntry:
            namespaceprefix_ = self.ParameterRefEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterRefEntry_nsprefix_) else ''
            ParameterRefEntry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ParameterRefEntry',
                                      pretty_print=pretty_print)
        for ParameterSegmentRefEntry_ in self.ParameterSegmentRefEntry:
            namespaceprefix_ = self.ParameterSegmentRefEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterSegmentRefEntry_nsprefix_) else ''
            ParameterSegmentRefEntry_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='ParameterSegmentRefEntry', pretty_print=pretty_print)
        for ContainerRefEntry_ in self.ContainerRefEntry:
            namespaceprefix_ = self.ContainerRefEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContainerRefEntry_nsprefix_) else ''
            ContainerRefEntry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContainerRefEntry',
                                      pretty_print=pretty_print)
        for ContainerSegmentRefEntry_ in self.ContainerSegmentRefEntry:
            namespaceprefix_ = self.ContainerSegmentRefEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContainerSegmentRefEntry_nsprefix_) else ''
            ContainerSegmentRefEntry_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='ContainerSegmentRefEntry', pretty_print=pretty_print)
        for StreamSegmentEntry_ in self.StreamSegmentEntry:
            namespaceprefix_ = self.StreamSegmentEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.StreamSegmentEntry_nsprefix_) else ''
            StreamSegmentEntry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StreamSegmentEntry',
                                       pretty_print=pretty_print)
        for IndirectParameterRefEntry_ in self.IndirectParameterRefEntry:
            namespaceprefix_ = self.IndirectParameterRefEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.IndirectParameterRefEntry_nsprefix_) else ''
            IndirectParameterRefEntry_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                              name_='IndirectParameterRefEntry', pretty_print=pretty_print)
        for ArrayParameterRefEntry_ in self.ArrayParameterRefEntry:
            namespaceprefix_ = self.ArrayParameterRefEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ArrayParameterRefEntry_nsprefix_) else ''
            ArrayParameterRefEntry_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='ArrayParameterRefEntry', pretty_print=pretty_print)
        for ArgumentRefEntry_ in self.ArgumentRefEntry:
            namespaceprefix_ = self.ArgumentRefEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ArgumentRefEntry_nsprefix_) else ''
            ArgumentRefEntry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ArgumentRefEntry',
                                     pretty_print=pretty_print)
        for ArrayArgumentRefEntry_ in self.ArrayArgumentRefEntry:
            namespaceprefix_ = self.ArrayArgumentRefEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ArrayArgumentRefEntry_nsprefix_) else ''
            ArrayArgumentRefEntry_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                          name_='ArrayArgumentRefEntry', pretty_print=pretty_print)
        for FixedValueEntry_ in self.FixedValueEntry:
            namespaceprefix_ = self.FixedValueEntry_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.FixedValueEntry_nsprefix_) else ''
            FixedValueEntry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FixedValueEntry',
                                    pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ParameterRefEntry':
            obj_ = ArgumentParameterRefEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterRefEntry.append(obj_)
            obj_.original_tagname_ = 'ParameterRefEntry'
        elif nodeName_ == 'ParameterSegmentRefEntry':
            obj_ = ArgumentParameterSegmentRefEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterSegmentRefEntry.append(obj_)
            obj_.original_tagname_ = 'ParameterSegmentRefEntry'
        elif nodeName_ == 'ContainerRefEntry':
            obj_ = ArgumentContainerRefEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContainerRefEntry.append(obj_)
            obj_.original_tagname_ = 'ContainerRefEntry'
        elif nodeName_ == 'ContainerSegmentRefEntry':
            obj_ = ArgumentContainerSegmentRefEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContainerSegmentRefEntry.append(obj_)
            obj_.original_tagname_ = 'ContainerSegmentRefEntry'
        elif nodeName_ == 'StreamSegmentEntry':
            obj_ = ArgumentStreamSegmentEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StreamSegmentEntry.append(obj_)
            obj_.original_tagname_ = 'StreamSegmentEntry'
        elif nodeName_ == 'IndirectParameterRefEntry':
            obj_ = ArgumentIndirectParameterRefEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IndirectParameterRefEntry.append(obj_)
            obj_.original_tagname_ = 'IndirectParameterRefEntry'
        elif nodeName_ == 'ArrayParameterRefEntry':
            obj_ = ArgumentArrayParameterRefEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ArrayParameterRefEntry.append(obj_)
            obj_.original_tagname_ = 'ArrayParameterRefEntry'
        elif nodeName_ == 'ArgumentRefEntry':
            obj_ = ArgumentArgumentRefEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ArgumentRefEntry.append(obj_)
            obj_.original_tagname_ = 'ArgumentRefEntry'
        elif nodeName_ == 'ArrayArgumentRefEntry':
            obj_ = ArgumentArrayArgumentRefEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ArrayArgumentRefEntry.append(obj_)
            obj_.original_tagname_ = 'ArrayArgumentRefEntry'
        elif nodeName_ == 'FixedValueEntry':
            obj_ = ArgumentFixedValueEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FixedValueEntry.append(obj_)
            obj_.original_tagname_ = 'FixedValueEntry'


# end class CommandContainerEntryListType


class CommandContainerSetType(GeneratedsSuper):
    """Contains an unordered Set of Command Containers"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, CommandContainer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if CommandContainer is None:
            self.CommandContainer = []
        else:
            self.CommandContainer = CommandContainer
        self.CommandContainer_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommandContainerSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommandContainerSetType.subclass:
            return CommandContainerSetType.subclass(*args_, **kwargs_)
        else:
            return CommandContainerSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_CommandContainer(self):
        return self.CommandContainer

    def set_CommandContainer(self, CommandContainer):
        self.CommandContainer = CommandContainer

    def add_CommandContainer(self, value):
        self.CommandContainer.append(value)

    def insert_CommandContainer_at(self, index, value):
        self.CommandContainer.insert(index, value)

    def replace_CommandContainer_at(self, index, value):
        self.CommandContainer[index] = value

    def hasContent_(self):
        if (
                self.CommandContainer
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='CommandContainerSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CommandContainerSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CommandContainerSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CommandContainerSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CommandContainerSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CommandContainerSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='CommandContainerSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CommandContainer_ in self.CommandContainer:
            namespaceprefix_ = self.CommandContainer_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CommandContainer_nsprefix_) else ''
            CommandContainer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CommandContainer',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CommandContainer':
            obj_ = SequenceContainerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CommandContainer.append(obj_)
            obj_.original_tagname_ = 'CommandContainer'


# end class CommandContainerSetType


class MetaCommandSetType(GeneratedsSuper):
    """Describes an unordered collection of command definitions. Duplicates are
    invalid based on the name attribute of MetaCommand and
    BlockMetaCommand. See MetaCommandType and BlockMetaCommandType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, MetaCommand=None, MetaCommandRef=None, BlockMetaCommand=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if MetaCommand is None:
            self.MetaCommand = []
        else:
            self.MetaCommand = MetaCommand
        self.MetaCommand_nsprefix_ = None
        if MetaCommandRef is None:
            self.MetaCommandRef = []
        else:
            self.MetaCommandRef = MetaCommandRef
        self.MetaCommandRef_nsprefix_ = None
        if BlockMetaCommand is None:
            self.BlockMetaCommand = []
        else:
            self.BlockMetaCommand = BlockMetaCommand
        self.BlockMetaCommand_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MetaCommandSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MetaCommandSetType.subclass:
            return MetaCommandSetType.subclass(*args_, **kwargs_)
        else:
            return MetaCommandSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MetaCommand(self):
        return self.MetaCommand

    def set_MetaCommand(self, MetaCommand):
        self.MetaCommand = MetaCommand

    def add_MetaCommand(self, value):
        self.MetaCommand.append(value)

    def insert_MetaCommand_at(self, index, value):
        self.MetaCommand.insert(index, value)

    def replace_MetaCommand_at(self, index, value):
        self.MetaCommand[index] = value

    def get_MetaCommandRef(self):
        return self.MetaCommandRef

    def set_MetaCommandRef(self, MetaCommandRef):
        self.MetaCommandRef = MetaCommandRef

    def add_MetaCommandRef(self, value):
        self.MetaCommandRef.append(value)

    def insert_MetaCommandRef_at(self, index, value):
        self.MetaCommandRef.insert(index, value)

    def replace_MetaCommandRef_at(self, index, value):
        self.MetaCommandRef[index] = value

    def get_BlockMetaCommand(self):
        return self.BlockMetaCommand

    def set_BlockMetaCommand(self, BlockMetaCommand):
        self.BlockMetaCommand = BlockMetaCommand

    def add_BlockMetaCommand(self, value):
        self.BlockMetaCommand.append(value)

    def insert_BlockMetaCommand_at(self, index, value):
        self.BlockMetaCommand.insert(index, value)

    def replace_BlockMetaCommand_at(self, index, value):
        self.BlockMetaCommand[index] = value

    def validate_NameReferenceType(self, value):
        result = True
        # Validate type NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))
                result = False
        return result

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                self.MetaCommand or
                self.MetaCommandRef or
                self.BlockMetaCommand
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MetaCommandSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MetaCommandSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MetaCommandSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MetaCommandSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MetaCommandSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MetaCommandSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MetaCommandSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MetaCommand_ in self.MetaCommand:
            namespaceprefix_ = self.MetaCommand_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MetaCommand_nsprefix_) else ''
            MetaCommand_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MetaCommand',
                                pretty_print=pretty_print)
        for MetaCommandRef_ in self.MetaCommandRef:
            namespaceprefix_ = self.MetaCommandRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MetaCommandRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetaCommandRef>%s</%sMetaCommandRef>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(MetaCommandRef_), input_name='MetaCommandRef')), namespaceprefix_,
                                                                         eol_))
        for BlockMetaCommand_ in self.BlockMetaCommand:
            namespaceprefix_ = self.BlockMetaCommand_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BlockMetaCommand_nsprefix_) else ''
            BlockMetaCommand_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BlockMetaCommand',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MetaCommand':
            obj_ = MetaCommandType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MetaCommand.append(obj_)
            obj_.original_tagname_ = 'MetaCommand'
        elif nodeName_ == 'MetaCommandRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MetaCommandRef')
            value_ = self.gds_validate_string(value_, node, 'MetaCommandRef')
            self.MetaCommandRef.append(value_)
            self.MetaCommandRef_nsprefix_ = child_.prefix
            # validate type NameReferenceType
            self.validate_NameReferenceType(self.MetaCommandRef[-1])
        elif nodeName_ == 'BlockMetaCommand':
            obj_ = BlockMetaCommandType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BlockMetaCommand.append(obj_)
            obj_.original_tagname_ = 'BlockMetaCommand'


# end class MetaCommandSetType


class MetaCommandStepListType(GeneratedsSuper):
    """Describe the list of MetaCommand definitions that form the block
    command. Contains an ordered list of MetaCommandSteps where each step
    is a MetaCommand with associated arguments, duplicates are valid. See
    BlockMetaCommandType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, MetaCommandStep=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if MetaCommandStep is None:
            self.MetaCommandStep = []
        else:
            self.MetaCommandStep = MetaCommandStep
        self.MetaCommandStep_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MetaCommandStepListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MetaCommandStepListType.subclass:
            return MetaCommandStepListType.subclass(*args_, **kwargs_)
        else:
            return MetaCommandStepListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MetaCommandStep(self):
        return self.MetaCommandStep

    def set_MetaCommandStep(self, MetaCommandStep):
        self.MetaCommandStep = MetaCommandStep

    def add_MetaCommandStep(self, value):
        self.MetaCommandStep.append(value)

    def insert_MetaCommandStep_at(self, index, value):
        self.MetaCommandStep.insert(index, value)

    def replace_MetaCommandStep_at(self, index, value):
        self.MetaCommandStep[index] = value

    def hasContent_(self):
        if (
                self.MetaCommandStep
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MetaCommandStepListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MetaCommandStepListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MetaCommandStepListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MetaCommandStepListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MetaCommandStepListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MetaCommandStepListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='MetaCommandStepListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MetaCommandStep_ in self.MetaCommandStep:
            namespaceprefix_ = self.MetaCommandStep_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MetaCommandStep_nsprefix_) else ''
            MetaCommandStep_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MetaCommandStep',
                                    pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MetaCommandStep':
            obj_ = MetaCommandStepType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MetaCommandStep.append(obj_)
            obj_.original_tagname_ = 'MetaCommandStep'


# end class MetaCommandStepListType


class MetaCommandStepType(GeneratedsSuper):
    """Describe a MetaCommand step, consisting MetaCommand reference and
    argument list. See MetaCommandStepListType and NameReferenceType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, metaCommandRef=None, ArgumentAssigmentList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.metaCommandRef = _cast(None, metaCommandRef)
        self.metaCommandRef_nsprefix_ = None
        self.ArgumentAssigmentList = ArgumentAssigmentList
        self.ArgumentAssigmentList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MetaCommandStepType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MetaCommandStepType.subclass:
            return MetaCommandStepType.subclass(*args_, **kwargs_)
        else:
            return MetaCommandStepType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ArgumentAssigmentList(self):
        return self.ArgumentAssigmentList

    def set_ArgumentAssigmentList(self, ArgumentAssigmentList):
        self.ArgumentAssigmentList = ArgumentAssigmentList

    def get_metaCommandRef(self):
        return self.metaCommandRef

    def set_metaCommandRef(self, metaCommandRef):
        self.metaCommandRef = metaCommandRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                self.ArgumentAssigmentList is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MetaCommandStepType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MetaCommandStepType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MetaCommandStepType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MetaCommandStepType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MetaCommandStepType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MetaCommandStepType'):
        if self.metaCommandRef is not None and 'metaCommandRef' not in already_processed:
            already_processed.add('metaCommandRef')
            outfile.write(' metaCommandRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.metaCommandRef), input_name='metaCommandRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MetaCommandStepType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ArgumentAssigmentList is not None:
            namespaceprefix_ = self.ArgumentAssigmentList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ArgumentAssigmentList_nsprefix_) else ''
            self.ArgumentAssigmentList.export(outfile, level, namespaceprefix_, namespacedef_='',
                                              name_='ArgumentAssigmentList', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('metaCommandRef', node)
        if value is not None and 'metaCommandRef' not in already_processed:
            already_processed.add('metaCommandRef')
            self.metaCommandRef = value
            self.validate_NameReferenceType(self.metaCommandRef)  # validate type NameReferenceType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ArgumentAssigmentList':
            obj_ = ArgumentAssignmentListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ArgumentAssigmentList = obj_
            obj_.original_tagname_ = 'ArgumentAssigmentList'


# end class MetaCommandStepType


class SignificanceType(GeneratedsSuper):
    """Significance provides some cautionary information about the potential
    consequence of each MetaCommand.If none is supplied, then the current
    SpaceSystem is assumed to be the one at risk by the issuance of this
    command"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, spaceSystemAtRisk=None, reasonForWarning=None, consequenceLevel='normal', gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.spaceSystemAtRisk = _cast(None, spaceSystemAtRisk)
        self.spaceSystemAtRisk_nsprefix_ = None
        self.reasonForWarning = _cast(None, reasonForWarning)
        self.reasonForWarning_nsprefix_ = None
        self.consequenceLevel = _cast(None, consequenceLevel)
        self.consequenceLevel_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignificanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignificanceType.subclass:
            return SignificanceType.subclass(*args_, **kwargs_)
        else:
            return SignificanceType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_spaceSystemAtRisk(self):
        return self.spaceSystemAtRisk

    def set_spaceSystemAtRisk(self, spaceSystemAtRisk):
        self.spaceSystemAtRisk = spaceSystemAtRisk

    def get_reasonForWarning(self):
        return self.reasonForWarning

    def set_reasonForWarning(self, reasonForWarning):
        self.reasonForWarning = reasonForWarning

    def get_consequenceLevel(self):
        return self.consequenceLevel

    def set_consequenceLevel(self, consequenceLevel):
        self.consequenceLevel = consequenceLevel

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def validate_ConsequenceLevelType(self, value):
        # Validate type xtce:ConsequenceLevelType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'vital', 'critical', 'forbidden', 'user1', 'user2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ConsequenceLevelType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='SignificanceType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignificanceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignificanceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignificanceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignificanceType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SignificanceType'):
        if self.spaceSystemAtRisk is not None and 'spaceSystemAtRisk' not in already_processed:
            already_processed.add('spaceSystemAtRisk')
            outfile.write(' spaceSystemAtRisk=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.spaceSystemAtRisk), input_name='spaceSystemAtRisk')),))
        if self.reasonForWarning is not None and 'reasonForWarning' not in already_processed:
            already_processed.add('reasonForWarning')
            outfile.write(' reasonForWarning=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.reasonForWarning), input_name='reasonForWarning')),))
        if self.consequenceLevel != "normal" and 'consequenceLevel' not in already_processed:
            already_processed.add('consequenceLevel')
            outfile.write(' consequenceLevel=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.consequenceLevel), input_name='consequenceLevel')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='SignificanceType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('spaceSystemAtRisk', node)
        if value is not None and 'spaceSystemAtRisk' not in already_processed:
            already_processed.add('spaceSystemAtRisk')
            self.spaceSystemAtRisk = value
            self.validate_NameReferenceType(self.spaceSystemAtRisk)  # validate type NameReferenceType
        value = find_attr_value_('reasonForWarning', node)
        if value is not None and 'reasonForWarning' not in already_processed:
            already_processed.add('reasonForWarning')
            self.reasonForWarning = value
        value = find_attr_value_('consequenceLevel', node)
        if value is not None and 'consequenceLevel' not in already_processed:
            already_processed.add('consequenceLevel')
            self.consequenceLevel = value
            self.validate_ConsequenceLevelType(self.consequenceLevel)  # validate type ConsequenceLevelType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class SignificanceType


class CheckWindowType(GeneratedsSuper):
    """Used by CommandVerifiers to limit the time allocated to check for the
    verification. See CheckWindowAlgorithmsType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, timeToStartChecking=None, timeToStopChecking=None,
                 timeWindowIsRelativeTo='timeLastVerifierPassed', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.timeToStartChecking = _cast(None, timeToStartChecking)
        self.timeToStartChecking_nsprefix_ = None
        self.timeToStopChecking = _cast(None, timeToStopChecking)
        self.timeToStopChecking_nsprefix_ = None
        self.timeWindowIsRelativeTo = _cast(None, timeWindowIsRelativeTo)
        self.timeWindowIsRelativeTo_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CheckWindowType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CheckWindowType.subclass:
            return CheckWindowType.subclass(*args_, **kwargs_)
        else:
            return CheckWindowType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_timeToStartChecking(self):
        return self.timeToStartChecking

    def set_timeToStartChecking(self, timeToStartChecking):
        self.timeToStartChecking = timeToStartChecking

    def get_timeToStopChecking(self):
        return self.timeToStopChecking

    def set_timeToStopChecking(self, timeToStopChecking):
        self.timeToStopChecking = timeToStopChecking

    def get_timeWindowIsRelativeTo(self):
        return self.timeWindowIsRelativeTo

    def set_timeWindowIsRelativeTo(self, timeWindowIsRelativeTo):
        self.timeWindowIsRelativeTo = timeWindowIsRelativeTo

    def validate_RelativeTimeType(self, value):
        # Validate type xtce:RelativeTimeType, a restriction on duration.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            pass

    def validate_TimeWindowIsRelativeToType(self, value):
        # Validate type xtce:TimeWindowIsRelativeToType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['commandRelease', 'timeLastVerifierPassed']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TimeWindowIsRelativeToType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='CheckWindowType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CheckWindowType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CheckWindowType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CheckWindowType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CheckWindowType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CheckWindowType'):
        if self.timeToStartChecking is not None and 'timeToStartChecking' not in already_processed:
            already_processed.add('timeToStartChecking')
            outfile.write(' timeToStartChecking=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.timeToStartChecking), input_name='timeToStartChecking')),))
        if self.timeToStopChecking is not None and 'timeToStopChecking' not in already_processed:
            already_processed.add('timeToStopChecking')
            outfile.write(' timeToStopChecking=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.timeToStopChecking), input_name='timeToStopChecking')),))
        if self.timeWindowIsRelativeTo != "timeLastVerifierPassed" and 'timeWindowIsRelativeTo' not in already_processed:
            already_processed.add('timeWindowIsRelativeTo')
            outfile.write(' timeWindowIsRelativeTo=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.timeWindowIsRelativeTo),
                                       input_name='timeWindowIsRelativeTo')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='CheckWindowType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timeToStartChecking', node)
        if value is not None and 'timeToStartChecking' not in already_processed:
            already_processed.add('timeToStartChecking')
            self.timeToStartChecking = value
            self.validate_RelativeTimeType(self.timeToStartChecking)  # validate type RelativeTimeType
        value = find_attr_value_('timeToStopChecking', node)
        if value is not None and 'timeToStopChecking' not in already_processed:
            already_processed.add('timeToStopChecking')
            self.timeToStopChecking = value
            self.validate_RelativeTimeType(self.timeToStopChecking)  # validate type RelativeTimeType
        value = find_attr_value_('timeWindowIsRelativeTo', node)
        if value is not None and 'timeWindowIsRelativeTo' not in already_processed:
            already_processed.add('timeWindowIsRelativeTo')
            self.timeWindowIsRelativeTo = value
            self.validate_TimeWindowIsRelativeToType(
                self.timeWindowIsRelativeTo)  # validate type TimeWindowIsRelativeToType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class CheckWindowType


class CheckWindowAlgorithmsType(GeneratedsSuper):
    """Used by CommandVerifiers to limit the time allocated to check for the
    verification. See CommandVerifierType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, StartCheck=None, StopTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.StartCheck = StartCheck
        self.StartCheck_nsprefix_ = None
        self.StopTime = StopTime
        self.StopTime_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CheckWindowAlgorithmsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CheckWindowAlgorithmsType.subclass:
            return CheckWindowAlgorithmsType.subclass(*args_, **kwargs_)
        else:
            return CheckWindowAlgorithmsType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_StartCheck(self):
        return self.StartCheck

    def set_StartCheck(self, StartCheck):
        self.StartCheck = StartCheck

    def get_StopTime(self):
        return self.StopTime

    def set_StopTime(self, StopTime):
        self.StopTime = StopTime

    def hasContent_(self):
        if (
                self.StartCheck is not None or
                self.StopTime is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='CheckWindowAlgorithmsType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CheckWindowAlgorithmsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CheckWindowAlgorithmsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CheckWindowAlgorithmsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CheckWindowAlgorithmsType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='CheckWindowAlgorithmsType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='CheckWindowAlgorithmsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StartCheck is not None:
            namespaceprefix_ = self.StartCheck_nsprefix_ + ':' if (UseCapturedNS_ and self.StartCheck_nsprefix_) else ''
            self.StartCheck.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StartCheck',
                                   pretty_print=pretty_print)
        if self.StopTime is not None:
            namespaceprefix_ = self.StopTime_nsprefix_ + ':' if (UseCapturedNS_ and self.StopTime_nsprefix_) else ''
            self.StopTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StopTime',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'StartCheck':
            class_obj_ = self.get_class_obj_(child_, InputAlgorithmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StartCheck = obj_
            obj_.original_tagname_ = 'StartCheck'
        elif nodeName_ == 'StopTime':
            class_obj_ = self.get_class_obj_(child_, InputAlgorithmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StopTime = obj_
            obj_.original_tagname_ = 'StopTime'


# end class CheckWindowAlgorithmsType


class ContextSignificanceType(GeneratedsSuper):
    """Describe a significance level for a MetaCommand definition where the
    significance level depends on matching a context value. See
    ContextMatchType and SignificanceType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ContextMatch=None, Significance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ContextMatch = ContextMatch
        self.ContextMatch_nsprefix_ = None
        self.Significance = Significance
        self.Significance_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContextSignificanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContextSignificanceType.subclass:
            return ContextSignificanceType.subclass(*args_, **kwargs_)
        else:
            return ContextSignificanceType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextMatch(self):
        return self.ContextMatch

    def set_ContextMatch(self, ContextMatch):
        self.ContextMatch = ContextMatch

    def get_Significance(self):
        return self.Significance

    def set_Significance(self, Significance):
        self.Significance = Significance

    def hasContent_(self):
        if (
                self.ContextMatch is not None or
                self.Significance is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ContextSignificanceType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContextSignificanceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContextSignificanceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContextSignificanceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContextSignificanceType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContextSignificanceType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ContextSignificanceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContextMatch is not None:
            namespaceprefix_ = self.ContextMatch_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextMatch_nsprefix_) else ''
            self.ContextMatch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextMatch',
                                     pretty_print=pretty_print)
        if self.Significance is not None:
            namespaceprefix_ = self.Significance_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.Significance_nsprefix_) else ''
            self.Significance.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Significance',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextMatch':
            obj_ = ContextMatchType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextMatch = obj_
            obj_.original_tagname_ = 'ContextMatch'
        elif nodeName_ == 'Significance':
            obj_ = SignificanceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Significance = obj_
            obj_.original_tagname_ = 'Significance'


# end class ContextSignificanceType


class ContextSignificanceListType(GeneratedsSuper):
    """Describe an ordered list of ContextSignificance elements where the
    significance on the first context match to test true is used as the
    significance of the MetaCommand. If there is a DefaultSignificance, it
    is overrideen by the matching context. See ContextSignificantType and
    MetaCommandType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ContextSignificance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ContextSignificance is None:
            self.ContextSignificance = []
        else:
            self.ContextSignificance = ContextSignificance
        self.ContextSignificance_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContextSignificanceListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContextSignificanceListType.subclass:
            return ContextSignificanceListType.subclass(*args_, **kwargs_)
        else:
            return ContextSignificanceListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextSignificance(self):
        return self.ContextSignificance

    def set_ContextSignificance(self, ContextSignificance):
        self.ContextSignificance = ContextSignificance

    def add_ContextSignificance(self, value):
        self.ContextSignificance.append(value)

    def insert_ContextSignificance_at(self, index, value):
        self.ContextSignificance.insert(index, value)

    def replace_ContextSignificance_at(self, index, value):
        self.ContextSignificance[index] = value

    def hasContent_(self):
        if (
                self.ContextSignificance
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ContextSignificanceListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContextSignificanceListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContextSignificanceListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContextSignificanceListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ContextSignificanceListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ContextSignificanceListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ContextSignificanceListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContextSignificance_ in self.ContextSignificance:
            namespaceprefix_ = self.ContextSignificance_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextSignificance_nsprefix_) else ''
            ContextSignificance_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextSignificance',
                                        pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextSignificance':
            obj_ = ContextSignificanceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextSignificance.append(obj_)
            obj_.original_tagname_ = 'ContextSignificance'


# end class ContextSignificanceListType


class InterlockType(GeneratedsSuper):
    """Describe a type of constraint on the next command, rather than this
    command. Interlocks apply only to the next command. An interlock will
    block successive commands until this command has reached a certain
    stage of verifier. Interlocks are scoped to a SpaceSystem basis: they
    by default apply to the SpaceSystem the MetaCommand is defined in but
    this may be overridden. See MetaCommandType and VerifierSetType.The
    name of a SpaceSystem this Interlock applies to. By default, it only
    applies to the SpaceSystem that contains this MetaCommand.The
    verification stage of the command that releases the interlock, with the
    default being complete.Only applies when the verificationToWaitFor
    attribute is 'queued' or 'executing'.A flag that indicates that under
    special circumstances, this Interlock can be suspended."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, scopeToSpaceSystem=None, verificationToWaitFor='complete', verificationProgressPercentage=None,
                 suspendable=False, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.scopeToSpaceSystem = _cast(None, scopeToSpaceSystem)
        self.scopeToSpaceSystem_nsprefix_ = None
        self.verificationToWaitFor = _cast(None, verificationToWaitFor)
        self.verificationToWaitFor_nsprefix_ = None
        self.verificationProgressPercentage = _cast(float, verificationProgressPercentage)
        self.verificationProgressPercentage_nsprefix_ = None
        self.suspendable = _cast(bool, suspendable)
        self.suspendable_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InterlockType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InterlockType.subclass:
            return InterlockType.subclass(*args_, **kwargs_)
        else:
            return InterlockType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_scopeToSpaceSystem(self):
        return self.scopeToSpaceSystem

    def set_scopeToSpaceSystem(self, scopeToSpaceSystem):
        self.scopeToSpaceSystem = scopeToSpaceSystem

    def get_verificationToWaitFor(self):
        return self.verificationToWaitFor

    def set_verificationToWaitFor(self, verificationToWaitFor):
        self.verificationToWaitFor = verificationToWaitFor

    def get_verificationProgressPercentage(self):
        return self.verificationProgressPercentage

    def set_verificationProgressPercentage(self, verificationProgressPercentage):
        self.verificationProgressPercentage = verificationProgressPercentage

    def get_suspendable(self):
        return self.suspendable

    def set_suspendable(self, suspendable):
        self.suspendable = suspendable

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def validate_VerifierEnumerationType(self, value):
        # Validate type xtce:VerifierEnumerationType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['release', 'transferredToRange', 'sentFromRange', 'received', 'accepted', 'queued',
                            'executing', 'complete', 'failed']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on VerifierEnumerationType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='InterlockType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InterlockType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InterlockType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InterlockType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InterlockType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InterlockType'):
        if self.scopeToSpaceSystem is not None and 'scopeToSpaceSystem' not in already_processed:
            already_processed.add('scopeToSpaceSystem')
            outfile.write(' scopeToSpaceSystem=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.scopeToSpaceSystem), input_name='scopeToSpaceSystem')),))
        if self.verificationToWaitFor != "complete" and 'verificationToWaitFor' not in already_processed:
            already_processed.add('verificationToWaitFor')
            outfile.write(' verificationToWaitFor=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.verificationToWaitFor), input_name='verificationToWaitFor')),))
        if self.verificationProgressPercentage is not None and 'verificationProgressPercentage' not in already_processed:
            already_processed.add('verificationProgressPercentage')
            outfile.write(
                ' verificationProgressPercentage="%s"' % self.gds_format_double(self.verificationProgressPercentage,
                                                                                input_name='verificationProgressPercentage'))
        if self.suspendable and 'suspendable' not in already_processed:
            already_processed.add('suspendable')
            outfile.write(' suspendable="%s"' % self.gds_format_boolean(self.suspendable, input_name='suspendable'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='InterlockType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scopeToSpaceSystem', node)
        if value is not None and 'scopeToSpaceSystem' not in already_processed:
            already_processed.add('scopeToSpaceSystem')
            self.scopeToSpaceSystem = value
            self.validate_NameReferenceType(self.scopeToSpaceSystem)  # validate type NameReferenceType
        value = find_attr_value_('verificationToWaitFor', node)
        if value is not None and 'verificationToWaitFor' not in already_processed:
            already_processed.add('verificationToWaitFor')
            self.verificationToWaitFor = value
            self.validate_VerifierEnumerationType(self.verificationToWaitFor)  # validate type VerifierEnumerationType
        value = find_attr_value_('verificationProgressPercentage', node)
        if value is not None and 'verificationProgressPercentage' not in already_processed:
            already_processed.add('verificationProgressPercentage')
            value = self.gds_parse_double(value, node, 'verificationProgressPercentage')
            self.verificationProgressPercentage = value
        value = find_attr_value_('suspendable', node)
        if value is not None and 'suspendable' not in already_processed:
            already_processed.add('suspendable')
            if value in ('true', '1'):
                self.suspendable = True
            elif value in ('false', '0'):
                self.suspendable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class InterlockType


class ParameterToSetType(ParameterRefType):
    """Sets a Parameter to a new value (either from a derivation or explicitly)
    after the command has been verified (all verifications have
    passed).This attribute provides more specific control over when the
    Parameter value is set. By default, it is when the command have all
    verifications complete. See VerifierEnumerationType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ParameterRefType

    def __init__(self, parameterRef=None, setOnVerification='complete', Derivation=None, NewValue=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ParameterToSetType, self).__init__(parameterRef, **kwargs_)
        self.setOnVerification = _cast(None, setOnVerification)
        self.setOnVerification_nsprefix_ = None
        self.Derivation = Derivation
        self.Derivation_nsprefix_ = None
        self.NewValue = NewValue
        self.NewValue_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterToSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterToSetType.subclass:
            return ParameterToSetType.subclass(*args_, **kwargs_)
        else:
            return ParameterToSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Derivation(self):
        return self.Derivation

    def set_Derivation(self, Derivation):
        self.Derivation = Derivation

    def set_Derivation_with_type(self, value):
        self.Derivation = value
        value.original_tagname_ = 'Derivation'
        value.extensiontype_ = value.__class__.__name__

    def get_NewValue(self):
        return self.NewValue

    def set_NewValue(self, NewValue):
        self.NewValue = NewValue

    def get_setOnVerification(self):
        return self.setOnVerification

    def set_setOnVerification(self, setOnVerification):
        self.setOnVerification = setOnVerification

    def validate_VerifierEnumerationType(self, value):
        # Validate type xtce:VerifierEnumerationType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['release', 'transferredToRange', 'sentFromRange', 'received', 'accepted', 'queued',
                            'executing', 'complete', 'failed']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on VerifierEnumerationType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.Derivation is not None or
                self.NewValue is not None or
                super(ParameterToSetType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
               name_='ParameterToSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterToSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterToSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterToSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParameterToSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParameterToSetType'):
        super(ParameterToSetType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                         name_='ParameterToSetType')
        if self.setOnVerification != "complete" and 'setOnVerification' not in already_processed:
            already_processed.add('setOnVerification')
            outfile.write(' setOnVerification=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.setOnVerification), input_name='setOnVerification')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
                       name_='ParameterToSetType', fromsubclass_=False, pretty_print=True):
        super(ParameterToSetType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                       pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Derivation is not None:
            self.Derivation.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        if self.NewValue is not None:
            namespaceprefix_ = self.NewValue_nsprefix_ + ':' if (UseCapturedNS_ and self.NewValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNewValue>%s</%sNewValue>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.NewValue), input_name='NewValue')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('setOnVerification', node)
        if value is not None and 'setOnVerification' not in already_processed:
            already_processed.add('setOnVerification')
            self.setOnVerification = value
            self.validate_VerifierEnumerationType(self.setOnVerification)  # validate type VerifierEnumerationType
        super(ParameterToSetType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Derivation':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_, gds_collector_=gds_collector_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Derivation> element')
            self.Derivation = obj_
            obj_.original_tagname_ = 'Derivation'
        elif nodeName_ == 'NewValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NewValue')
            value_ = self.gds_validate_string(value_, node, 'NewValue')
            self.NewValue = value_
            self.NewValue_nsprefix_ = child_.prefix
        super(ParameterToSetType, self).buildChildren(child_, node, nodeName_, True)


# end class ParameterToSetType


class ParameterToSetListType(GeneratedsSuper):
    """Parameters that are set with a new value after the command has been
    sent. Appended to the Base Command list"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ParameterToSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ParameterToSet is None:
            self.ParameterToSet = []
        else:
            self.ParameterToSet = ParameterToSet
        self.ParameterToSet_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterToSetListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterToSetListType.subclass:
            return ParameterToSetListType.subclass(*args_, **kwargs_)
        else:
            return ParameterToSetListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ParameterToSet(self):
        return self.ParameterToSet

    def set_ParameterToSet(self, ParameterToSet):
        self.ParameterToSet = ParameterToSet

    def add_ParameterToSet(self, value):
        self.ParameterToSet.append(value)

    def insert_ParameterToSet_at(self, index, value):
        self.ParameterToSet.insert(index, value)

    def replace_ParameterToSet_at(self, index, value):
        self.ParameterToSet[index] = value

    def hasContent_(self):
        if (
                self.ParameterToSet
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ParameterToSetListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterToSetListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterToSetListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterToSetListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParameterToSetListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParameterToSetListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ParameterToSetListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ParameterToSet_ in self.ParameterToSet:
            namespaceprefix_ = self.ParameterToSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterToSet_nsprefix_) else ''
            ParameterToSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ParameterToSet',
                                   pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ParameterToSet':
            obj_ = ParameterToSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterToSet.append(obj_)
            obj_.original_tagname_ = 'ParameterToSet'


# end class ParameterToSetListType


class ParameterToSuspendAlarmsOnType(ParameterRefType):
    """Will suspend all Alarms associated with this Parameter for the given
    suspense time after the given verifier"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ParameterRefType

    def __init__(self, parameterRef=None, suspenseTime=None, verifierToTriggerOn='release', gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ParameterToSuspendAlarmsOnType, self).__init__(parameterRef, **kwargs_)
        self.suspenseTime = _cast(None, suspenseTime)
        self.suspenseTime_nsprefix_ = None
        self.verifierToTriggerOn = _cast(None, verifierToTriggerOn)
        self.verifierToTriggerOn_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterToSuspendAlarmsOnType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterToSuspendAlarmsOnType.subclass:
            return ParameterToSuspendAlarmsOnType.subclass(*args_, **kwargs_)
        else:
            return ParameterToSuspendAlarmsOnType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_suspenseTime(self):
        return self.suspenseTime

    def set_suspenseTime(self, suspenseTime):
        self.suspenseTime = suspenseTime

    def get_verifierToTriggerOn(self):
        return self.verifierToTriggerOn

    def set_verifierToTriggerOn(self, verifierToTriggerOn):
        self.verifierToTriggerOn = verifierToTriggerOn

    def validate_RelativeTimeType(self, value):
        # Validate type xtce:RelativeTimeType, a restriction on duration.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            pass

    def validate_VerifierEnumerationType(self, value):
        # Validate type xtce:VerifierEnumerationType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['release', 'transferredToRange', 'sentFromRange', 'received', 'accepted', 'queued',
                            'executing', 'complete', 'failed']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on VerifierEnumerationType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(ParameterToSuspendAlarmsOnType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
               name_='ParameterToSuspendAlarmsOnType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterToSuspendAlarmsOnType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterToSuspendAlarmsOnType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='ParameterToSuspendAlarmsOnType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ParameterToSuspendAlarmsOnType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ParameterToSuspendAlarmsOnType'):
        super(ParameterToSuspendAlarmsOnType, self).exportAttributes(outfile, level, already_processed,
                                                                     namespaceprefix_,
                                                                     name_='ParameterToSuspendAlarmsOnType')
        if self.suspenseTime is not None and 'suspenseTime' not in already_processed:
            already_processed.add('suspenseTime')
            outfile.write(' suspenseTime=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.suspenseTime), input_name='suspenseTime')),))
        if self.verifierToTriggerOn != "release" and 'verifierToTriggerOn' not in already_processed:
            already_processed.add('verifierToTriggerOn')
            outfile.write(' verifierToTriggerOn=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.verifierToTriggerOn), input_name='verifierToTriggerOn')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ParameterToSuspendAlarmsOnType', fromsubclass_=False, pretty_print=True):
        super(ParameterToSuspendAlarmsOnType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_,
                                                                   name_, True, pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('suspenseTime', node)
        if value is not None and 'suspenseTime' not in already_processed:
            already_processed.add('suspenseTime')
            self.suspenseTime = value
            self.validate_RelativeTimeType(self.suspenseTime)  # validate type RelativeTimeType
        value = find_attr_value_('verifierToTriggerOn', node)
        if value is not None and 'verifierToTriggerOn' not in already_processed:
            already_processed.add('verifierToTriggerOn')
            self.verifierToTriggerOn = value
            self.validate_VerifierEnumerationType(self.verifierToTriggerOn)  # validate type VerifierEnumerationType
        super(ParameterToSuspendAlarmsOnType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ParameterToSuspendAlarmsOnType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ParameterToSuspendAlarmsOnType


class ParametersToSuspendAlarmsOnSetType(GeneratedsSuper):
    """Sometimes it is necessary to suspend alarms - particularly 'change'
    alarms for commands that will change the value of a Parameter"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ParameterToSuspendAlarmsOn=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ParameterToSuspendAlarmsOn is None:
            self.ParameterToSuspendAlarmsOn = []
        else:
            self.ParameterToSuspendAlarmsOn = ParameterToSuspendAlarmsOn
        self.ParameterToSuspendAlarmsOn_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParametersToSuspendAlarmsOnSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParametersToSuspendAlarmsOnSetType.subclass:
            return ParametersToSuspendAlarmsOnSetType.subclass(*args_, **kwargs_)
        else:
            return ParametersToSuspendAlarmsOnSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ParameterToSuspendAlarmsOn(self):
        return self.ParameterToSuspendAlarmsOn

    def set_ParameterToSuspendAlarmsOn(self, ParameterToSuspendAlarmsOn):
        self.ParameterToSuspendAlarmsOn = ParameterToSuspendAlarmsOn

    def add_ParameterToSuspendAlarmsOn(self, value):
        self.ParameterToSuspendAlarmsOn.append(value)

    def insert_ParameterToSuspendAlarmsOn_at(self, index, value):
        self.ParameterToSuspendAlarmsOn.insert(index, value)

    def replace_ParameterToSuspendAlarmsOn_at(self, index, value):
        self.ParameterToSuspendAlarmsOn[index] = value

    def hasContent_(self):
        if (
                self.ParameterToSuspendAlarmsOn
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
               name_='ParametersToSuspendAlarmsOnSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParametersToSuspendAlarmsOnSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParametersToSuspendAlarmsOnSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='ParametersToSuspendAlarmsOnSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ParametersToSuspendAlarmsOnSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ParametersToSuspendAlarmsOnSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ParametersToSuspendAlarmsOnSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ParameterToSuspendAlarmsOn_ in self.ParameterToSuspendAlarmsOn:
            namespaceprefix_ = self.ParameterToSuspendAlarmsOn_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterToSuspendAlarmsOn_nsprefix_) else ''
            ParameterToSuspendAlarmsOn_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                               name_='ParameterToSuspendAlarmsOn', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ParameterToSuspendAlarmsOn':
            obj_ = ParameterToSuspendAlarmsOnType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterToSuspendAlarmsOn.append(obj_)
            obj_.original_tagname_ = 'ParameterToSuspendAlarmsOn'


# end class ParametersToSuspendAlarmsOnSetType


class ParameterValueChangeType(GeneratedsSuper):
    """A parameter change in value or specified delta change in value."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ParameterRef=None, Change=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ParameterRef = ParameterRef
        self.ParameterRef_nsprefix_ = None
        self.Change = Change
        self.Change_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterValueChangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterValueChangeType.subclass:
            return ParameterValueChangeType.subclass(*args_, **kwargs_)
        else:
            return ParameterValueChangeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ParameterRef(self):
        return self.ParameterRef

    def set_ParameterRef(self, ParameterRef):
        self.ParameterRef = ParameterRef

    def get_Change(self):
        return self.Change

    def set_Change(self, Change):
        self.Change = Change

    def hasContent_(self):
        if (
                self.ParameterRef is not None or
                self.Change is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ParameterValueChangeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterValueChangeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterValueChangeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterValueChangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParameterValueChangeType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ParameterValueChangeType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ParameterValueChangeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ParameterRef is not None:
            namespaceprefix_ = self.ParameterRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterRef_nsprefix_) else ''
            self.ParameterRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ParameterRef',
                                     pretty_print=pretty_print)
        if self.Change is not None:
            namespaceprefix_ = self.Change_nsprefix_ + ':' if (UseCapturedNS_ and self.Change_nsprefix_) else ''
            self.Change.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Change',
                               pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ParameterRef':
            class_obj_ = self.get_class_obj_(child_, ParameterRefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterRef = obj_
            obj_.original_tagname_ = 'ParameterRef'
        elif nodeName_ == 'Change':
            obj_ = ChangeValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Change = obj_
            obj_.original_tagname_ = 'Change'


# end class ParameterValueChangeType


class TransmissionConstraintListType(GeneratedsSuper):
    """Appended to the TramsmissionConstraint List of the base command.
    Constraints are checked in order."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, TransmissionConstraint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if TransmissionConstraint is None:
            self.TransmissionConstraint = []
        else:
            self.TransmissionConstraint = TransmissionConstraint
        self.TransmissionConstraint_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransmissionConstraintListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransmissionConstraintListType.subclass:
            return TransmissionConstraintListType.subclass(*args_, **kwargs_)
        else:
            return TransmissionConstraintListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_TransmissionConstraint(self):
        return self.TransmissionConstraint

    def set_TransmissionConstraint(self, TransmissionConstraint):
        self.TransmissionConstraint = TransmissionConstraint

    def add_TransmissionConstraint(self, value):
        self.TransmissionConstraint.append(value)

    def insert_TransmissionConstraint_at(self, index, value):
        self.TransmissionConstraint.insert(index, value)

    def replace_TransmissionConstraint_at(self, index, value):
        self.TransmissionConstraint[index] = value

    def hasContent_(self):
        if (
                self.TransmissionConstraint
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
               name_='TransmissionConstraintListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransmissionConstraintListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransmissionConstraintListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='TransmissionConstraintListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='TransmissionConstraintListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='TransmissionConstraintListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='TransmissionConstraintListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TransmissionConstraint_ in self.TransmissionConstraint:
            namespaceprefix_ = self.TransmissionConstraint_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TransmissionConstraint_nsprefix_) else ''
            TransmissionConstraint_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='TransmissionConstraint', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TransmissionConstraint':
            obj_ = TransmissionConstraintType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TransmissionConstraint.append(obj_)
            obj_.original_tagname_ = 'TransmissionConstraint'


# end class TransmissionConstraintListType


class VerifierSetType(GeneratedsSuper):
    """Describe a collection of unordered verifiers. A command verifier is a
    conditional check on the telemetry from a SpaceSystem that that
    provides positive indication on the processing state of a command.
    There are eight different verifiers each associated with difference
    states in command processing: TransferredToRange, TransferredFromRange,
    Received, Accepted, Queued, Execution, Complete, and Failed. There may
    be multiple ‘complete’ and 'execution' verifiers. If the MetaCommand is
    part of an inheritance relation (BaseMetaCommand), the 'complete' and
    'execution' verifier sets are appended to any defined in the parent
    MetaCommand. All others will override a verifier defined in a
    BaseMetaCommand. Duplicate verifiers in the list of CompleteVerifiers
    and ExecutionVerifiers before and after appending to the verifiers in
    BaseMetaCommand should be avoided. See MetaCommandType and
    BaseMetaCommandType for additional information."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, TransferredToRangeVerifier=None, SentFromRangeVerifier=None, ReceivedVerifier=None,
                 AcceptedVerifier=None, QueuedVerifier=None, ExecutionVerifier=None, CompleteVerifier=None,
                 FailedVerifier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TransferredToRangeVerifier = TransferredToRangeVerifier
        self.TransferredToRangeVerifier_nsprefix_ = None
        self.SentFromRangeVerifier = SentFromRangeVerifier
        self.SentFromRangeVerifier_nsprefix_ = None
        self.ReceivedVerifier = ReceivedVerifier
        self.ReceivedVerifier_nsprefix_ = None
        self.AcceptedVerifier = AcceptedVerifier
        self.AcceptedVerifier_nsprefix_ = None
        self.QueuedVerifier = QueuedVerifier
        self.QueuedVerifier_nsprefix_ = None
        if ExecutionVerifier is None:
            self.ExecutionVerifier = []
        else:
            self.ExecutionVerifier = ExecutionVerifier
        self.ExecutionVerifier_nsprefix_ = None
        if CompleteVerifier is None:
            self.CompleteVerifier = []
        else:
            self.CompleteVerifier = CompleteVerifier
        self.CompleteVerifier_nsprefix_ = None
        self.FailedVerifier = FailedVerifier
        self.FailedVerifier_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerifierSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerifierSetType.subclass:
            return VerifierSetType.subclass(*args_, **kwargs_)
        else:
            return VerifierSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_TransferredToRangeVerifier(self):
        return self.TransferredToRangeVerifier

    def set_TransferredToRangeVerifier(self, TransferredToRangeVerifier):
        self.TransferredToRangeVerifier = TransferredToRangeVerifier

    def get_SentFromRangeVerifier(self):
        return self.SentFromRangeVerifier

    def set_SentFromRangeVerifier(self, SentFromRangeVerifier):
        self.SentFromRangeVerifier = SentFromRangeVerifier

    def get_ReceivedVerifier(self):
        return self.ReceivedVerifier

    def set_ReceivedVerifier(self, ReceivedVerifier):
        self.ReceivedVerifier = ReceivedVerifier

    def get_AcceptedVerifier(self):
        return self.AcceptedVerifier

    def set_AcceptedVerifier(self, AcceptedVerifier):
        self.AcceptedVerifier = AcceptedVerifier

    def get_QueuedVerifier(self):
        return self.QueuedVerifier

    def set_QueuedVerifier(self, QueuedVerifier):
        self.QueuedVerifier = QueuedVerifier

    def get_ExecutionVerifier(self):
        return self.ExecutionVerifier

    def set_ExecutionVerifier(self, ExecutionVerifier):
        self.ExecutionVerifier = ExecutionVerifier

    def add_ExecutionVerifier(self, value):
        self.ExecutionVerifier.append(value)

    def insert_ExecutionVerifier_at(self, index, value):
        self.ExecutionVerifier.insert(index, value)

    def replace_ExecutionVerifier_at(self, index, value):
        self.ExecutionVerifier[index] = value

    def get_CompleteVerifier(self):
        return self.CompleteVerifier

    def set_CompleteVerifier(self, CompleteVerifier):
        self.CompleteVerifier = CompleteVerifier

    def add_CompleteVerifier(self, value):
        self.CompleteVerifier.append(value)

    def insert_CompleteVerifier_at(self, index, value):
        self.CompleteVerifier.insert(index, value)

    def replace_CompleteVerifier_at(self, index, value):
        self.CompleteVerifier[index] = value

    def get_FailedVerifier(self):
        return self.FailedVerifier

    def set_FailedVerifier(self, FailedVerifier):
        self.FailedVerifier = FailedVerifier

    def hasContent_(self):
        if (
                self.TransferredToRangeVerifier is not None or
                self.SentFromRangeVerifier is not None or
                self.ReceivedVerifier is not None or
                self.AcceptedVerifier is not None or
                self.QueuedVerifier is not None or
                self.ExecutionVerifier or
                self.CompleteVerifier or
                self.FailedVerifier is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='VerifierSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VerifierSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VerifierSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VerifierSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VerifierSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VerifierSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='VerifierSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TransferredToRangeVerifier is not None:
            namespaceprefix_ = self.TransferredToRangeVerifier_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TransferredToRangeVerifier_nsprefix_) else ''
            self.TransferredToRangeVerifier.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                   name_='TransferredToRangeVerifier', pretty_print=pretty_print)
        if self.SentFromRangeVerifier is not None:
            namespaceprefix_ = self.SentFromRangeVerifier_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SentFromRangeVerifier_nsprefix_) else ''
            self.SentFromRangeVerifier.export(outfile, level, namespaceprefix_, namespacedef_='',
                                              name_='SentFromRangeVerifier', pretty_print=pretty_print)
        if self.ReceivedVerifier is not None:
            namespaceprefix_ = self.ReceivedVerifier_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ReceivedVerifier_nsprefix_) else ''
            self.ReceivedVerifier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReceivedVerifier',
                                         pretty_print=pretty_print)
        if self.AcceptedVerifier is not None:
            namespaceprefix_ = self.AcceptedVerifier_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AcceptedVerifier_nsprefix_) else ''
            self.AcceptedVerifier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AcceptedVerifier',
                                         pretty_print=pretty_print)
        if self.QueuedVerifier is not None:
            namespaceprefix_ = self.QueuedVerifier_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.QueuedVerifier_nsprefix_) else ''
            self.QueuedVerifier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='QueuedVerifier',
                                       pretty_print=pretty_print)
        for ExecutionVerifier_ in self.ExecutionVerifier:
            namespaceprefix_ = self.ExecutionVerifier_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ExecutionVerifier_nsprefix_) else ''
            ExecutionVerifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ExecutionVerifier',
                                      pretty_print=pretty_print)
        for CompleteVerifier_ in self.CompleteVerifier:
            namespaceprefix_ = self.CompleteVerifier_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CompleteVerifier_nsprefix_) else ''
            CompleteVerifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CompleteVerifier',
                                     pretty_print=pretty_print)
        if self.FailedVerifier is not None:
            namespaceprefix_ = self.FailedVerifier_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.FailedVerifier_nsprefix_) else ''
            self.FailedVerifier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FailedVerifier',
                                       pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TransferredToRangeVerifier':
            obj_ = TransferredToRangeVerifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TransferredToRangeVerifier = obj_
            obj_.original_tagname_ = 'TransferredToRangeVerifier'
        elif nodeName_ == 'SentFromRangeVerifier':
            obj_ = SentFromRangeVerifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SentFromRangeVerifier = obj_
            obj_.original_tagname_ = 'SentFromRangeVerifier'
        elif nodeName_ == 'ReceivedVerifier':
            obj_ = ReceivedVerifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReceivedVerifier = obj_
            obj_.original_tagname_ = 'ReceivedVerifier'
        elif nodeName_ == 'AcceptedVerifier':
            obj_ = AcceptedVerifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AcceptedVerifier = obj_
            obj_.original_tagname_ = 'AcceptedVerifier'
        elif nodeName_ == 'QueuedVerifier':
            obj_ = QueuedVerifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.QueuedVerifier = obj_
            obj_.original_tagname_ = 'QueuedVerifier'
        elif nodeName_ == 'ExecutionVerifier':
            obj_ = ExecutionVerifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ExecutionVerifier.append(obj_)
            obj_.original_tagname_ = 'ExecutionVerifier'
        elif nodeName_ == 'CompleteVerifier':
            obj_ = CompleteVerifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CompleteVerifier.append(obj_)
            obj_.original_tagname_ = 'CompleteVerifier'
        elif nodeName_ == 'FailedVerifier':
            obj_ = FailedVerifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FailedVerifier = obj_
            obj_.original_tagname_ = 'FailedVerifier'


# end class VerifierSetType


class AlgorithmTextType(GeneratedsSuper):
    """This optional element may be used to enter Pseudo or actual code for the
    algorithm. The language for the algorithm is specified with the
    language attribute"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, language='pseudo', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlgorithmTextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlgorithmTextType.subclass:
            return AlgorithmTextType.subclass(*args_, **kwargs_)
        else:
            return AlgorithmTextType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_language(self):
        return self.language

    def set_language(self, language):
        self.language = language

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AlgorithmTextType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlgorithmTextType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AlgorithmTextType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlgorithmTextType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlgorithmTextType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlgorithmTextType'):
        if self.language != "pseudo" and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AlgorithmTextType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class AlgorithmTextType


class BaseTriggerType(GeneratedsSuper):
    """A base type for the various triggers, purely to improve the mappings
    created by data binding compilers."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseTriggerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseTriggerType.subclass:
            return BaseTriggerType.subclass(*args_, **kwargs_)
        else:
            return BaseTriggerType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BaseTriggerType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseTriggerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BaseTriggerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseTriggerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseTriggerType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseTriggerType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BaseTriggerType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class BaseTriggerType


class ChecksumType(GeneratedsSuper):
    """Describe checksum information.Qualified list of name checksum
    algorithms. If custom is chosen, InputAlgorithm must be set."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, bitsFromReference=None, reference='start', name=None, hashSizeInBits=None, InputAlgorithm=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.bitsFromReference = _cast(int, bitsFromReference)
        self.bitsFromReference_nsprefix_ = None
        self.reference = _cast(None, reference)
        self.reference_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.hashSizeInBits = _cast(int, hashSizeInBits)
        self.hashSizeInBits_nsprefix_ = None
        self.InputAlgorithm = InputAlgorithm
        self.InputAlgorithm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChecksumType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChecksumType.subclass:
            return ChecksumType.subclass(*args_, **kwargs_)
        else:
            return ChecksumType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_InputAlgorithm(self):
        return self.InputAlgorithm

    def set_InputAlgorithm(self, InputAlgorithm):
        self.InputAlgorithm = InputAlgorithm

    def get_bitsFromReference(self):
        return self.bitsFromReference

    def set_bitsFromReference(self, bitsFromReference):
        self.bitsFromReference = bitsFromReference

    def get_reference(self):
        return self.reference

    def set_reference(self, reference):
        self.reference = reference

    def get_name(self):
        return self.name

    def set_name(self, name):
        self.name = name

    def get_hashSizeInBits(self):
        return self.hashSizeInBits

    def set_hashSizeInBits(self, hashSizeInBits):
        self.hashSizeInBits = hashSizeInBits

    def validate_NonNegativeLongType(self, value):
        # Validate type xtce:NonNegativeLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on NonNegativeLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def validate_ReferencePointType(self, value):
        # Validate type xtce:ReferencePointType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'end']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ReferencePointType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_nameType(self, value):
        # Validate type nameType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['unix_sum', 'sum8', 'sum16', 'sum24', 'sum32', 'fletcher4', 'fletcher8', 'fletcher16',
                            'fletcher32', 'adler32', 'luhn', 'verhoeff', 'damm', 'custom']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on nameType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.InputAlgorithm is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ChecksumType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChecksumType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ChecksumType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChecksumType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChecksumType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChecksumType'):
        if self.bitsFromReference is not None and 'bitsFromReference' not in already_processed:
            already_processed.add('bitsFromReference')
            outfile.write(' bitsFromReference="%s"' % self.gds_format_integer(self.bitsFromReference,
                                                                              input_name='bitsFromReference'))
        if self.reference != "start" and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')),))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(
                ' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')),))
        if self.hashSizeInBits is not None and 'hashSizeInBits' not in already_processed:
            already_processed.add('hashSizeInBits')
            outfile.write(
                ' hashSizeInBits="%s"' % self.gds_format_integer(self.hashSizeInBits, input_name='hashSizeInBits'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ChecksumType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InputAlgorithm is not None:
            namespaceprefix_ = self.InputAlgorithm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.InputAlgorithm_nsprefix_) else ''
            self.InputAlgorithm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InputAlgorithm',
                                       pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bitsFromReference', node)
        if value is not None and 'bitsFromReference' not in already_processed:
            already_processed.add('bitsFromReference')
            self.bitsFromReference = self.gds_parse_integer(value, node, 'bitsFromReference')
            self.validate_NonNegativeLongType(self.bitsFromReference)  # validate type NonNegativeLongType
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
            self.validate_ReferencePointType(self.reference)  # validate type ReferencePointType
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_nameType(self.name)  # validate type nameType
        value = find_attr_value_('hashSizeInBits', node)
        if value is not None and 'hashSizeInBits' not in already_processed:
            already_processed.add('hashSizeInBits')
            self.hashSizeInBits = self.gds_parse_integer(value, node, 'hashSizeInBits')
            self.validate_PositiveLongType(self.hashSizeInBits)  # validate type PositiveLongType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'InputAlgorithm':
            class_obj_ = self.get_class_obj_(child_, InputAlgorithmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InputAlgorithm = obj_
            obj_.original_tagname_ = 'InputAlgorithm'


# end class ChecksumType


class ConstantType(GeneratedsSuper):
    """Names and provides a value for a constant input to the algorithm. There
    are two attributes to Constant, constantName and value. constantName is
    a variable name in the algorithm to be executed. value is the value of
    the constant to be used."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, constantName=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.constantName = _cast(None, constantName)
        self.constantName_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConstantType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConstantType.subclass:
            return ConstantType.subclass(*args_, **kwargs_)
        else:
            return ConstantType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_constantName(self):
        return self.constantName

    def set_constantName(self, constantName):
        self.constantName = constantName

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ConstantType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConstantType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConstantType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConstantType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConstantType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConstantType'):
        if self.constantName is not None and 'constantName' not in already_processed:
            already_processed.add('constantName')
            outfile.write(' constantName=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.constantName), input_name='constantName')),))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(
                ' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ConstantType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('constantName', node)
        if value is not None and 'constantName' not in already_processed:
            already_processed.add('constantName')
            self.constantName = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ConstantType


class ContextCalibratorListType(GeneratedsSuper):
    """Describe an ordered list of calibrators with a context match. Useful
    when different calibrations must be used depending on a matching value.
    The first context that matches determines which calibrator to use. See
    IntegerDataEncodingType and FloatDataEncodingType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ContextCalibrator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ContextCalibrator is None:
            self.ContextCalibrator = []
        else:
            self.ContextCalibrator = ContextCalibrator
        self.ContextCalibrator_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContextCalibratorListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContextCalibratorListType.subclass:
            return ContextCalibratorListType.subclass(*args_, **kwargs_)
        else:
            return ContextCalibratorListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextCalibrator(self):
        return self.ContextCalibrator

    def set_ContextCalibrator(self, ContextCalibrator):
        self.ContextCalibrator = ContextCalibrator

    def add_ContextCalibrator(self, value):
        self.ContextCalibrator.append(value)

    def insert_ContextCalibrator_at(self, index, value):
        self.ContextCalibrator.insert(index, value)

    def replace_ContextCalibrator_at(self, index, value):
        self.ContextCalibrator[index] = value

    def hasContent_(self):
        if (
                self.ContextCalibrator
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ContextCalibratorListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContextCalibratorListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContextCalibratorListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContextCalibratorListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContextCalibratorListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ContextCalibratorListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ContextCalibratorListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContextCalibrator_ in self.ContextCalibrator:
            namespaceprefix_ = self.ContextCalibrator_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextCalibrator_nsprefix_) else ''
            ContextCalibrator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextCalibrator',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextCalibrator':
            obj_ = ContextCalibratorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextCalibrator.append(obj_)
            obj_.original_tagname_ = 'ContextCalibrator'


# end class ContextCalibratorListType


class ExternalAlgorithmType(GeneratedsSuper):
    """This is the external algorithm. Multiple entries are provided so that
    the same database may be used for multiple implementation s"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, implementationName=None, algorithmLocation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.implementationName = _cast(None, implementationName)
        self.implementationName_nsprefix_ = None
        self.algorithmLocation = _cast(None, algorithmLocation)
        self.algorithmLocation_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalAlgorithmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalAlgorithmType.subclass:
            return ExternalAlgorithmType.subclass(*args_, **kwargs_)
        else:
            return ExternalAlgorithmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_implementationName(self):
        return self.implementationName

    def set_implementationName(self, implementationName):
        self.implementationName = implementationName

    def get_algorithmLocation(self):
        return self.algorithmLocation

    def set_algorithmLocation(self, algorithmLocation):
        self.algorithmLocation = algorithmLocation

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ExternalAlgorithmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExternalAlgorithmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ExternalAlgorithmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExternalAlgorithmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExternalAlgorithmType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExternalAlgorithmType'):
        if self.implementationName is not None and 'implementationName' not in already_processed:
            already_processed.add('implementationName')
            outfile.write(' implementationName=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.implementationName), input_name='implementationName')),))
        if self.algorithmLocation is not None and 'algorithmLocation' not in already_processed:
            already_processed.add('algorithmLocation')
            outfile.write(' algorithmLocation=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.algorithmLocation), input_name='algorithmLocation')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ExternalAlgorithmType', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('implementationName', node)
        if value is not None and 'implementationName' not in already_processed:
            already_processed.add('implementationName')
            self.implementationName = value
        value = find_attr_value_('algorithmLocation', node)
        if value is not None and 'algorithmLocation' not in already_processed:
            already_processed.add('algorithmLocation')
            self.algorithmLocation = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ExternalAlgorithmType


class ExternalAlgorithmSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ExternalAlgorithm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ExternalAlgorithm is None:
            self.ExternalAlgorithm = []
        else:
            self.ExternalAlgorithm = ExternalAlgorithm
        self.ExternalAlgorithm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalAlgorithmSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalAlgorithmSetType.subclass:
            return ExternalAlgorithmSetType.subclass(*args_, **kwargs_)
        else:
            return ExternalAlgorithmSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ExternalAlgorithm(self):
        return self.ExternalAlgorithm

    def set_ExternalAlgorithm(self, ExternalAlgorithm):
        self.ExternalAlgorithm = ExternalAlgorithm

    def add_ExternalAlgorithm(self, value):
        self.ExternalAlgorithm.append(value)

    def insert_ExternalAlgorithm_at(self, index, value):
        self.ExternalAlgorithm.insert(index, value)

    def replace_ExternalAlgorithm_at(self, index, value):
        self.ExternalAlgorithm[index] = value

    def hasContent_(self):
        if (
                self.ExternalAlgorithm
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ExternalAlgorithmSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExternalAlgorithmSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ExternalAlgorithmSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExternalAlgorithmSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExternalAlgorithmSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ExternalAlgorithmSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ExternalAlgorithmSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ExternalAlgorithm_ in self.ExternalAlgorithm:
            namespaceprefix_ = self.ExternalAlgorithm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ExternalAlgorithm_nsprefix_) else ''
            ExternalAlgorithm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ExternalAlgorithm',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ExternalAlgorithm':
            obj_ = ExternalAlgorithmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ExternalAlgorithm.append(obj_)
            obj_.original_tagname_ = 'ExternalAlgorithm'


# end class ExternalAlgorithmSetType


class InputSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, InputParameterInstanceRef=None, Constant=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if InputParameterInstanceRef is None:
            self.InputParameterInstanceRef = []
        else:
            self.InputParameterInstanceRef = InputParameterInstanceRef
        self.InputParameterInstanceRef_nsprefix_ = None
        if Constant is None:
            self.Constant = []
        else:
            self.Constant = Constant
        self.Constant_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InputSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InputSetType.subclass:
            return InputSetType.subclass(*args_, **kwargs_)
        else:
            return InputSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_InputParameterInstanceRef(self):
        return self.InputParameterInstanceRef

    def set_InputParameterInstanceRef(self, InputParameterInstanceRef):
        self.InputParameterInstanceRef = InputParameterInstanceRef

    def add_InputParameterInstanceRef(self, value):
        self.InputParameterInstanceRef.append(value)

    def insert_InputParameterInstanceRef_at(self, index, value):
        self.InputParameterInstanceRef.insert(index, value)

    def replace_InputParameterInstanceRef_at(self, index, value):
        self.InputParameterInstanceRef[index] = value

    def get_Constant(self):
        return self.Constant

    def set_Constant(self, Constant):
        self.Constant = Constant

    def add_Constant(self, value):
        self.Constant.append(value)

    def insert_Constant_at(self, index, value):
        self.Constant.insert(index, value)

    def replace_Constant_at(self, index, value):
        self.Constant[index] = value

    def hasContent_(self):
        if (
                self.InputParameterInstanceRef or
                self.Constant
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='InputSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InputSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InputSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InputSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InputSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InputSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='InputSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for InputParameterInstanceRef_ in self.InputParameterInstanceRef:
            namespaceprefix_ = self.InputParameterInstanceRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.InputParameterInstanceRef_nsprefix_) else ''
            InputParameterInstanceRef_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                              name_='InputParameterInstanceRef', pretty_print=pretty_print)
        for Constant_ in self.Constant:
            namespaceprefix_ = self.Constant_nsprefix_ + ':' if (UseCapturedNS_ and self.Constant_nsprefix_) else ''
            Constant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Constant',
                             pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'InputParameterInstanceRef':
            obj_ = InputParameterInstanceRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InputParameterInstanceRef.append(obj_)
            obj_.original_tagname_ = 'InputParameterInstanceRef'
        elif nodeName_ == 'Constant':
            obj_ = ConstantType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Constant.append(obj_)
            obj_.original_tagname_ = 'Constant'


# end class InputSetType


class OnContainerUpdateTriggerType(BaseTriggerType):
    """Describe a reference to container that triggers an event when the
    telemetry container referred to is updated (processed). See
    TriggerSetType.Reference to the Container whose update/receipt triggers
    this algorithm to evaluate."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseTriggerType

    def __init__(self, containerRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(OnContainerUpdateTriggerType, self).__init__(**kwargs_)
        self.containerRef = _cast(None, containerRef)
        self.containerRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OnContainerUpdateTriggerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnContainerUpdateTriggerType.subclass:
            return OnContainerUpdateTriggerType.subclass(*args_, **kwargs_)
        else:
            return OnContainerUpdateTriggerType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_containerRef(self):
        return self.containerRef

    def set_containerRef(self, containerRef):
        self.containerRef = containerRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                super(OnContainerUpdateTriggerType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='OnContainerUpdateTriggerType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OnContainerUpdateTriggerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OnContainerUpdateTriggerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OnContainerUpdateTriggerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='OnContainerUpdateTriggerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='OnContainerUpdateTriggerType'):
        super(OnContainerUpdateTriggerType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                   name_='OnContainerUpdateTriggerType')
        if self.containerRef is not None and 'containerRef' not in already_processed:
            already_processed.add('containerRef')
            outfile.write(' containerRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.containerRef), input_name='containerRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='OnContainerUpdateTriggerType', fromsubclass_=False, pretty_print=True):
        super(OnContainerUpdateTriggerType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                                 True, pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('containerRef', node)
        if value is not None and 'containerRef' not in already_processed:
            already_processed.add('containerRef')
            self.containerRef = value
            self.validate_NameReferenceType(self.containerRef)  # validate type NameReferenceType
        super(OnContainerUpdateTriggerType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(OnContainerUpdateTriggerType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class OnContainerUpdateTriggerType


class OnPeriodicRateTriggerType(BaseTriggerType):
    """Describe a periodic time basis to trigger an event. See
    TriggerSetType.The periodic rate in time in which this algorithm is
    triggered to evaluate."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseTriggerType

    def __init__(self, fireRateInSeconds=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(OnPeriodicRateTriggerType, self).__init__(**kwargs_)
        self.fireRateInSeconds = _cast(float, fireRateInSeconds)
        self.fireRateInSeconds_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OnPeriodicRateTriggerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnPeriodicRateTriggerType.subclass:
            return OnPeriodicRateTriggerType.subclass(*args_, **kwargs_)
        else:
            return OnPeriodicRateTriggerType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_fireRateInSeconds(self):
        return self.fireRateInSeconds

    def set_fireRateInSeconds(self, fireRateInSeconds):
        self.fireRateInSeconds = fireRateInSeconds

    def hasContent_(self):
        if (
                super(OnPeriodicRateTriggerType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='OnPeriodicRateTriggerType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OnPeriodicRateTriggerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OnPeriodicRateTriggerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OnPeriodicRateTriggerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OnPeriodicRateTriggerType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='OnPeriodicRateTriggerType'):
        super(OnPeriodicRateTriggerType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                name_='OnPeriodicRateTriggerType')
        if self.fireRateInSeconds is not None and 'fireRateInSeconds' not in already_processed:
            already_processed.add('fireRateInSeconds')
            outfile.write(' fireRateInSeconds="%s"' % self.gds_format_double(self.fireRateInSeconds,
                                                                             input_name='fireRateInSeconds'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='OnPeriodicRateTriggerType', fromsubclass_=False, pretty_print=True):
        super(OnPeriodicRateTriggerType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                              True, pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fireRateInSeconds', node)
        if value is not None and 'fireRateInSeconds' not in already_processed:
            already_processed.add('fireRateInSeconds')
            value = self.gds_parse_double(value, node, 'fireRateInSeconds')
            self.fireRateInSeconds = value
        super(OnPeriodicRateTriggerType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(OnPeriodicRateTriggerType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class OnPeriodicRateTriggerType


class OnParameterUpdateTriggerType(BaseTriggerType):
    """Describe a reference to parameter that triggers an event when the
    telemetry parameter referred to is updated (processed) with a new
    value. See TriggerSetType.Reference to the Parameter whose update
    triggers this algorithm to evaluate."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseTriggerType

    def __init__(self, parameterRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(OnParameterUpdateTriggerType, self).__init__(**kwargs_)
        self.parameterRef = _cast(None, parameterRef)
        self.parameterRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OnParameterUpdateTriggerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnParameterUpdateTriggerType.subclass:
            return OnParameterUpdateTriggerType.subclass(*args_, **kwargs_)
        else:
            return OnParameterUpdateTriggerType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_parameterRef(self):
        return self.parameterRef

    def set_parameterRef(self, parameterRef):
        self.parameterRef = parameterRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                super(OnParameterUpdateTriggerType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='OnParameterUpdateTriggerType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OnParameterUpdateTriggerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OnParameterUpdateTriggerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OnParameterUpdateTriggerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='OnParameterUpdateTriggerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='OnParameterUpdateTriggerType'):
        super(OnParameterUpdateTriggerType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                   name_='OnParameterUpdateTriggerType')
        if self.parameterRef is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            outfile.write(' parameterRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.parameterRef), input_name='parameterRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='OnParameterUpdateTriggerType', fromsubclass_=False, pretty_print=True):
        super(OnParameterUpdateTriggerType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                                 True, pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameterRef', node)
        if value is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            self.parameterRef = value
            self.validate_NameReferenceType(self.parameterRef)  # validate type NameReferenceType
        super(OnParameterUpdateTriggerType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(OnParameterUpdateTriggerType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class OnParameterUpdateTriggerType


class OutputParameterRefType(ParameterRefType):
    """Names an output parameter to the algorithm. There are two attributes to
    OutputParm, outputName and parameterName. parameterName is a parameter
    reference name for a parameter that will be updated by this algorithm.
    outputName is an optional "friendly" name for the output parameter."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ParameterRefType

    def __init__(self, parameterRef=None, outputName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(OutputParameterRefType, self).__init__(parameterRef, **kwargs_)
        self.outputName = _cast(None, outputName)
        self.outputName_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutputParameterRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutputParameterRefType.subclass:
            return OutputParameterRefType.subclass(*args_, **kwargs_)
        else:
            return OutputParameterRefType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_outputName(self):
        return self.outputName

    def set_outputName(self, outputName):
        self.outputName = outputName

    def hasContent_(self):
        if (
                super(OutputParameterRefType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='OutputParameterRefType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OutputParameterRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OutputParameterRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OutputParameterRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OutputParameterRefType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OutputParameterRefType'):
        super(OutputParameterRefType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                             name_='OutputParameterRefType')
        if self.outputName is not None and 'outputName' not in already_processed:
            already_processed.add('outputName')
            outfile.write(' outputName=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.outputName), input_name='outputName')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='OutputParameterRefType', fromsubclass_=False, pretty_print=True):
        super(OutputParameterRefType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                           pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('outputName', node)
        if value is not None and 'outputName' not in already_processed:
            already_processed.add('outputName')
            self.outputName = value
        super(OutputParameterRefType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(OutputParameterRefType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class OutputParameterRefType


class OutputSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, OutputParameterRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if OutputParameterRef is None:
            self.OutputParameterRef = []
        else:
            self.OutputParameterRef = OutputParameterRef
        self.OutputParameterRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutputSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutputSetType.subclass:
            return OutputSetType.subclass(*args_, **kwargs_)
        else:
            return OutputSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_OutputParameterRef(self):
        return self.OutputParameterRef

    def set_OutputParameterRef(self, OutputParameterRef):
        self.OutputParameterRef = OutputParameterRef

    def add_OutputParameterRef(self, value):
        self.OutputParameterRef.append(value)

    def insert_OutputParameterRef_at(self, index, value):
        self.OutputParameterRef.insert(index, value)

    def replace_OutputParameterRef_at(self, index, value):
        self.OutputParameterRef[index] = value

    def hasContent_(self):
        if (
                self.OutputParameterRef
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='OutputSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OutputSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OutputSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OutputSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OutputSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OutputSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='OutputSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OutputParameterRef_ in self.OutputParameterRef:
            namespaceprefix_ = self.OutputParameterRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.OutputParameterRef_nsprefix_) else ''
            OutputParameterRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OutputParameterRef',
                                       pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OutputParameterRef':
            obj_ = OutputParameterRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OutputParameterRef.append(obj_)
            obj_.original_tagname_ = 'OutputParameterRef'


# end class OutputSetType


class TriggerSetType(GeneratedsSuper):
    """A trigger is used to initiate the processing of some algorithm. A
    trigger may be based on an update of a Parameter, receipt of a
    Container, or on a time basis. Triggers may also have a maximum rate
    that limits how often the trigger can be invoked.Triggers may
    optionally be named.This attribute is a maximum rate that constrains
    how quickly this trigger may evaluate the algorithm to avoid flooding
    the implementation. The default is once per second. Setting to 0
    results in no maximum."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, name=None, triggerRate='1', OnParameterUpdateTrigger=None, OnContainerUpdateTrigger=None,
                 OnPeriodicRateTrigger=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.triggerRate = _cast(int, triggerRate)
        self.triggerRate_nsprefix_ = None
        if OnParameterUpdateTrigger is None:
            self.OnParameterUpdateTrigger = []
        else:
            self.OnParameterUpdateTrigger = OnParameterUpdateTrigger
        self.OnParameterUpdateTrigger_nsprefix_ = None
        if OnContainerUpdateTrigger is None:
            self.OnContainerUpdateTrigger = []
        else:
            self.OnContainerUpdateTrigger = OnContainerUpdateTrigger
        self.OnContainerUpdateTrigger_nsprefix_ = None
        if OnPeriodicRateTrigger is None:
            self.OnPeriodicRateTrigger = []
        else:
            self.OnPeriodicRateTrigger = OnPeriodicRateTrigger
        self.OnPeriodicRateTrigger_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TriggerSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TriggerSetType.subclass:
            return TriggerSetType.subclass(*args_, **kwargs_)
        else:
            return TriggerSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_OnParameterUpdateTrigger(self):
        return self.OnParameterUpdateTrigger

    def set_OnParameterUpdateTrigger(self, OnParameterUpdateTrigger):
        self.OnParameterUpdateTrigger = OnParameterUpdateTrigger

    def add_OnParameterUpdateTrigger(self, value):
        self.OnParameterUpdateTrigger.append(value)

    def insert_OnParameterUpdateTrigger_at(self, index, value):
        self.OnParameterUpdateTrigger.insert(index, value)

    def replace_OnParameterUpdateTrigger_at(self, index, value):
        self.OnParameterUpdateTrigger[index] = value

    def get_OnContainerUpdateTrigger(self):
        return self.OnContainerUpdateTrigger

    def set_OnContainerUpdateTrigger(self, OnContainerUpdateTrigger):
        self.OnContainerUpdateTrigger = OnContainerUpdateTrigger

    def add_OnContainerUpdateTrigger(self, value):
        self.OnContainerUpdateTrigger.append(value)

    def insert_OnContainerUpdateTrigger_at(self, index, value):
        self.OnContainerUpdateTrigger.insert(index, value)

    def replace_OnContainerUpdateTrigger_at(self, index, value):
        self.OnContainerUpdateTrigger[index] = value

    def get_OnPeriodicRateTrigger(self):
        return self.OnPeriodicRateTrigger

    def set_OnPeriodicRateTrigger(self, OnPeriodicRateTrigger):
        self.OnPeriodicRateTrigger = OnPeriodicRateTrigger

    def add_OnPeriodicRateTrigger(self, value):
        self.OnPeriodicRateTrigger.append(value)

    def insert_OnPeriodicRateTrigger_at(self, index, value):
        self.OnPeriodicRateTrigger.insert(index, value)

    def replace_OnPeriodicRateTrigger_at(self, index, value):
        self.OnPeriodicRateTrigger[index] = value

    def get_name(self):
        return self.name

    def set_name(self, name):
        self.name = name

    def get_triggerRate(self):
        return self.triggerRate

    def set_triggerRate(self, triggerRate):
        self.triggerRate = triggerRate

    def validate_NonNegativeLongType(self, value):
        # Validate type xtce:NonNegativeLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on NonNegativeLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.OnParameterUpdateTrigger or
                self.OnContainerUpdateTrigger or
                self.OnPeriodicRateTrigger
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='TriggerSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TriggerSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TriggerSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TriggerSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TriggerSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TriggerSetType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(
                ' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')),))
        if self.triggerRate != 1 and 'triggerRate' not in already_processed:
            already_processed.add('triggerRate')
            outfile.write(' triggerRate="%s"' % self.gds_format_integer(self.triggerRate, input_name='triggerRate'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='TriggerSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OnParameterUpdateTrigger_ in self.OnParameterUpdateTrigger:
            namespaceprefix_ = self.OnParameterUpdateTrigger_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.OnParameterUpdateTrigger_nsprefix_) else ''
            OnParameterUpdateTrigger_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='OnParameterUpdateTrigger', pretty_print=pretty_print)
        for OnContainerUpdateTrigger_ in self.OnContainerUpdateTrigger:
            namespaceprefix_ = self.OnContainerUpdateTrigger_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.OnContainerUpdateTrigger_nsprefix_) else ''
            OnContainerUpdateTrigger_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='OnContainerUpdateTrigger', pretty_print=pretty_print)
        for OnPeriodicRateTrigger_ in self.OnPeriodicRateTrigger:
            namespaceprefix_ = self.OnPeriodicRateTrigger_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.OnPeriodicRateTrigger_nsprefix_) else ''
            OnPeriodicRateTrigger_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                          name_='OnPeriodicRateTrigger', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('triggerRate', node)
        if value is not None and 'triggerRate' not in already_processed:
            already_processed.add('triggerRate')
            self.triggerRate = self.gds_parse_integer(value, node, 'triggerRate')
            self.validate_NonNegativeLongType(self.triggerRate)  # validate type NonNegativeLongType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OnParameterUpdateTrigger':
            obj_ = OnParameterUpdateTriggerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OnParameterUpdateTrigger.append(obj_)
            obj_.original_tagname_ = 'OnParameterUpdateTrigger'
        elif nodeName_ == 'OnContainerUpdateTrigger':
            obj_ = OnContainerUpdateTriggerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OnContainerUpdateTrigger.append(obj_)
            obj_.original_tagname_ = 'OnContainerUpdateTrigger'
        elif nodeName_ == 'OnPeriodicRateTrigger':
            obj_ = OnPeriodicRateTriggerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OnPeriodicRateTrigger.append(obj_)
            obj_.original_tagname_ = 'OnPeriodicRateTrigger'


# end class TriggerSetType


class BaseCalibratorType(GeneratedsSuper):
    """Supplies an optional non-reference-able name and short description for
    calibrators. Also includes an optional ancillary data for any special
    local flags, note that these may not necessarily transfer to another
    recipient of an instance document.Optional name for this
    calibrator/algorithmOptional description for this
    calibrator/algorithm"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.shortDescription = _cast(None, shortDescription)
        self.shortDescription_nsprefix_ = None
        self.AncillaryDataSet = AncillaryDataSet
        self.AncillaryDataSet_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseCalibratorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseCalibratorType.subclass:
            return BaseCalibratorType.subclass(*args_, **kwargs_)
        else:
            return BaseCalibratorType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AncillaryDataSet(self):
        return self.AncillaryDataSet

    def set_AncillaryDataSet(self, AncillaryDataSet):
        self.AncillaryDataSet = AncillaryDataSet

    def get_name(self):
        return self.name

    def set_name(self, name):
        self.name = name

    def get_shortDescription(self):
        return self.shortDescription

    def set_shortDescription(self, shortDescription):
        self.shortDescription = shortDescription

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_ShortDescriptionType(self, value):
        # Validate type xtce:ShortDescriptionType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            pass

    def hasContent_(self):
        if (
                self.AncillaryDataSet is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BaseCalibratorType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseCalibratorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BaseCalibratorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseCalibratorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseCalibratorType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseCalibratorType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(
                ' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')),))
        if self.shortDescription is not None and 'shortDescription' not in already_processed:
            already_processed.add('shortDescription')
            outfile.write(' shortDescription=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.shortDescription), input_name='shortDescription')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BaseCalibratorType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AncillaryDataSet is not None:
            namespaceprefix_ = self.AncillaryDataSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AncillaryDataSet_nsprefix_) else ''
            self.AncillaryDataSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AncillaryDataSet',
                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('shortDescription', node)
        if value is not None and 'shortDescription' not in already_processed:
            already_processed.add('shortDescription')
            self.shortDescription = value
            self.validate_ShortDescriptionType(self.shortDescription)  # validate type ShortDescriptionType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AncillaryDataSet':
            obj_ = AncillaryDataSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AncillaryDataSet = obj_
            obj_.original_tagname_ = 'AncillaryDataSet'


# end class BaseCalibratorType


class CalibratorType(BaseCalibratorType):
    """Describe a calibrator to transform a source data type raw/uncalibrated
    value (e.g. an integer count from a spacecraft) to an engineering
    unit/calibrated value for users (e.g. a float)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseCalibratorType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, SplineCalibrator=None,
                 PolynomialCalibrator=None, MathOperationCalibrator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CalibratorType, self).__init__(name, shortDescription, AncillaryDataSet, **kwargs_)
        self.SplineCalibrator = SplineCalibrator
        self.SplineCalibrator_nsprefix_ = None
        self.PolynomialCalibrator = PolynomialCalibrator
        self.PolynomialCalibrator_nsprefix_ = None
        self.MathOperationCalibrator = MathOperationCalibrator
        self.MathOperationCalibrator_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalibratorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalibratorType.subclass:
            return CalibratorType.subclass(*args_, **kwargs_)
        else:
            return CalibratorType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SplineCalibrator(self):
        return self.SplineCalibrator

    def set_SplineCalibrator(self, SplineCalibrator):
        self.SplineCalibrator = SplineCalibrator

    def get_PolynomialCalibrator(self):
        return self.PolynomialCalibrator

    def set_PolynomialCalibrator(self, PolynomialCalibrator):
        self.PolynomialCalibrator = PolynomialCalibrator

    def get_MathOperationCalibrator(self):
        return self.MathOperationCalibrator

    def set_MathOperationCalibrator(self, MathOperationCalibrator):
        self.MathOperationCalibrator = MathOperationCalibrator

    def hasContent_(self):
        if (
                self.SplineCalibrator is not None or
                self.PolynomialCalibrator is not None or
                self.MathOperationCalibrator is not None or
                super(CalibratorType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='CalibratorType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CalibratorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CalibratorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CalibratorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CalibratorType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CalibratorType'):
        super(CalibratorType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                     name_='CalibratorType')

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='CalibratorType',
                       fromsubclass_=False, pretty_print=True):
        super(CalibratorType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                   pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SplineCalibrator is not None:
            namespaceprefix_ = self.SplineCalibrator_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SplineCalibrator_nsprefix_) else ''
            self.SplineCalibrator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SplineCalibrator',
                                         pretty_print=pretty_print)
        if self.PolynomialCalibrator is not None:
            namespaceprefix_ = self.PolynomialCalibrator_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.PolynomialCalibrator_nsprefix_) else ''
            self.PolynomialCalibrator.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='PolynomialCalibrator', pretty_print=pretty_print)
        if self.MathOperationCalibrator is not None:
            namespaceprefix_ = self.MathOperationCalibrator_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MathOperationCalibrator_nsprefix_) else ''
            self.MathOperationCalibrator.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                name_='MathOperationCalibrator', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(CalibratorType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SplineCalibrator':
            obj_ = SplineCalibratorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SplineCalibrator = obj_
            obj_.original_tagname_ = 'SplineCalibrator'
        elif nodeName_ == 'PolynomialCalibrator':
            obj_ = PolynomialCalibratorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PolynomialCalibrator = obj_
            obj_.original_tagname_ = 'PolynomialCalibrator'
        elif nodeName_ == 'MathOperationCalibrator':
            class_obj_ = self.get_class_obj_(child_, MathOperationCalibratorType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MathOperationCalibrator = obj_
            obj_.original_tagname_ = 'MathOperationCalibrator'
        super(CalibratorType, self).buildChildren(child_, node, nodeName_, True)


# end class CalibratorType


class ChangeValueType(GeneratedsSuper):
    """Describe a change value used to test verification status. See
    CommandVerifierType.Value as a floating point number."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = _cast(float, value)
        self.value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChangeValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChangeValueType.subclass:
            return ChangeValueType.subclass(*args_, **kwargs_)
        else:
            return ChangeValueType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ChangeValueType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChangeValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ChangeValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChangeValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChangeValueType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChangeValueType'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ChangeValueType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            value = self.gds_parse_double(value, node, 'value')
            self.value = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ChangeValueType


class MathOperationCalibratorType(BaseCalibratorType):
    """Describe a mathematical function for calibration where the mathematical
    function is defined using the MathOperationType.Describe a postfix (aka
    Reverse Polish Notation (RPN)) expression for mathematical equations.
    It uses a stack where operands (either fixed values or
    ParameterInstances) are pushed onto the stack from first to last in the
    XML. As the operators are specified, each pops off operands as it
    evaluates them, and pushes the result back onto the stack. For example,
    the stack, 4 8 /, would result as 0.5. In this case postfix is used to
    avoid having to specify parenthesis. To convert from infix to postfix,
    use Dijkstra's "shunting yard" algorithm."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseCalibratorType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, ValueOperand=None,
                 ThisParameterOperand=None, Operator=None, ParameterInstanceRefOperand=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MathOperationCalibratorType, self).__init__(name, shortDescription, AncillaryDataSet, extensiontype_,
                                                          **kwargs_)
        if ValueOperand is None:
            self.ValueOperand = []
        else:
            self.ValueOperand = ValueOperand
        self.ValueOperand_nsprefix_ = None
        if ThisParameterOperand is None:
            self.ThisParameterOperand = []
        else:
            self.ThisParameterOperand = ThisParameterOperand
        self.ThisParameterOperand_nsprefix_ = None
        if Operator is None:
            self.Operator = []
        else:
            self.Operator = Operator
        self.Operator_nsprefix_ = None
        if ParameterInstanceRefOperand is None:
            self.ParameterInstanceRefOperand = []
        else:
            self.ParameterInstanceRefOperand = ParameterInstanceRefOperand
        self.ParameterInstanceRefOperand_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MathOperationCalibratorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MathOperationCalibratorType.subclass:
            return MathOperationCalibratorType.subclass(*args_, **kwargs_)
        else:
            return MathOperationCalibratorType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ValueOperand(self):
        return self.ValueOperand

    def set_ValueOperand(self, ValueOperand):
        self.ValueOperand = ValueOperand

    def add_ValueOperand(self, value):
        self.ValueOperand.append(value)

    def insert_ValueOperand_at(self, index, value):
        self.ValueOperand.insert(index, value)

    def replace_ValueOperand_at(self, index, value):
        self.ValueOperand[index] = value

    def get_ThisParameterOperand(self):
        return self.ThisParameterOperand

    def set_ThisParameterOperand(self, ThisParameterOperand):
        self.ThisParameterOperand = ThisParameterOperand

    def add_ThisParameterOperand(self, value):
        self.ThisParameterOperand.append(value)

    def insert_ThisParameterOperand_at(self, index, value):
        self.ThisParameterOperand.insert(index, value)

    def replace_ThisParameterOperand_at(self, index, value):
        self.ThisParameterOperand[index] = value

    def get_Operator(self):
        return self.Operator

    def set_Operator(self, Operator):
        self.Operator = Operator

    def add_Operator(self, value):
        self.Operator.append(value)

    def insert_Operator_at(self, index, value):
        self.Operator.insert(index, value)

    def replace_Operator_at(self, index, value):
        self.Operator[index] = value

    def get_ParameterInstanceRefOperand(self):
        return self.ParameterInstanceRefOperand

    def set_ParameterInstanceRefOperand(self, ParameterInstanceRefOperand):
        self.ParameterInstanceRefOperand = ParameterInstanceRefOperand

    def add_ParameterInstanceRefOperand(self, value):
        self.ParameterInstanceRefOperand.append(value)

    def insert_ParameterInstanceRefOperand_at(self, index, value):
        self.ParameterInstanceRefOperand.insert(index, value)

    def replace_ParameterInstanceRefOperand_at(self, index, value):
        self.ParameterInstanceRefOperand[index] = value

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_MathOperatorsType(self, value):
        result = True
        # Validate type MathOperatorsType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-', '*', '/', '%', '^', 'y^x', 'ln', 'log', 'e^x', '1/x', 'x!', 'tan', 'cos', 'sin',
                            'atan', 'atan2', 'acos', 'asin', 'tanh', 'cosh', 'sinh', 'atanh', 'acosh', 'asinh', 'swap',
                            'drop', 'dup', 'over', '<<', '>>', '&', '|', '&&', '||', '!', 'abs', 'div', 'int', '>',
                            '>=', '<', '<=', '==', '!=', 'min', 'max', 'xor', '~']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MathOperatorsType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def hasContent_(self):
        if (
                self.ValueOperand or
                self.ThisParameterOperand or
                self.Operator or
                self.ParameterInstanceRefOperand or
                super(MathOperationCalibratorType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
               name_='MathOperationCalibratorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MathOperationCalibratorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MathOperationCalibratorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MathOperationCalibratorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='MathOperationCalibratorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='MathOperationCalibratorType'):
        super(MathOperationCalibratorType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                  name_='MathOperationCalibratorType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
                       name_='MathOperationCalibratorType', fromsubclass_=False, pretty_print=True):
        super(MathOperationCalibratorType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                                True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ValueOperand_ in self.ValueOperand:
            namespaceprefix_ = self.ValueOperand_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ValueOperand_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValueOperand>%s</%sValueOperand>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(ValueOperand_), input_name='ValueOperand')), namespaceprefix_, eol_))
        for ThisParameterOperand_ in self.ThisParameterOperand:
            namespaceprefix_ = self.ThisParameterOperand_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ThisParameterOperand_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThisParameterOperand>%s</%sThisParameterOperand>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(ThisParameterOperand_), input_name='ThisParameterOperand')),
                                                                                     namespaceprefix_, eol_))
        for Operator_ in self.Operator:
            namespaceprefix_ = self.Operator_nsprefix_ + ':' if (UseCapturedNS_ and self.Operator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOperator>%s</%sOperator>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(Operator_), input_name='Operator')),
            namespaceprefix_, eol_))
        for ParameterInstanceRefOperand_ in self.ParameterInstanceRefOperand:
            namespaceprefix_ = self.ParameterInstanceRefOperand_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterInstanceRefOperand_nsprefix_) else ''
            ParameterInstanceRefOperand_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                name_='ParameterInstanceRefOperand', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(MathOperationCalibratorType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ValueOperand':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ValueOperand')
            value_ = self.gds_validate_string(value_, node, 'ValueOperand')
            self.ValueOperand.append(value_)
            self.ValueOperand_nsprefix_ = child_.prefix
        elif nodeName_ == 'ThisParameterOperand':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ThisParameterOperand')
            value_ = self.gds_validate_string(value_, node, 'ThisParameterOperand')
            self.ThisParameterOperand.append(value_)
            self.ThisParameterOperand_nsprefix_ = child_.prefix
        elif nodeName_ == 'Operator':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Operator')
            value_ = self.gds_validate_string(value_, node, 'Operator')
            self.Operator.append(value_)
            self.Operator_nsprefix_ = child_.prefix
            # validate type MathOperatorsType
            self.validate_MathOperatorsType(self.Operator[-1])
        elif nodeName_ == 'ParameterInstanceRefOperand':
            class_obj_ = self.get_class_obj_(child_, ParameterInstanceRefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterInstanceRefOperand.append(obj_)
            obj_.original_tagname_ = 'ParameterInstanceRefOperand'
        super(MathOperationCalibratorType, self).buildChildren(child_, node, nodeName_, True)


# end class MathOperationCalibratorType


class PolynomialCalibratorType(BaseCalibratorType):
    """Describe a polynomial equation for calibration. This is a calibration
    type where a curve in a raw vs calibrated plane is described using a
    set of polynomial coefficients. Raw values are converted to calibrated
    values by finding a position on the curve corresponding to the raw
    value. The first coefficient belongs with the X^0 term, the next
    coefficient belongs to the X^1 term and so on. See CalibratorType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseCalibratorType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, Term=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PolynomialCalibratorType, self).__init__(name, shortDescription, AncillaryDataSet, **kwargs_)
        if Term is None:
            self.Term = []
        else:
            self.Term = Term
        self.Term_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PolynomialCalibratorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PolynomialCalibratorType.subclass:
            return PolynomialCalibratorType.subclass(*args_, **kwargs_)
        else:
            return PolynomialCalibratorType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Term(self):
        return self.Term

    def set_Term(self, Term):
        self.Term = Term

    def add_Term(self, value):
        self.Term.append(value)

    def insert_Term_at(self, index, value):
        self.Term.insert(index, value)

    def replace_Term_at(self, index, value):
        self.Term[index] = value

    def hasContent_(self):
        if (
                self.Term or
                super(PolynomialCalibratorType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='PolynomialCalibratorType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PolynomialCalibratorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PolynomialCalibratorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PolynomialCalibratorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PolynomialCalibratorType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='PolynomialCalibratorType'):
        super(PolynomialCalibratorType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                               name_='PolynomialCalibratorType')

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='PolynomialCalibratorType', fromsubclass_=False, pretty_print=True):
        super(PolynomialCalibratorType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                             True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Term_ in self.Term:
            namespaceprefix_ = self.Term_nsprefix_ + ':' if (UseCapturedNS_ and self.Term_nsprefix_) else ''
            Term_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Term', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(PolynomialCalibratorType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Term':
            obj_ = TermType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Term.append(obj_)
            obj_.original_tagname_ = 'Term'
        super(PolynomialCalibratorType, self).buildChildren(child_, node, nodeName_, True)


# end class PolynomialCalibratorType


class SplineCalibratorType(BaseCalibratorType):
    """Describe a spline function for calibration using a set of at least 2
    points. Raw values are converted to calibrated values by finding a
    position on the line corresponding to the raw value. The line may be
    interpolated and/or extrapolated as needed. The interpolation order may
    be specified for all the points and overridden on individual points.
    The algorithm triggers on the input parameter. See CalibratorType.The
    interpolation order to apply to the overall spline function. Order 0 is
    no slope between the points (flat). Order 1 is linear interpolation.
    Order 2 would be quadratic and in this special case, 3 points would be
    required, etc.Extrapolation allows the closest outside point and the
    associated interpolation to extend outside of the range of the points
    in the spline function."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseCalibratorType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, order='1', extrapolate=False,
                 SplinePoint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SplineCalibratorType, self).__init__(name, shortDescription, AncillaryDataSet, **kwargs_)
        self.order = _cast(int, order)
        self.order_nsprefix_ = None
        self.extrapolate = _cast(bool, extrapolate)
        self.extrapolate_nsprefix_ = None
        if SplinePoint is None:
            self.SplinePoint = []
        else:
            self.SplinePoint = SplinePoint
        self.SplinePoint_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SplineCalibratorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SplineCalibratorType.subclass:
            return SplineCalibratorType.subclass(*args_, **kwargs_)
        else:
            return SplineCalibratorType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SplinePoint(self):
        return self.SplinePoint

    def set_SplinePoint(self, SplinePoint):
        self.SplinePoint = SplinePoint

    def add_SplinePoint(self, value):
        self.SplinePoint.append(value)

    def insert_SplinePoint_at(self, index, value):
        self.SplinePoint.insert(index, value)

    def replace_SplinePoint_at(self, index, value):
        self.SplinePoint[index] = value

    def get_order(self):
        return self.order

    def set_order(self, order):
        self.order = order

    def get_extrapolate(self):
        return self.extrapolate

    def set_extrapolate(self, extrapolate):
        self.extrapolate = extrapolate

    def validate_NonNegativeLongType(self, value):
        # Validate type xtce:NonNegativeLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on NonNegativeLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.SplinePoint or
                super(SplineCalibratorType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='SplineCalibratorType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SplineCalibratorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SplineCalibratorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SplineCalibratorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SplineCalibratorType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SplineCalibratorType'):
        super(SplineCalibratorType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='SplineCalibratorType')
        if self.order != 1 and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order="%s"' % self.gds_format_integer(self.order, input_name='order'))
        if self.extrapolate and 'extrapolate' not in already_processed:
            already_processed.add('extrapolate')
            outfile.write(' extrapolate="%s"' % self.gds_format_boolean(self.extrapolate, input_name='extrapolate'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='SplineCalibratorType',
                       fromsubclass_=False, pretty_print=True):
        super(SplineCalibratorType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SplinePoint_ in self.SplinePoint:
            namespaceprefix_ = self.SplinePoint_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SplinePoint_nsprefix_) else ''
            SplinePoint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SplinePoint',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            self.order = self.gds_parse_integer(value, node, 'order')
            self.validate_NonNegativeLongType(self.order)  # validate type NonNegativeLongType
        value = find_attr_value_('extrapolate', node)
        if value is not None and 'extrapolate' not in already_processed:
            already_processed.add('extrapolate')
            if value in ('true', '1'):
                self.extrapolate = True
            elif value in ('false', '0'):
                self.extrapolate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(SplineCalibratorType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SplinePoint':
            obj_ = SplinePointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SplinePoint.append(obj_)
            obj_.original_tagname_ = 'SplinePoint'
        super(SplineCalibratorType, self).buildChildren(child_, node, nodeName_, True)


# end class SplineCalibratorType


class AutoInvertType(GeneratedsSuper):
    """After searching for the frame sync marker for some number of bits, it
    may be desirable to invert the incoming data, and then look for frame
    sync. In some cases this will require an external algorithm"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, badFramesToAutoInvert='1024', InvertAlgorithm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.badFramesToAutoInvert = _cast(int, badFramesToAutoInvert)
        self.badFramesToAutoInvert_nsprefix_ = None
        self.InvertAlgorithm = InvertAlgorithm
        self.InvertAlgorithm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AutoInvertType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AutoInvertType.subclass:
            return AutoInvertType.subclass(*args_, **kwargs_)
        else:
            return AutoInvertType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_InvertAlgorithm(self):
        return self.InvertAlgorithm

    def set_InvertAlgorithm(self, InvertAlgorithm):
        self.InvertAlgorithm = InvertAlgorithm

    def get_badFramesToAutoInvert(self):
        return self.badFramesToAutoInvert

    def set_badFramesToAutoInvert(self, badFramesToAutoInvert):
        self.badFramesToAutoInvert = badFramesToAutoInvert

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.InvertAlgorithm is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AutoInvertType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AutoInvertType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AutoInvertType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AutoInvertType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AutoInvertType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AutoInvertType'):
        if self.badFramesToAutoInvert != 1024 and 'badFramesToAutoInvert' not in already_processed:
            already_processed.add('badFramesToAutoInvert')
            outfile.write(' badFramesToAutoInvert="%s"' % self.gds_format_integer(self.badFramesToAutoInvert,
                                                                                  input_name='badFramesToAutoInvert'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AutoInvertType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InvertAlgorithm is not None:
            namespaceprefix_ = self.InvertAlgorithm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.InvertAlgorithm_nsprefix_) else ''
            self.InvertAlgorithm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InvertAlgorithm',
                                        pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('badFramesToAutoInvert', node)
        if value is not None and 'badFramesToAutoInvert' not in already_processed:
            already_processed.add('badFramesToAutoInvert')
            self.badFramesToAutoInvert = self.gds_parse_integer(value, node, 'badFramesToAutoInvert')
            self.validate_PositiveLongType(self.badFramesToAutoInvert)  # validate type PositiveLongType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'InvertAlgorithm':
            class_obj_ = self.get_class_obj_(child_, InputAlgorithmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InvertAlgorithm = obj_
            obj_.original_tagname_ = 'InvertAlgorithm'


# end class AutoInvertType


class FlagType(GeneratedsSuper):
    """The pattern of bits used to look for frame synchronization."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, flagSizeInBits='6', flagBitType='ones', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.flagSizeInBits = _cast(int, flagSizeInBits)
        self.flagSizeInBits_nsprefix_ = None
        self.flagBitType = _cast(None, flagBitType)
        self.flagBitType_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlagType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlagType.subclass:
            return FlagType.subclass(*args_, **kwargs_)
        else:
            return FlagType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_flagSizeInBits(self):
        return self.flagSizeInBits

    def set_flagSizeInBits(self, flagSizeInBits):
        self.flagSizeInBits = flagSizeInBits

    def get_flagBitType(self):
        return self.flagBitType

    def set_flagBitType(self, flagBitType):
        self.flagBitType = flagBitType

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def validate_FlagBitType(self, value):
        # Validate type xtce:FlagBitType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['zeros', 'ones']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FlagBitType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='FlagType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlagType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FlagType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlagType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlagType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FlagType'):
        if self.flagSizeInBits != 6 and 'flagSizeInBits' not in already_processed:
            already_processed.add('flagSizeInBits')
            outfile.write(
                ' flagSizeInBits="%s"' % self.gds_format_integer(self.flagSizeInBits, input_name='flagSizeInBits'))
        if self.flagBitType != "ones" and 'flagBitType' not in already_processed:
            already_processed.add('flagBitType')
            outfile.write(' flagBitType=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.flagBitType), input_name='flagBitType')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='FlagType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('flagSizeInBits', node)
        if value is not None and 'flagSizeInBits' not in already_processed:
            already_processed.add('flagSizeInBits')
            self.flagSizeInBits = self.gds_parse_integer(value, node, 'flagSizeInBits')
            self.validate_PositiveLongType(self.flagSizeInBits)  # validate type PositiveLongType
        value = find_attr_value_('flagBitType', node)
        if value is not None and 'flagBitType' not in already_processed:
            already_processed.add('flagBitType')
            self.flagBitType = value
            self.validate_FlagBitType(self.flagBitType)  # validate type FlagBitType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class FlagType


class StreamRefType(GeneratedsSuper):
    """Holds a reference to a streamname of reference stream"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, streamRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.streamRef = _cast(None, streamRef)
        self.streamRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreamRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreamRefType.subclass:
            return StreamRefType.subclass(*args_, **kwargs_)
        else:
            return StreamRefType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_streamRef(self):
        return self.streamRef

    def set_streamRef(self, streamRef):
        self.streamRef = streamRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='StreamRefType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StreamRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StreamRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StreamRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StreamRefType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StreamRefType'):
        if self.streamRef is not None and 'streamRef' not in already_processed:
            already_processed.add('streamRef')
            outfile.write(' streamRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.streamRef), input_name='streamRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='StreamRefType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('streamRef', node)
        if value is not None and 'streamRef' not in already_processed:
            already_processed.add('streamRef')
            self.streamRef = value
            self.validate_NameReferenceType(self.streamRef)  # validate type NameReferenceType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class StreamRefType


class StreamSetType(GeneratedsSuper):
    """Contains an unordered set of Streams."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, FixedFrameStream=None, VariableFrameStream=None, CustomStream=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if FixedFrameStream is None:
            self.FixedFrameStream = []
        else:
            self.FixedFrameStream = FixedFrameStream
        self.FixedFrameStream_nsprefix_ = None
        if VariableFrameStream is None:
            self.VariableFrameStream = []
        else:
            self.VariableFrameStream = VariableFrameStream
        self.VariableFrameStream_nsprefix_ = None
        if CustomStream is None:
            self.CustomStream = []
        else:
            self.CustomStream = CustomStream
        self.CustomStream_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreamSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreamSetType.subclass:
            return StreamSetType.subclass(*args_, **kwargs_)
        else:
            return StreamSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_FixedFrameStream(self):
        return self.FixedFrameStream

    def set_FixedFrameStream(self, FixedFrameStream):
        self.FixedFrameStream = FixedFrameStream

    def add_FixedFrameStream(self, value):
        self.FixedFrameStream.append(value)

    def insert_FixedFrameStream_at(self, index, value):
        self.FixedFrameStream.insert(index, value)

    def replace_FixedFrameStream_at(self, index, value):
        self.FixedFrameStream[index] = value

    def get_VariableFrameStream(self):
        return self.VariableFrameStream

    def set_VariableFrameStream(self, VariableFrameStream):
        self.VariableFrameStream = VariableFrameStream

    def add_VariableFrameStream(self, value):
        self.VariableFrameStream.append(value)

    def insert_VariableFrameStream_at(self, index, value):
        self.VariableFrameStream.insert(index, value)

    def replace_VariableFrameStream_at(self, index, value):
        self.VariableFrameStream[index] = value

    def get_CustomStream(self):
        return self.CustomStream

    def set_CustomStream(self, CustomStream):
        self.CustomStream = CustomStream

    def add_CustomStream(self, value):
        self.CustomStream.append(value)

    def insert_CustomStream_at(self, index, value):
        self.CustomStream.insert(index, value)

    def replace_CustomStream_at(self, index, value):
        self.CustomStream[index] = value

    def hasContent_(self):
        if (
                self.FixedFrameStream or
                self.VariableFrameStream or
                self.CustomStream
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='StreamSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StreamSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StreamSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StreamSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StreamSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StreamSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='StreamSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FixedFrameStream_ in self.FixedFrameStream:
            namespaceprefix_ = self.FixedFrameStream_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.FixedFrameStream_nsprefix_) else ''
            FixedFrameStream_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FixedFrameStream',
                                     pretty_print=pretty_print)
        for VariableFrameStream_ in self.VariableFrameStream:
            namespaceprefix_ = self.VariableFrameStream_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.VariableFrameStream_nsprefix_) else ''
            VariableFrameStream_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VariableFrameStream',
                                        pretty_print=pretty_print)
        for CustomStream_ in self.CustomStream:
            namespaceprefix_ = self.CustomStream_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CustomStream_nsprefix_) else ''
            CustomStream_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CustomStream',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FixedFrameStream':
            obj_ = FixedFrameStreamType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FixedFrameStream.append(obj_)
            obj_.original_tagname_ = 'FixedFrameStream'
        elif nodeName_ == 'VariableFrameStream':
            obj_ = VariableFrameStreamType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VariableFrameStream.append(obj_)
            obj_.original_tagname_ = 'VariableFrameStream'
        elif nodeName_ == 'CustomStream':
            obj_ = CustomStreamType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CustomStream.append(obj_)
            obj_.original_tagname_ = 'CustomStream'


# end class StreamSetType


class SyncStrategyType(GeneratedsSuper):
    """A Sync Strategy specifies the strategy on how to find frames within a
    stream of PCM data. The sync strategy is based upon a state machine
    that begins in the 'Search' state until the first sync marker is found.
    Then it goes into the 'Verify' state until a specified number of
    successive good sync markers are found. Then, the state machine goes
    into the 'Lock' state, in the 'Lock' state frames are considered good.
    Should a sync marker be missed in the 'Lock' state, the state machine
    will transition into the 'Check' state, if the next sync marker is
    where it's expected within a specified number of frames, then the state
    machine will transition back to the 'Lock' state, it not it will
    transition back to 'Search'. Maximum number of bit errors in the sync
    pattern (marker)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, verifyToLockGoodFrames='4', checkToLockGoodFrames='1', maxBitErrorsInSyncPattern='0',
                 AutoInvert=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.verifyToLockGoodFrames = _cast(int, verifyToLockGoodFrames)
        self.verifyToLockGoodFrames_nsprefix_ = None
        self.checkToLockGoodFrames = _cast(int, checkToLockGoodFrames)
        self.checkToLockGoodFrames_nsprefix_ = None
        self.maxBitErrorsInSyncPattern = _cast(int, maxBitErrorsInSyncPattern)
        self.maxBitErrorsInSyncPattern_nsprefix_ = None
        self.AutoInvert = AutoInvert
        self.AutoInvert_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SyncStrategyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SyncStrategyType.subclass:
            return SyncStrategyType.subclass(*args_, **kwargs_)
        else:
            return SyncStrategyType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AutoInvert(self):
        return self.AutoInvert

    def set_AutoInvert(self, AutoInvert):
        self.AutoInvert = AutoInvert

    def get_verifyToLockGoodFrames(self):
        return self.verifyToLockGoodFrames

    def set_verifyToLockGoodFrames(self, verifyToLockGoodFrames):
        self.verifyToLockGoodFrames = verifyToLockGoodFrames

    def get_checkToLockGoodFrames(self):
        return self.checkToLockGoodFrames

    def set_checkToLockGoodFrames(self, checkToLockGoodFrames):
        self.checkToLockGoodFrames = checkToLockGoodFrames

    def get_maxBitErrorsInSyncPattern(self):
        return self.maxBitErrorsInSyncPattern

    def set_maxBitErrorsInSyncPattern(self, maxBitErrorsInSyncPattern):
        self.maxBitErrorsInSyncPattern = maxBitErrorsInSyncPattern

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_NonNegativeLongType(self, value):
        # Validate type xtce:NonNegativeLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on NonNegativeLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.AutoInvert is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='SyncStrategyType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SyncStrategyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SyncStrategyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SyncStrategyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SyncStrategyType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SyncStrategyType'):
        if self.verifyToLockGoodFrames != 4 and 'verifyToLockGoodFrames' not in already_processed:
            already_processed.add('verifyToLockGoodFrames')
            outfile.write(' verifyToLockGoodFrames="%s"' % self.gds_format_integer(self.verifyToLockGoodFrames,
                                                                                   input_name='verifyToLockGoodFrames'))
        if self.checkToLockGoodFrames != 1 and 'checkToLockGoodFrames' not in already_processed:
            already_processed.add('checkToLockGoodFrames')
            outfile.write(' checkToLockGoodFrames="%s"' % self.gds_format_integer(self.checkToLockGoodFrames,
                                                                                  input_name='checkToLockGoodFrames'))
        if self.maxBitErrorsInSyncPattern != 0 and 'maxBitErrorsInSyncPattern' not in already_processed:
            already_processed.add('maxBitErrorsInSyncPattern')
            outfile.write(' maxBitErrorsInSyncPattern="%s"' % self.gds_format_integer(self.maxBitErrorsInSyncPattern,
                                                                                      input_name='maxBitErrorsInSyncPattern'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='SyncStrategyType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AutoInvert is not None:
            namespaceprefix_ = self.AutoInvert_nsprefix_ + ':' if (UseCapturedNS_ and self.AutoInvert_nsprefix_) else ''
            self.AutoInvert.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AutoInvert',
                                   pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('verifyToLockGoodFrames', node)
        if value is not None and 'verifyToLockGoodFrames' not in already_processed:
            already_processed.add('verifyToLockGoodFrames')
            self.verifyToLockGoodFrames = self.gds_parse_integer(value, node, 'verifyToLockGoodFrames')
            self.validate_NonNegativeLongType(self.verifyToLockGoodFrames)  # validate type NonNegativeLongType
        value = find_attr_value_('checkToLockGoodFrames', node)
        if value is not None and 'checkToLockGoodFrames' not in already_processed:
            already_processed.add('checkToLockGoodFrames')
            self.checkToLockGoodFrames = self.gds_parse_integer(value, node, 'checkToLockGoodFrames')
            self.validate_NonNegativeLongType(self.checkToLockGoodFrames)  # validate type NonNegativeLongType
        value = find_attr_value_('maxBitErrorsInSyncPattern', node)
        if value is not None and 'maxBitErrorsInSyncPattern' not in already_processed:
            already_processed.add('maxBitErrorsInSyncPattern')
            self.maxBitErrorsInSyncPattern = self.gds_parse_integer(value, node, 'maxBitErrorsInSyncPattern')
            self.validate_NonNegativeLongType(self.maxBitErrorsInSyncPattern)  # validate type NonNegativeLongType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AutoInvert':
            obj_ = AutoInvertType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AutoInvert = obj_
            obj_.original_tagname_ = 'AutoInvert'


# end class SyncStrategyType


class SyncPatternType(GeneratedsSuper):
    """The pattern of bits used to look for frame synchronization.CCSDS ASM for
    non-turbocoded frames = 1acffc1dtruncate the mask from the lefttruncate
    the pattern from the left"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, pattern=None, bitLocationFromStartOfContainer=0, mask=None, maskLengthInBits=None,
                 patternLengthInBits=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.pattern = _cast(None, pattern)
        self.pattern_nsprefix_ = None
        self.bitLocationFromStartOfContainer = _cast(int, bitLocationFromStartOfContainer)
        self.bitLocationFromStartOfContainer_nsprefix_ = None
        self.mask = _cast(None, mask)
        self.mask_nsprefix_ = None
        self.maskLengthInBits = _cast(int, maskLengthInBits)
        self.maskLengthInBits_nsprefix_ = None
        self.patternLengthInBits = _cast(int, patternLengthInBits)
        self.patternLengthInBits_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SyncPatternType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SyncPatternType.subclass:
            return SyncPatternType.subclass(*args_, **kwargs_)
        else:
            return SyncPatternType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_pattern(self):
        return self.pattern

    def set_pattern(self, pattern):
        self.pattern = pattern

    def get_bitLocationFromStartOfContainer(self):
        return self.bitLocationFromStartOfContainer

    def set_bitLocationFromStartOfContainer(self, bitLocationFromStartOfContainer):
        self.bitLocationFromStartOfContainer = bitLocationFromStartOfContainer

    def get_mask(self):
        return self.mask

    def set_mask(self, mask):
        self.mask = mask

    def get_maskLengthInBits(self):
        return self.maskLengthInBits

    def set_maskLengthInBits(self, maskLengthInBits):
        self.maskLengthInBits = maskLengthInBits

    def get_patternLengthInBits(self):
        return self.patternLengthInBits

    def set_patternLengthInBits(self, patternLengthInBits):
        self.patternLengthInBits = patternLengthInBits

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='SyncPatternType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SyncPatternType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SyncPatternType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SyncPatternType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SyncPatternType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SyncPatternType'):
        if self.pattern is not None and 'pattern' not in already_processed:
            already_processed.add('pattern')
            outfile.write(' pattern=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.pattern), input_name='pattern')),))
        if self.bitLocationFromStartOfContainer != 0 and 'bitLocationFromStartOfContainer' not in already_processed:
            already_processed.add('bitLocationFromStartOfContainer')
            outfile.write(
                ' bitLocationFromStartOfContainer="%s"' % self.gds_format_integer(self.bitLocationFromStartOfContainer,
                                                                                  input_name='bitLocationFromStartOfContainer'))
        if self.mask is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            outfile.write(
                ' mask=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mask), input_name='mask')),))
        if self.maskLengthInBits is not None and 'maskLengthInBits' not in already_processed:
            already_processed.add('maskLengthInBits')
            outfile.write(' maskLengthInBits="%s"' % self.gds_format_integer(self.maskLengthInBits,
                                                                             input_name='maskLengthInBits'))
        if self.patternLengthInBits is not None and 'patternLengthInBits' not in already_processed:
            already_processed.add('patternLengthInBits')
            outfile.write(' patternLengthInBits="%s"' % self.gds_format_integer(self.patternLengthInBits,
                                                                                input_name='patternLengthInBits'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='SyncPatternType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pattern', node)
        if value is not None and 'pattern' not in already_processed:
            already_processed.add('pattern')
            self.pattern = value
        value = find_attr_value_('bitLocationFromStartOfContainer', node)
        if value is not None and 'bitLocationFromStartOfContainer' not in already_processed:
            already_processed.add('bitLocationFromStartOfContainer')
            self.bitLocationFromStartOfContainer = self.gds_parse_integer(value, node,
                                                                          'bitLocationFromStartOfContainer')
        value = find_attr_value_('mask', node)
        if value is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            self.mask = value
        value = find_attr_value_('maskLengthInBits', node)
        if value is not None and 'maskLengthInBits' not in already_processed:
            already_processed.add('maskLengthInBits')
            self.maskLengthInBits = self.gds_parse_integer(value, node, 'maskLengthInBits')
            self.validate_PositiveLongType(self.maskLengthInBits)  # validate type PositiveLongType
        value = find_attr_value_('patternLengthInBits', node)
        if value is not None and 'patternLengthInBits' not in already_processed:
            already_processed.add('patternLengthInBits')
            self.patternLengthInBits = self.gds_parse_integer(value, node, 'patternLengthInBits')
            self.validate_PositiveLongType(self.patternLengthInBits)  # validate type PositiveLongType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class SyncPatternType


class VariableFrameSyncStrategyType(SyncStrategyType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SyncStrategyType

    def __init__(self, verifyToLockGoodFrames='4', checkToLockGoodFrames='1', maxBitErrorsInSyncPattern='0',
                 AutoInvert=None, Flag=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(VariableFrameSyncStrategyType, self).__init__(verifyToLockGoodFrames, checkToLockGoodFrames,
                                                            maxBitErrorsInSyncPattern, AutoInvert, **kwargs_)
        self.Flag = Flag
        self.Flag_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableFrameSyncStrategyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableFrameSyncStrategyType.subclass:
            return VariableFrameSyncStrategyType.subclass(*args_, **kwargs_)
        else:
            return VariableFrameSyncStrategyType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Flag(self):
        return self.Flag

    def set_Flag(self, Flag):
        self.Flag = Flag

    def hasContent_(self):
        if (
                self.Flag is not None or
                super(VariableFrameSyncStrategyType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
               name_='VariableFrameSyncStrategyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VariableFrameSyncStrategyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VariableFrameSyncStrategyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='VariableFrameSyncStrategyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='VariableFrameSyncStrategyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='VariableFrameSyncStrategyType'):
        super(VariableFrameSyncStrategyType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                    name_='VariableFrameSyncStrategyType')

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='VariableFrameSyncStrategyType', fromsubclass_=False, pretty_print=True):
        super(VariableFrameSyncStrategyType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_,
                                                                  name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Flag is not None:
            namespaceprefix_ = self.Flag_nsprefix_ + ':' if (UseCapturedNS_ and self.Flag_nsprefix_) else ''
            self.Flag.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Flag',
                             pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(VariableFrameSyncStrategyType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Flag':
            obj_ = FlagType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Flag = obj_
            obj_.original_tagname_ = 'Flag'
        super(VariableFrameSyncStrategyType, self).buildChildren(child_, node, nodeName_, True)


# end class VariableFrameSyncStrategyType


class DimensionType(GeneratedsSuper):
    """For partial entries of an array, the starting and ending index for each
    dimension, OR the Size must be specified. Indexes are zero based."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, StartingIndex=None, EndingIndex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.StartingIndex = StartingIndex
        self.StartingIndex_nsprefix_ = None
        self.EndingIndex = EndingIndex
        self.EndingIndex_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionType.subclass:
            return DimensionType.subclass(*args_, **kwargs_)
        else:
            return DimensionType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_StartingIndex(self):
        return self.StartingIndex

    def set_StartingIndex(self, StartingIndex):
        self.StartingIndex = StartingIndex

    def get_EndingIndex(self):
        return self.EndingIndex

    def set_EndingIndex(self, EndingIndex):
        self.EndingIndex = EndingIndex

    def hasContent_(self):
        if (
                self.StartingIndex is not None or
                self.EndingIndex is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='DimensionType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DimensionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DimensionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DimensionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DimensionType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DimensionType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='DimensionType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StartingIndex is not None:
            namespaceprefix_ = self.StartingIndex_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.StartingIndex_nsprefix_) else ''
            self.StartingIndex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StartingIndex',
                                      pretty_print=pretty_print)
        if self.EndingIndex is not None:
            namespaceprefix_ = self.EndingIndex_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.EndingIndex_nsprefix_) else ''
            self.EndingIndex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EndingIndex',
                                    pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'StartingIndex':
            class_obj_ = self.get_class_obj_(child_, IntegerValueType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StartingIndex = obj_
            obj_.original_tagname_ = 'StartingIndex'
        elif nodeName_ == 'EndingIndex':
            class_obj_ = self.get_class_obj_(child_, IntegerValueType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EndingIndex = obj_
            obj_.original_tagname_ = 'EndingIndex'


# end class DimensionType


class ArgumentDimensionType(GeneratedsSuper):
    """Identical to DimensionType but supports argument instance references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, StartingIndex=None, EndingIndex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.StartingIndex = StartingIndex
        self.StartingIndex_nsprefix_ = None
        self.EndingIndex = EndingIndex
        self.EndingIndex_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentDimensionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentDimensionType.subclass:
            return ArgumentDimensionType.subclass(*args_, **kwargs_)
        else:
            return ArgumentDimensionType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_StartingIndex(self):
        return self.StartingIndex

    def set_StartingIndex(self, StartingIndex):
        self.StartingIndex = StartingIndex

    def get_EndingIndex(self):
        return self.EndingIndex

    def set_EndingIndex(self, EndingIndex):
        self.EndingIndex = EndingIndex

    def hasContent_(self):
        if (
                self.StartingIndex is not None or
                self.EndingIndex is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentDimensionType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentDimensionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentDimensionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentDimensionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentDimensionType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArgumentDimensionType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ArgumentDimensionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StartingIndex is not None:
            namespaceprefix_ = self.StartingIndex_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.StartingIndex_nsprefix_) else ''
            self.StartingIndex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StartingIndex',
                                      pretty_print=pretty_print)
        if self.EndingIndex is not None:
            namespaceprefix_ = self.EndingIndex_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.EndingIndex_nsprefix_) else ''
            self.EndingIndex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EndingIndex',
                                    pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'StartingIndex':
            class_obj_ = self.get_class_obj_(child_, ArgumentIntegerValueType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StartingIndex = obj_
            obj_.original_tagname_ = 'StartingIndex'
        elif nodeName_ == 'EndingIndex':
            class_obj_ = self.get_class_obj_(child_, ArgumentIntegerValueType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EndingIndex = obj_
            obj_.original_tagname_ = 'EndingIndex'


# end class ArgumentDimensionType


class DimensionListType(GeneratedsSuper):
    """Where the Dimension list is in this form:
    Array[1stDim][2ndDim][lastDim]. The last dimension is assumed to be the
    least significant - that is this dimension will cycle through its
    combination before the next to last dimension changes. The order MUST
    ascend or the array will need to be broken out entry by entry."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Dimension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Dimension is None:
            self.Dimension = []
        else:
            self.Dimension = Dimension
        self.Dimension_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionListType.subclass:
            return DimensionListType.subclass(*args_, **kwargs_)
        else:
            return DimensionListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Dimension(self):
        return self.Dimension

    def set_Dimension(self, Dimension):
        self.Dimension = Dimension

    def add_Dimension(self, value):
        self.Dimension.append(value)

    def insert_Dimension_at(self, index, value):
        self.Dimension.insert(index, value)

    def replace_Dimension_at(self, index, value):
        self.Dimension[index] = value

    def hasContent_(self):
        if (
                self.Dimension
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='DimensionListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DimensionListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DimensionListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DimensionListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DimensionListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DimensionListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='DimensionListType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Dimension_ in self.Dimension:
            namespaceprefix_ = self.Dimension_nsprefix_ + ':' if (UseCapturedNS_ and self.Dimension_nsprefix_) else ''
            Dimension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Dimension',
                              pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Dimension':
            obj_ = DimensionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimension.append(obj_)
            obj_.original_tagname_ = 'Dimension'


# end class DimensionListType


class ArgumentDimensionListType(GeneratedsSuper):
    """Identical to DimensionListType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Dimension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Dimension is None:
            self.Dimension = []
        else:
            self.Dimension = Dimension
        self.Dimension_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentDimensionListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentDimensionListType.subclass:
            return ArgumentDimensionListType.subclass(*args_, **kwargs_)
        else:
            return ArgumentDimensionListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Dimension(self):
        return self.Dimension

    def set_Dimension(self, Dimension):
        self.Dimension = Dimension

    def add_Dimension(self, value):
        self.Dimension.append(value)

    def insert_Dimension_at(self, index, value):
        self.Dimension.insert(index, value)

    def replace_Dimension_at(self, index, value):
        self.Dimension[index] = value

    def hasContent_(self):
        if (
                self.Dimension
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentDimensionListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentDimensionListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentDimensionListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentDimensionListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentDimensionListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentDimensionListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ArgumentDimensionListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Dimension_ in self.Dimension:
            namespaceprefix_ = self.Dimension_nsprefix_ + ':' if (UseCapturedNS_ and self.Dimension_nsprefix_) else ''
            Dimension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Dimension',
                              pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Dimension':
            obj_ = ArgumentDimensionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimension.append(obj_)
            obj_.original_tagname_ = 'Dimension'


# end class ArgumentDimensionListType


class EnumerationListType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Enumeration=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Enumeration is None:
            self.Enumeration = []
        else:
            self.Enumeration = Enumeration
        self.Enumeration_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnumerationListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnumerationListType.subclass:
            return EnumerationListType.subclass(*args_, **kwargs_)
        else:
            return EnumerationListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Enumeration(self):
        return self.Enumeration

    def set_Enumeration(self, Enumeration):
        self.Enumeration = Enumeration

    def add_Enumeration(self, value):
        self.Enumeration.append(value)

    def insert_Enumeration_at(self, index, value):
        self.Enumeration.insert(index, value)

    def replace_Enumeration_at(self, index, value):
        self.Enumeration[index] = value

    def hasContent_(self):
        if (
                self.Enumeration
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='EnumerationListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnumerationListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EnumerationListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnumerationListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EnumerationListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EnumerationListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='EnumerationListType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Enumeration_ in self.Enumeration:
            namespaceprefix_ = self.Enumeration_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.Enumeration_nsprefix_) else ''
            Enumeration_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Enumeration',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Enumeration':
            obj_ = ValueEnumerationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Enumeration.append(obj_)
            obj_.original_tagname_ = 'Enumeration'


# end class EnumerationListType


class MemberListType(GeneratedsSuper):
    """Order is important only if the name of the AggregateParameter or
    Aggregate Argument is directly referenced in SequenceContainers. In
    this case the members are assued to be added sequentially (in the order
    listed here) into the Container."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Member=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Member is None:
            self.Member = []
        else:
            self.Member = Member
        self.Member_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MemberListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MemberListType.subclass:
            return MemberListType.subclass(*args_, **kwargs_)
        else:
            return MemberListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Member(self):
        return self.Member

    def set_Member(self, Member):
        self.Member = Member

    def add_Member(self, value):
        self.Member.append(value)

    def insert_Member_at(self, index, value):
        self.Member.insert(index, value)

    def replace_Member_at(self, index, value):
        self.Member[index] = value

    def hasContent_(self):
        if (
                self.Member
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MemberListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MemberListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MemberListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MemberListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MemberListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MemberListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MemberListType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Member_ in self.Member:
            namespaceprefix_ = self.Member_nsprefix_ + ':' if (UseCapturedNS_ and self.Member_nsprefix_) else ''
            Member_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Member',
                           pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Member':
            obj_ = MemberType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Member.append(obj_)
            obj_.original_tagname_ = 'Member'


# end class MemberListType


class UnitSetType(GeneratedsSuper):
    """Describe an ordered collection of units that form a unit-expression.
    Units may be described for both calibrated/engineering values and also
    potentially uncalibrated/raw values. See UnitType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Unit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Unit is None:
            self.Unit = []
        else:
            self.Unit = Unit
        self.Unit_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitSetType.subclass:
            return UnitSetType.subclass(*args_, **kwargs_)
        else:
            return UnitSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Unit(self):
        return self.Unit

    def set_Unit(self, Unit):
        self.Unit = Unit

    def add_Unit(self, value):
        self.Unit.append(value)

    def insert_Unit_at(self, index, value):
        self.Unit.insert(index, value)

    def replace_Unit_at(self, index, value):
        self.Unit[index] = value

    def hasContent_(self):
        if (
                self.Unit
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='UnitSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnitSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UnitSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnitSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UnitSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UnitSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='UnitSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Unit_ in self.Unit:
            namespaceprefix_ = self.Unit_nsprefix_ + ':' if (UseCapturedNS_ and self.Unit_nsprefix_) else ''
            Unit_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Unit', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Unit':
            obj_ = UnitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Unit.append(obj_)
            obj_.original_tagname_ = 'Unit'


# end class UnitSetType


class ValidFloatRangeSetType(GeneratedsSuper):
    """Numerical ranges that define the universe of valid values for this
    argument. A single range is the most common, although it is possible to
    define multiple ranges when the valid values are not contiguous.By
    default and general recommendation, the valid range is specified in
    engineering/calibrated values, although this can be adjusted."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, validRangeAppliesToCalibrated=True, ValidRange=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.validRangeAppliesToCalibrated = _cast(bool, validRangeAppliesToCalibrated)
        self.validRangeAppliesToCalibrated_nsprefix_ = None
        if ValidRange is None:
            self.ValidRange = []
        else:
            self.ValidRange = ValidRange
        self.ValidRange_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValidFloatRangeSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValidFloatRangeSetType.subclass:
            return ValidFloatRangeSetType.subclass(*args_, **kwargs_)
        else:
            return ValidFloatRangeSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ValidRange(self):
        return self.ValidRange

    def set_ValidRange(self, ValidRange):
        self.ValidRange = ValidRange

    def add_ValidRange(self, value):
        self.ValidRange.append(value)

    def insert_ValidRange_at(self, index, value):
        self.ValidRange.insert(index, value)

    def replace_ValidRange_at(self, index, value):
        self.ValidRange[index] = value

    def get_validRangeAppliesToCalibrated(self):
        return self.validRangeAppliesToCalibrated

    def set_validRangeAppliesToCalibrated(self, validRangeAppliesToCalibrated):
        self.validRangeAppliesToCalibrated = validRangeAppliesToCalibrated

    def hasContent_(self):
        if (
                self.ValidRange
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ValidFloatRangeSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ValidFloatRangeSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ValidFloatRangeSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ValidFloatRangeSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ValidFloatRangeSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ValidFloatRangeSetType'):
        if not self.validRangeAppliesToCalibrated and 'validRangeAppliesToCalibrated' not in already_processed:
            already_processed.add('validRangeAppliesToCalibrated')
            outfile.write(
                ' validRangeAppliesToCalibrated="%s"' % self.gds_format_boolean(self.validRangeAppliesToCalibrated,
                                                                                input_name='validRangeAppliesToCalibrated'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ValidFloatRangeSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ValidRange_ in self.ValidRange:
            namespaceprefix_ = self.ValidRange_nsprefix_ + ':' if (UseCapturedNS_ and self.ValidRange_nsprefix_) else ''
            ValidRange_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ValidRange',
                               pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('validRangeAppliesToCalibrated', node)
        if value is not None and 'validRangeAppliesToCalibrated' not in already_processed:
            already_processed.add('validRangeAppliesToCalibrated')
            if value in ('true', '1'):
                self.validRangeAppliesToCalibrated = True
            elif value in ('false', '0'):
                self.validRangeAppliesToCalibrated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ValidRange':
            class_obj_ = self.get_class_obj_(child_, FloatRangeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValidRange.append(obj_)
            obj_.original_tagname_ = 'ValidRange'


# end class ValidFloatRangeSetType


class ValidIntegerRangeSetType(GeneratedsSuper):
    """Numerical ranges that define the universe of valid values for this
    argument. A single range is the most common, although it is possible to
    define multiple ranges when the valid values are not contiguous.By
    default and general recommendation, the valid range is specified in
    engineering/calibrated values, although this can be adjusted."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, validRangeAppliesToCalibrated=True, ValidRange=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.validRangeAppliesToCalibrated = _cast(bool, validRangeAppliesToCalibrated)
        self.validRangeAppliesToCalibrated_nsprefix_ = None
        if ValidRange is None:
            self.ValidRange = []
        else:
            self.ValidRange = ValidRange
        self.ValidRange_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValidIntegerRangeSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValidIntegerRangeSetType.subclass:
            return ValidIntegerRangeSetType.subclass(*args_, **kwargs_)
        else:
            return ValidIntegerRangeSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ValidRange(self):
        return self.ValidRange

    def set_ValidRange(self, ValidRange):
        self.ValidRange = ValidRange

    def add_ValidRange(self, value):
        self.ValidRange.append(value)

    def insert_ValidRange_at(self, index, value):
        self.ValidRange.insert(index, value)

    def replace_ValidRange_at(self, index, value):
        self.ValidRange[index] = value

    def get_validRangeAppliesToCalibrated(self):
        return self.validRangeAppliesToCalibrated

    def set_validRangeAppliesToCalibrated(self, validRangeAppliesToCalibrated):
        self.validRangeAppliesToCalibrated = validRangeAppliesToCalibrated

    def hasContent_(self):
        if (
                self.ValidRange
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ValidIntegerRangeSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ValidIntegerRangeSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ValidIntegerRangeSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ValidIntegerRangeSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ValidIntegerRangeSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ValidIntegerRangeSetType'):
        if not self.validRangeAppliesToCalibrated and 'validRangeAppliesToCalibrated' not in already_processed:
            already_processed.add('validRangeAppliesToCalibrated')
            outfile.write(
                ' validRangeAppliesToCalibrated="%s"' % self.gds_format_boolean(self.validRangeAppliesToCalibrated,
                                                                                input_name='validRangeAppliesToCalibrated'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ValidIntegerRangeSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ValidRange_ in self.ValidRange:
            namespaceprefix_ = self.ValidRange_nsprefix_ + ':' if (UseCapturedNS_ and self.ValidRange_nsprefix_) else ''
            ValidRange_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ValidRange',
                               pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('validRangeAppliesToCalibrated', node)
        if value is not None and 'validRangeAppliesToCalibrated' not in already_processed:
            already_processed.add('validRangeAppliesToCalibrated')
            if value in ('true', '1'):
                self.validRangeAppliesToCalibrated = True
            elif value in ('false', '0'):
                self.validRangeAppliesToCalibrated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ValidRange':
            class_obj_ = self.get_class_obj_(child_, IntegerRangeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValidRange.append(obj_)
            obj_.original_tagname_ = 'ValidRange'


# end class ValidIntegerRangeSetType


class ByteType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, byteSignificance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.byteSignificance = _cast(int, byteSignificance)
        self.byteSignificance_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ByteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ByteType.subclass:
            return ByteType.subclass(*args_, **kwargs_)
        else:
            return ByteType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_byteSignificance(self):
        return self.byteSignificance

    def set_byteSignificance(self, byteSignificance):
        self.byteSignificance = byteSignificance

    def validate_NonNegativeLongType(self, value):
        # Validate type xtce:NonNegativeLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on NonNegativeLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ByteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ByteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ByteType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ByteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ByteType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ByteType'):
        if self.byteSignificance is not None and 'byteSignificance' not in already_processed:
            already_processed.add('byteSignificance')
            outfile.write(' byteSignificance="%s"' % self.gds_format_integer(self.byteSignificance,
                                                                             input_name='byteSignificance'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ByteType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('byteSignificance', node)
        if value is not None and 'byteSignificance' not in already_processed:
            already_processed.add('byteSignificance')
            self.byteSignificance = self.gds_parse_integer(value, node, 'byteSignificance')
            self.validate_NonNegativeLongType(self.byteSignificance)  # validate type NonNegativeLongType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ByteType


class CRCType(GeneratedsSuper):
    """Cyclic Redundancy Check (CRC) definition. The polynomial coefficients
    for the CRC
    are defined as a truncated hex value. The coefficient for the nth bit of an
    n-bit CRC will always be 1 and is not
    represented in the truncated hex value. For example, the truncated hex
    value of CRC-32 (width=32 bits) used in the
    Ethernet specification is 0x04C11DB7, where each non-zero bit of the
    truncated hex represents a coefficient of 1 in
    the polynomial and the bit position represents the exponent. There may also
    be an initial remainder "InitRemainder"
    and a final XOR "FinalXOR" to fully specify the CRC. reflectData and
    reflectRemainder may also be specified to
    reverse the bit order in the incoming data and/or the result."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, width=None, reflectData=False, reflectRemainder=False, bitsFromReference=None, reference='start',
                 Polynomial=None, InitRemainder=None, FinalXOR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.width = _cast(int, width)
        self.width_nsprefix_ = None
        self.reflectData = _cast(bool, reflectData)
        self.reflectData_nsprefix_ = None
        self.reflectRemainder = _cast(bool, reflectRemainder)
        self.reflectRemainder_nsprefix_ = None
        self.bitsFromReference = _cast(int, bitsFromReference)
        self.bitsFromReference_nsprefix_ = None
        self.reference = _cast(None, reference)
        self.reference_nsprefix_ = None
        self.Polynomial = Polynomial
        self.Polynomial_nsprefix_ = None
        self.InitRemainder = InitRemainder
        self.InitRemainder_nsprefix_ = None
        self.FinalXOR = FinalXOR
        self.FinalXOR_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CRCType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CRCType.subclass:
            return CRCType.subclass(*args_, **kwargs_)
        else:
            return CRCType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Polynomial(self):
        return self.Polynomial

    def set_Polynomial(self, Polynomial):
        self.Polynomial = Polynomial

    def get_InitRemainder(self):
        return self.InitRemainder

    def set_InitRemainder(self, InitRemainder):
        self.InitRemainder = InitRemainder

    def get_FinalXOR(self):
        return self.FinalXOR

    def set_FinalXOR(self, FinalXOR):
        self.FinalXOR = FinalXOR

    def get_width(self):
        return self.width

    def set_width(self, width):
        self.width = width

    def get_reflectData(self):
        return self.reflectData

    def set_reflectData(self, reflectData):
        self.reflectData = reflectData

    def get_reflectRemainder(self):
        return self.reflectRemainder

    def set_reflectRemainder(self, reflectRemainder):
        self.reflectRemainder = reflectRemainder

    def get_bitsFromReference(self):
        return self.bitsFromReference

    def set_bitsFromReference(self, bitsFromReference):
        self.bitsFromReference = bitsFromReference

    def get_reference(self):
        return self.reference

    def set_reference(self, reference):
        self.reference = reference

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def validate_NonNegativeLongType(self, value):
        # Validate type xtce:NonNegativeLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on NonNegativeLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def validate_ReferencePointType(self, value):
        # Validate type xtce:ReferencePointType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'end']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ReferencePointType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.Polynomial is not None or
                self.InitRemainder is not None or
                self.FinalXOR is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
               name_='CRCType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CRCType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CRCType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CRCType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CRCType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CRCType'):
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_integer(self.width, input_name='width'))
        if self.reflectData and 'reflectData' not in already_processed:
            already_processed.add('reflectData')
            outfile.write(' reflectData="%s"' % self.gds_format_boolean(self.reflectData, input_name='reflectData'))
        if self.reflectRemainder and 'reflectRemainder' not in already_processed:
            already_processed.add('reflectRemainder')
            outfile.write(' reflectRemainder="%s"' % self.gds_format_boolean(self.reflectRemainder,
                                                                             input_name='reflectRemainder'))
        if self.bitsFromReference is not None and 'bitsFromReference' not in already_processed:
            already_processed.add('bitsFromReference')
            outfile.write(' bitsFromReference="%s"' % self.gds_format_integer(self.bitsFromReference,
                                                                              input_name='bitsFromReference'))
        if self.reference != "start" and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
                       name_='CRCType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Polynomial is not None:
            namespaceprefix_ = self.Polynomial_nsprefix_ + ':' if (UseCapturedNS_ and self.Polynomial_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPolynomial>%s</%sPolynomial>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.Polynomial), input_name='Polynomial')), namespaceprefix_, eol_))
        if self.InitRemainder is not None:
            namespaceprefix_ = self.InitRemainder_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.InitRemainder_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInitRemainder>%s</%sInitRemainder>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.InitRemainder), input_name='InitRemainder')), namespaceprefix_,
                                                                       eol_))
        if self.FinalXOR is not None:
            namespaceprefix_ = self.FinalXOR_nsprefix_ + ':' if (UseCapturedNS_ and self.FinalXOR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFinalXOR>%s</%sFinalXOR>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.FinalXOR), input_name='FinalXOR')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = self.gds_parse_integer(value, node, 'width')
            self.validate_PositiveLongType(self.width)  # validate type PositiveLongType
        value = find_attr_value_('reflectData', node)
        if value is not None and 'reflectData' not in already_processed:
            already_processed.add('reflectData')
            if value in ('true', '1'):
                self.reflectData = True
            elif value in ('false', '0'):
                self.reflectData = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('reflectRemainder', node)
        if value is not None and 'reflectRemainder' not in already_processed:
            already_processed.add('reflectRemainder')
            if value in ('true', '1'):
                self.reflectRemainder = True
            elif value in ('false', '0'):
                self.reflectRemainder = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('bitsFromReference', node)
        if value is not None and 'bitsFromReference' not in already_processed:
            already_processed.add('bitsFromReference')
            self.bitsFromReference = self.gds_parse_integer(value, node, 'bitsFromReference')
            self.validate_NonNegativeLongType(self.bitsFromReference)  # validate type NonNegativeLongType
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
            self.validate_ReferencePointType(self.reference)  # validate type ReferencePointType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Polynomial':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Polynomial')
            value_ = self.gds_validate_string(value_, node, 'Polynomial')
            self.Polynomial = value_
            self.Polynomial_nsprefix_ = child_.prefix
        elif nodeName_ == 'InitRemainder':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'InitRemainder')
            value_ = self.gds_validate_string(value_, node, 'InitRemainder')
            self.InitRemainder = value_
            self.InitRemainder_nsprefix_ = child_.prefix
        elif nodeName_ == 'FinalXOR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FinalXOR')
            value_ = self.gds_validate_string(value_, node, 'FinalXOR')
            self.FinalXOR = value_
            self.FinalXOR_nsprefix_ = child_.prefix


# end class CRCType


class DataEncodingType(GeneratedsSuper):
    """Describes how a particular piece of data is sent or received from some
    non-native, off-platform device. (e.g. a spacecraft)"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, bitOrder='mostSignificantBitFirst', byteOrder='mostSignificantByteFirst',
                 ErrorDetectCorrect=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.bitOrder = _cast(None, bitOrder)
        self.bitOrder_nsprefix_ = None
        self.byteOrder = _cast(None, byteOrder)
        self.byteOrder_nsprefix_ = None
        self.ErrorDetectCorrect = ErrorDetectCorrect
        self.ErrorDetectCorrect_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataEncodingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataEncodingType.subclass:
            return DataEncodingType.subclass(*args_, **kwargs_)
        else:
            return DataEncodingType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ErrorDetectCorrect(self):
        return self.ErrorDetectCorrect

    def set_ErrorDetectCorrect(self, ErrorDetectCorrect):
        self.ErrorDetectCorrect = ErrorDetectCorrect

    def get_bitOrder(self):
        return self.bitOrder

    def set_bitOrder(self, bitOrder):
        self.bitOrder = bitOrder

    def get_byteOrder(self):
        return self.byteOrder

    def set_byteOrder(self, byteOrder):
        self.byteOrder = byteOrder

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_BitOrderType(self, value):
        # Validate type xtce:BitOrderType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['leastSignificantBitFirst', 'mostSignificantBitFirst']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BitOrderType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_ByteOrderType(self, value):
        # Validate type xtce:ByteOrderType, a restriction on None.
        pass

    def hasContent_(self):
        if (
                self.ErrorDetectCorrect is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='DataEncodingType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataEncodingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DataEncodingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataEncodingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataEncodingType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataEncodingType'):
        if self.bitOrder != "mostSignificantBitFirst" and 'bitOrder' not in already_processed:
            already_processed.add('bitOrder')
            outfile.write(' bitOrder=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.bitOrder), input_name='bitOrder')),))
        if self.byteOrder != "mostSignificantByteFirst" and 'byteOrder' not in already_processed:
            already_processed.add('byteOrder')
            outfile.write(' byteOrder=%s' % (quote_attrib(self.byteOrder),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='DataEncodingType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ErrorDetectCorrect is not None:
            namespaceprefix_ = self.ErrorDetectCorrect_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ErrorDetectCorrect_nsprefix_) else ''
            self.ErrorDetectCorrect.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='ErrorDetectCorrect', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bitOrder', node)
        if value is not None and 'bitOrder' not in already_processed:
            already_processed.add('bitOrder')
            self.bitOrder = value
            self.validate_BitOrderType(self.bitOrder)  # validate type BitOrderType
        value = find_attr_value_('byteOrder', node)
        if value is not None and 'byteOrder' not in already_processed:
            already_processed.add('byteOrder')
            self.byteOrder = value
            self.validate_ByteOrderType(self.byteOrder)  # validate type ByteOrderType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ErrorDetectCorrect':
            obj_ = ErrorDetectCorrectType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ErrorDetectCorrect = obj_
            obj_.original_tagname_ = 'ErrorDetectCorrect'


# end class DataEncodingType


class EncodingType(GeneratedsSuper):
    """Describe the data encoding for a time data type. It includes the units
    and other attributes scale and offset. Use scale and offset to describe
    a y=mx+b relationship (where m is the slope/scale and b is the
    intercept/offset) to make adjustments to the encoded time value so that
    it matches the time units. For binary encoded time use transform
    algorithms to convert time data formats that are too difficult to
    describe in XTCE. See AbsoluteTimeDataType and
    RelativeTimeDataType.Time units, with the default being in
    seconds.Linear slope used as a shorter form of specifying a calibrator
    to convert between the raw value and the engineering units.Linear
    intercept used as a shorter form of specifying a calibrator to convert
    between the raw value and the engineering units."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, units='seconds', scale=1, offset=0, BinaryDataEncoding=None, FloatDataEncoding=None,
                 IntegerDataEncoding=None, StringDataEncoding=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.units = _cast(None, units)
        self.units_nsprefix_ = None
        self.scale = _cast(float, scale)
        self.scale_nsprefix_ = None
        self.offset = _cast(float, offset)
        self.offset_nsprefix_ = None
        self.BinaryDataEncoding = BinaryDataEncoding
        self.BinaryDataEncoding_nsprefix_ = None
        self.FloatDataEncoding = FloatDataEncoding
        self.FloatDataEncoding_nsprefix_ = None
        self.IntegerDataEncoding = IntegerDataEncoding
        self.IntegerDataEncoding_nsprefix_ = None
        self.StringDataEncoding = StringDataEncoding
        self.StringDataEncoding_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EncodingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EncodingType.subclass:
            return EncodingType.subclass(*args_, **kwargs_)
        else:
            return EncodingType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_BinaryDataEncoding(self):
        return self.BinaryDataEncoding

    def set_BinaryDataEncoding(self, BinaryDataEncoding):
        self.BinaryDataEncoding = BinaryDataEncoding

    def get_FloatDataEncoding(self):
        return self.FloatDataEncoding

    def set_FloatDataEncoding(self, FloatDataEncoding):
        self.FloatDataEncoding = FloatDataEncoding

    def get_IntegerDataEncoding(self):
        return self.IntegerDataEncoding

    def set_IntegerDataEncoding(self, IntegerDataEncoding):
        self.IntegerDataEncoding = IntegerDataEncoding

    def get_StringDataEncoding(self):
        return self.StringDataEncoding

    def set_StringDataEncoding(self, StringDataEncoding):
        self.StringDataEncoding = StringDataEncoding

    def get_units(self):
        return self.units

    def set_units(self, units):
        self.units = units

    def get_scale(self):
        return self.scale

    def set_scale(self, scale):
        self.scale = scale

    def get_offset(self):
        return self.offset

    def set_offset(self, offset):
        self.offset = offset

    def validate_TimeUnitsType(self, value):
        # Validate type xtce:TimeUnitsType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['seconds', 'picoSeconds', 'days', 'months', 'years']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TimeUnitsType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.BinaryDataEncoding is not None or
                self.FloatDataEncoding is not None or
                self.IntegerDataEncoding is not None or
                self.StringDataEncoding is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='EncodingType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EncodingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EncodingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EncodingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EncodingType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EncodingType'):
        if self.units != "seconds" and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(
                ' units=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.units), input_name='units')),))
        if self.scale != 1 and 'scale' not in already_processed:
            already_processed.add('scale')
            outfile.write(' scale="%s"' % self.gds_format_double(self.scale, input_name='scale'))
        if self.offset != 0 and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_double(self.offset, input_name='offset'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='EncodingType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BinaryDataEncoding is not None:
            namespaceprefix_ = self.BinaryDataEncoding_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BinaryDataEncoding_nsprefix_) else ''
            self.BinaryDataEncoding.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='BinaryDataEncoding', pretty_print=pretty_print)
        if self.FloatDataEncoding is not None:
            namespaceprefix_ = self.FloatDataEncoding_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.FloatDataEncoding_nsprefix_) else ''
            self.FloatDataEncoding.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FloatDataEncoding',
                                          pretty_print=pretty_print)
        if self.IntegerDataEncoding is not None:
            namespaceprefix_ = self.IntegerDataEncoding_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.IntegerDataEncoding_nsprefix_) else ''
            self.IntegerDataEncoding.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='IntegerDataEncoding', pretty_print=pretty_print)
        if self.StringDataEncoding is not None:
            namespaceprefix_ = self.StringDataEncoding_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.StringDataEncoding_nsprefix_) else ''
            self.StringDataEncoding.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='StringDataEncoding', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
            self.validate_TimeUnitsType(self.units)  # validate type TimeUnitsType
        value = find_attr_value_('scale', node)
        if value is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            value = self.gds_parse_double(value, node, 'scale')
            self.scale = value
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            value = self.gds_parse_double(value, node, 'offset')
            self.offset = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BinaryDataEncoding':
            obj_ = BinaryDataEncodingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BinaryDataEncoding = obj_
            obj_.original_tagname_ = 'BinaryDataEncoding'
        elif nodeName_ == 'FloatDataEncoding':
            obj_ = FloatDataEncodingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FloatDataEncoding = obj_
            obj_.original_tagname_ = 'FloatDataEncoding'
        elif nodeName_ == 'IntegerDataEncoding':
            obj_ = IntegerDataEncodingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IntegerDataEncoding = obj_
            obj_.original_tagname_ = 'IntegerDataEncoding'
        elif nodeName_ == 'StringDataEncoding':
            obj_ = StringDataEncodingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StringDataEncoding = obj_
            obj_.original_tagname_ = 'StringDataEncoding'


# end class EncodingType


class FloatDataEncodingType(DataEncodingType):
    """For common encodings of floating point dataSpecifies real/decimal
    numeric value to raw encoding method, with the default being
    "IEEE754_1985".Number of bits to use for the float raw encoding method,
    with 32 being the default. Not every number of bits is valid for each
    encoding method.A changeThreshold may optionally be specified to inform
    systems of the minimum change in value that is significant. This is
    used by some systems to limit the telemetry processing and/or recording
    requirements. If the value is unspecified or zero, any change is
    significant."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataEncodingType

    def __init__(self, bitOrder='mostSignificantBitFirst', byteOrder='mostSignificantByteFirst',
                 ErrorDetectCorrect=None, encoding='IEEE754_1985', sizeInBits='32', changeThreshold=None,
                 DefaultCalibrator=None, ContextCalibratorList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FloatDataEncodingType, self).__init__(bitOrder, byteOrder, ErrorDetectCorrect, **kwargs_)
        self.encoding = _cast(None, encoding)
        self.encoding_nsprefix_ = None
        self.sizeInBits = _cast(int, sizeInBits)
        self.sizeInBits_nsprefix_ = None
        self.changeThreshold = _cast(float, changeThreshold)
        self.changeThreshold_nsprefix_ = None
        self.DefaultCalibrator = DefaultCalibrator
        self.DefaultCalibrator_nsprefix_ = None
        self.ContextCalibratorList = ContextCalibratorList
        self.ContextCalibratorList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatDataEncodingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatDataEncodingType.subclass:
            return FloatDataEncodingType.subclass(*args_, **kwargs_)
        else:
            return FloatDataEncodingType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DefaultCalibrator(self):
        return self.DefaultCalibrator

    def set_DefaultCalibrator(self, DefaultCalibrator):
        self.DefaultCalibrator = DefaultCalibrator

    def get_ContextCalibratorList(self):
        return self.ContextCalibratorList

    def set_ContextCalibratorList(self, ContextCalibratorList):
        self.ContextCalibratorList = ContextCalibratorList

    def get_encoding(self):
        return self.encoding

    def set_encoding(self, encoding):
        self.encoding = encoding

    def get_sizeInBits(self):
        return self.sizeInBits

    def set_sizeInBits(self, sizeInBits):
        self.sizeInBits = sizeInBits

    def get_changeThreshold(self):
        return self.changeThreshold

    def set_changeThreshold(self, changeThreshold):
        self.changeThreshold = changeThreshold

    def validate_FloatEncodingType(self, value):
        # Validate type xtce:FloatEncodingType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['IEEE754_1985', 'IEEE754', 'MILSTD_1750A', 'DEC', 'IBM', 'TI']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FloatEncodingType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_FloatEncodingSizeInBitsType(self, value):
        # Validate type xtce:FloatEncodingSizeInBitsType, a restriction on unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = [16, 32, 40, 48, 64, 80, 128]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FloatEncodingSizeInBitsType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.DefaultCalibrator is not None or
                self.ContextCalibratorList is not None or
                super(FloatDataEncodingType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='FloatDataEncodingType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FloatDataEncodingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FloatDataEncodingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FloatDataEncodingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FloatDataEncodingType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FloatDataEncodingType'):
        super(FloatDataEncodingType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                            name_='FloatDataEncodingType')
        if self.encoding != "IEEE754_1985" and 'encoding' not in already_processed:
            already_processed.add('encoding')
            outfile.write(' encoding=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.encoding), input_name='encoding')),))
        if self.sizeInBits != 32 and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            outfile.write(' sizeInBits="%s"' % self.gds_format_integer(self.sizeInBits, input_name='sizeInBits'))
        if self.changeThreshold is not None and 'changeThreshold' not in already_processed:
            already_processed.add('changeThreshold')
            outfile.write(
                ' changeThreshold="%s"' % self.gds_format_double(self.changeThreshold, input_name='changeThreshold'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='FloatDataEncodingType', fromsubclass_=False, pretty_print=True):
        super(FloatDataEncodingType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                          pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultCalibrator is not None:
            namespaceprefix_ = self.DefaultCalibrator_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DefaultCalibrator_nsprefix_) else ''
            self.DefaultCalibrator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DefaultCalibrator',
                                          pretty_print=pretty_print)
        if self.ContextCalibratorList is not None:
            namespaceprefix_ = self.ContextCalibratorList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextCalibratorList_nsprefix_) else ''
            self.ContextCalibratorList.export(outfile, level, namespaceprefix_, namespacedef_='',
                                              name_='ContextCalibratorList', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('encoding', node)
        if value is not None and 'encoding' not in already_processed:
            already_processed.add('encoding')
            self.encoding = value
            self.validate_FloatEncodingType(self.encoding)  # validate type FloatEncodingType
        value = find_attr_value_('sizeInBits', node)
        if value is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            self.sizeInBits = self.gds_parse_integer(value, node, 'sizeInBits')
            self.validate_FloatEncodingSizeInBitsType(self.sizeInBits)  # validate type FloatEncodingSizeInBitsType
        value = find_attr_value_('changeThreshold', node)
        if value is not None and 'changeThreshold' not in already_processed:
            already_processed.add('changeThreshold')
            value = self.gds_parse_double(value, node, 'changeThreshold')
            self.changeThreshold = value
        super(FloatDataEncodingType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DefaultCalibrator':
            obj_ = CalibratorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DefaultCalibrator = obj_
            obj_.original_tagname_ = 'DefaultCalibrator'
        elif nodeName_ == 'ContextCalibratorList':
            obj_ = ContextCalibratorListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextCalibratorList = obj_
            obj_.original_tagname_ = 'ContextCalibratorList'
        super(FloatDataEncodingType, self).buildChildren(child_, node, nodeName_, True)


# end class FloatDataEncodingType


class IntegerDataEncodingType(DataEncodingType):
    """For all major encodings of integer dataSpecifies integer numeric value
    to raw encoding method, with the default being "unsigned".Number of
    bits to use for the raw encoding, with 8 being the default.A
    changeThreshold may optionally be specified to inform systems of the
    minimum change in value that is significant. This is used by some
    systems to limit the telemetry processing and/or recording
    requirements, such as for an analog-to-digital converter that dithers
    in the least significant bit. If the value is unspecified or zero, any
    change is significant."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataEncodingType

    def __init__(self, bitOrder='mostSignificantBitFirst', byteOrder='mostSignificantByteFirst',
                 ErrorDetectCorrect=None, encoding='unsigned', sizeInBits='8', changeThreshold=None,
                 DefaultCalibrator=None, ContextCalibratorList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IntegerDataEncodingType, self).__init__(bitOrder, byteOrder, ErrorDetectCorrect, **kwargs_)
        self.encoding = _cast(None, encoding)
        self.encoding_nsprefix_ = None
        self.sizeInBits = _cast(int, sizeInBits)
        self.sizeInBits_nsprefix_ = None
        self.changeThreshold = _cast(int, changeThreshold)
        self.changeThreshold_nsprefix_ = None
        self.DefaultCalibrator = DefaultCalibrator
        self.DefaultCalibrator_nsprefix_ = None
        self.ContextCalibratorList = ContextCalibratorList
        self.ContextCalibratorList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntegerDataEncodingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntegerDataEncodingType.subclass:
            return IntegerDataEncodingType.subclass(*args_, **kwargs_)
        else:
            return IntegerDataEncodingType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DefaultCalibrator(self):
        return self.DefaultCalibrator

    def set_DefaultCalibrator(self, DefaultCalibrator):
        self.DefaultCalibrator = DefaultCalibrator

    def get_ContextCalibratorList(self):
        return self.ContextCalibratorList

    def set_ContextCalibratorList(self, ContextCalibratorList):
        self.ContextCalibratorList = ContextCalibratorList

    def get_encoding(self):
        return self.encoding

    def set_encoding(self, encoding):
        self.encoding = encoding

    def get_sizeInBits(self):
        return self.sizeInBits

    def set_sizeInBits(self, sizeInBits):
        self.sizeInBits = sizeInBits

    def get_changeThreshold(self):
        return self.changeThreshold

    def set_changeThreshold(self, changeThreshold):
        self.changeThreshold = changeThreshold

    def validate_IntegerEncodingType(self, value):
        # Validate type xtce:IntegerEncodingType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['unsigned', 'signMagnitude', 'twosComplement', 'onesComplement', 'BCD', 'packedBCD']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on IntegerEncodingType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def validate_NonNegativeLongType(self, value):
        # Validate type xtce:NonNegativeLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on NonNegativeLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.DefaultCalibrator is not None or
                self.ContextCalibratorList is not None or
                super(IntegerDataEncodingType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='IntegerDataEncodingType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IntegerDataEncodingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IntegerDataEncodingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IntegerDataEncodingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IntegerDataEncodingType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IntegerDataEncodingType'):
        super(IntegerDataEncodingType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                              name_='IntegerDataEncodingType')
        if self.encoding != "unsigned" and 'encoding' not in already_processed:
            already_processed.add('encoding')
            outfile.write(' encoding=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.encoding), input_name='encoding')),))
        if self.sizeInBits != 8 and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            outfile.write(' sizeInBits="%s"' % self.gds_format_integer(self.sizeInBits, input_name='sizeInBits'))
        if self.changeThreshold is not None and 'changeThreshold' not in already_processed:
            already_processed.add('changeThreshold')
            outfile.write(
                ' changeThreshold="%s"' % self.gds_format_integer(self.changeThreshold, input_name='changeThreshold'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='IntegerDataEncodingType', fromsubclass_=False, pretty_print=True):
        super(IntegerDataEncodingType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                            True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultCalibrator is not None:
            namespaceprefix_ = self.DefaultCalibrator_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DefaultCalibrator_nsprefix_) else ''
            self.DefaultCalibrator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DefaultCalibrator',
                                          pretty_print=pretty_print)
        if self.ContextCalibratorList is not None:
            namespaceprefix_ = self.ContextCalibratorList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextCalibratorList_nsprefix_) else ''
            self.ContextCalibratorList.export(outfile, level, namespaceprefix_, namespacedef_='',
                                              name_='ContextCalibratorList', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('encoding', node)
        if value is not None and 'encoding' not in already_processed:
            already_processed.add('encoding')
            self.encoding = value
            self.validate_IntegerEncodingType(self.encoding)  # validate type IntegerEncodingType
        value = find_attr_value_('sizeInBits', node)
        if value is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            self.sizeInBits = self.gds_parse_integer(value, node, 'sizeInBits')
            self.validate_PositiveLongType(self.sizeInBits)  # validate type PositiveLongType
        value = find_attr_value_('changeThreshold', node)
        if value is not None and 'changeThreshold' not in already_processed:
            already_processed.add('changeThreshold')
            self.changeThreshold = self.gds_parse_integer(value, node, 'changeThreshold')
            self.validate_NonNegativeLongType(self.changeThreshold)  # validate type NonNegativeLongType
        super(IntegerDataEncodingType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DefaultCalibrator':
            obj_ = CalibratorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DefaultCalibrator = obj_
            obj_.original_tagname_ = 'DefaultCalibrator'
        elif nodeName_ == 'ContextCalibratorList':
            obj_ = ContextCalibratorListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextCalibratorList = obj_
            obj_.original_tagname_ = 'ContextCalibratorList'
        super(IntegerDataEncodingType, self).buildChildren(child_, node, nodeName_, True)


# end class IntegerDataEncodingType


class LeadingSizeType(GeneratedsSuper):
    """Like PASCAL strings, the size of the string is given as an integer at
    the start of the string. SizeTag must be an unsigned Integer"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, sizeInBitsOfSizeTag='16', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sizeInBitsOfSizeTag = _cast(int, sizeInBitsOfSizeTag)
        self.sizeInBitsOfSizeTag_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LeadingSizeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LeadingSizeType.subclass:
            return LeadingSizeType.subclass(*args_, **kwargs_)
        else:
            return LeadingSizeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_sizeInBitsOfSizeTag(self):
        return self.sizeInBitsOfSizeTag

    def set_sizeInBitsOfSizeTag(self, sizeInBitsOfSizeTag):
        self.sizeInBitsOfSizeTag = sizeInBitsOfSizeTag

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='LeadingSizeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LeadingSizeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LeadingSizeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LeadingSizeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LeadingSizeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LeadingSizeType'):
        if self.sizeInBitsOfSizeTag != 16 and 'sizeInBitsOfSizeTag' not in already_processed:
            already_processed.add('sizeInBitsOfSizeTag')
            outfile.write(' sizeInBitsOfSizeTag="%s"' % self.gds_format_integer(self.sizeInBitsOfSizeTag,
                                                                                input_name='sizeInBitsOfSizeTag'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='LeadingSizeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sizeInBitsOfSizeTag', node)
        if value is not None and 'sizeInBitsOfSizeTag' not in already_processed:
            already_processed.add('sizeInBitsOfSizeTag')
            self.sizeInBitsOfSizeTag = self.gds_parse_integer(value, node, 'sizeInBitsOfSizeTag')
            self.validate_PositiveLongType(self.sizeInBitsOfSizeTag)  # validate type PositiveLongType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class LeadingSizeType


class ParityType(GeneratedsSuper):
    """Bit position starts with 'zero'."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, type_=None, bitsFromReference=None, reference='start', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.bitsFromReference = _cast(int, bitsFromReference)
        self.bitsFromReference_nsprefix_ = None
        self.reference = _cast(None, reference)
        self.reference_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParityType.subclass:
            return ParityType.subclass(*args_, **kwargs_)
        else:
            return ParityType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_type(self):
        return self.type_

    def set_type(self, type_):
        self.type_ = type_

    def get_bitsFromReference(self):
        return self.bitsFromReference

    def set_bitsFromReference(self, bitsFromReference):
        self.bitsFromReference = bitsFromReference

    def get_reference(self):
        return self.reference

    def set_reference(self, reference):
        self.reference = reference

    def validate_ParityFormType(self, value):
        # Validate type xtce:ParityFormType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['Even', 'Odd']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ParityFormType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_NonNegativeLongType(self, value):
        # Validate type xtce:NonNegativeLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on NonNegativeLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def validate_ReferencePointType(self, value):
        # Validate type xtce:ReferencePointType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['start', 'end']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ReferencePointType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ParityType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParityType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParityType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParityType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(
                ' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')),))
        if self.bitsFromReference is not None and 'bitsFromReference' not in already_processed:
            already_processed.add('bitsFromReference')
            outfile.write(' bitsFromReference="%s"' % self.gds_format_integer(self.bitsFromReference,
                                                                              input_name='bitsFromReference'))
        if self.reference != "start" and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ParityType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_ParityFormType(self.type_)  # validate type ParityFormType
        value = find_attr_value_('bitsFromReference', node)
        if value is not None and 'bitsFromReference' not in already_processed:
            already_processed.add('bitsFromReference')
            self.bitsFromReference = self.gds_parse_integer(value, node, 'bitsFromReference')
            self.validate_NonNegativeLongType(self.bitsFromReference)  # validate type NonNegativeLongType
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
            self.validate_ReferencePointType(self.reference)  # validate type ReferencePointType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ParityType


class SizeInBitsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Fixed=None, TerminationChar='00', LeadingSize=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Fixed = Fixed
        self.Fixed_nsprefix_ = None
        self.TerminationChar = TerminationChar
        self.TerminationChar_nsprefix_ = None
        self.LeadingSize = LeadingSize
        self.LeadingSize_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SizeInBitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SizeInBitsType.subclass:
            return SizeInBitsType.subclass(*args_, **kwargs_)
        else:
            return SizeInBitsType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Fixed(self):
        return self.Fixed

    def set_Fixed(self, Fixed):
        self.Fixed = Fixed

    def get_TerminationChar(self):
        return self.TerminationChar

    def set_TerminationChar(self, TerminationChar):
        self.TerminationChar = TerminationChar

    def get_LeadingSize(self):
        return self.LeadingSize

    def set_LeadingSize(self, LeadingSize):
        self.LeadingSize = LeadingSize

    def hasContent_(self):
        if (
                self.Fixed is not None or
                self.TerminationChar != "" or
                self.LeadingSize is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
               name_='SizeInBitsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SizeInBitsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SizeInBitsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SizeInBitsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SizeInBitsType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SizeInBitsType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
                       name_='SizeInBitsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Fixed is not None:
            namespaceprefix_ = self.Fixed_nsprefix_ + ':' if (UseCapturedNS_ and self.Fixed_nsprefix_) else ''
            self.Fixed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Fixed',
                              pretty_print=pretty_print)
        if self.TerminationChar != "":
            namespaceprefix_ = self.TerminationChar_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TerminationChar_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTerminationChar>%s</%sTerminationChar>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.TerminationChar), input_name='TerminationChar')),
                                                                           namespaceprefix_, eol_))
        if self.LeadingSize is not None:
            namespaceprefix_ = self.LeadingSize_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.LeadingSize_nsprefix_) else ''
            self.LeadingSize.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LeadingSize',
                                    pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Fixed':
            obj_ = FixedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Fixed = obj_
            obj_.original_tagname_ = 'Fixed'
        elif nodeName_ == 'TerminationChar':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TerminationChar')
            value_ = self.gds_validate_string(value_, node, 'TerminationChar')
            self.TerminationChar = value_
            self.TerminationChar_nsprefix_ = child_.prefix
        elif nodeName_ == 'LeadingSize':
            obj_ = LeadingSizeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LeadingSize = obj_
            obj_.original_tagname_ = 'LeadingSize'


# end class SizeInBitsType


class ArgumentVariableStringType(GeneratedsSuper):
    """Identical to VariableStringType but supports argument instance
    references.The upper bound of the size of this string data type so that
    the implementation can reserve/allocate enough memory to capture all
    reported instances of the string."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, maxSizeInBits=None, DynamicValue=None, DiscreteLookupList=None, LeadingSize=None,
                 TerminationChar='00', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.maxSizeInBits = _cast(int, maxSizeInBits)
        self.maxSizeInBits_nsprefix_ = None
        self.DynamicValue = DynamicValue
        self.DynamicValue_nsprefix_ = None
        self.DiscreteLookupList = DiscreteLookupList
        self.DiscreteLookupList_nsprefix_ = None
        self.LeadingSize = LeadingSize
        self.LeadingSize_nsprefix_ = None
        self.TerminationChar = TerminationChar
        self.TerminationChar_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentVariableStringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentVariableStringType.subclass:
            return ArgumentVariableStringType.subclass(*args_, **kwargs_)
        else:
            return ArgumentVariableStringType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DynamicValue(self):
        return self.DynamicValue

    def set_DynamicValue(self, DynamicValue):
        self.DynamicValue = DynamicValue

    def get_DiscreteLookupList(self):
        return self.DiscreteLookupList

    def set_DiscreteLookupList(self, DiscreteLookupList):
        self.DiscreteLookupList = DiscreteLookupList

    def get_LeadingSize(self):
        return self.LeadingSize

    def set_LeadingSize(self, LeadingSize):
        self.LeadingSize = LeadingSize

    def get_TerminationChar(self):
        return self.TerminationChar

    def set_TerminationChar(self, TerminationChar):
        self.TerminationChar = TerminationChar

    def get_maxSizeInBits(self):
        return self.maxSizeInBits

    def set_maxSizeInBits(self, maxSizeInBits):
        self.maxSizeInBits = maxSizeInBits

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.DynamicValue is not None or
                self.DiscreteLookupList is not None or
                self.LeadingSize is not None or
                self.TerminationChar != ""
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
               name_='ArgumentVariableStringType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentVariableStringType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentVariableStringType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentVariableStringType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentVariableStringType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentVariableStringType'):
        if self.maxSizeInBits is not None and 'maxSizeInBits' not in already_processed:
            already_processed.add('maxSizeInBits')
            outfile.write(
                ' maxSizeInBits="%s"' % self.gds_format_integer(self.maxSizeInBits, input_name='maxSizeInBits'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
                       name_='ArgumentVariableStringType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DynamicValue is not None:
            namespaceprefix_ = self.DynamicValue_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DynamicValue_nsprefix_) else ''
            self.DynamicValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DynamicValue',
                                     pretty_print=pretty_print)
        if self.DiscreteLookupList is not None:
            namespaceprefix_ = self.DiscreteLookupList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DiscreteLookupList_nsprefix_) else ''
            self.DiscreteLookupList.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='DiscreteLookupList', pretty_print=pretty_print)
        if self.LeadingSize is not None:
            namespaceprefix_ = self.LeadingSize_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.LeadingSize_nsprefix_) else ''
            self.LeadingSize.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LeadingSize',
                                    pretty_print=pretty_print)
        if self.TerminationChar != "":
            namespaceprefix_ = self.TerminationChar_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TerminationChar_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTerminationChar>%s</%sTerminationChar>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.TerminationChar), input_name='TerminationChar')),
                                                                           namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('maxSizeInBits', node)
        if value is not None and 'maxSizeInBits' not in already_processed:
            already_processed.add('maxSizeInBits')
            self.maxSizeInBits = self.gds_parse_integer(value, node, 'maxSizeInBits')
            self.validate_PositiveLongType(self.maxSizeInBits)  # validate type PositiveLongType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DynamicValue':
            obj_ = ArgumentDynamicValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DynamicValue = obj_
            obj_.original_tagname_ = 'DynamicValue'
        elif nodeName_ == 'DiscreteLookupList':
            obj_ = ArgumentDiscreteLookupListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DiscreteLookupList = obj_
            obj_.original_tagname_ = 'DiscreteLookupList'
        elif nodeName_ == 'LeadingSize':
            obj_ = LeadingSizeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LeadingSize = obj_
            obj_.original_tagname_ = 'LeadingSize'
        elif nodeName_ == 'TerminationChar':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TerminationChar')
            value_ = self.gds_validate_string(value_, node, 'TerminationChar')
            self.TerminationChar = value_
            self.TerminationChar_nsprefix_ = child_.prefix


# end class ArgumentVariableStringType


class VariableStringType(GeneratedsSuper):
    """Describe a variable string whose length may change between samples.The
    upper bound of the size of this string data type so that the
    implementation can reserve/allocate enough memory to capture all
    reported instances of the string."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, maxSizeInBits=None, DynamicValue=None, DiscreteLookupList=None, LeadingSize=None,
                 TerminationChar='00', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.maxSizeInBits = _cast(int, maxSizeInBits)
        self.maxSizeInBits_nsprefix_ = None
        self.DynamicValue = DynamicValue
        self.DynamicValue_nsprefix_ = None
        self.DiscreteLookupList = DiscreteLookupList
        self.DiscreteLookupList_nsprefix_ = None
        self.LeadingSize = LeadingSize
        self.LeadingSize_nsprefix_ = None
        self.TerminationChar = TerminationChar
        self.TerminationChar_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableStringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableStringType.subclass:
            return VariableStringType.subclass(*args_, **kwargs_)
        else:
            return VariableStringType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DynamicValue(self):
        return self.DynamicValue

    def set_DynamicValue(self, DynamicValue):
        self.DynamicValue = DynamicValue

    def get_DiscreteLookupList(self):
        return self.DiscreteLookupList

    def set_DiscreteLookupList(self, DiscreteLookupList):
        self.DiscreteLookupList = DiscreteLookupList

    def get_LeadingSize(self):
        return self.LeadingSize

    def set_LeadingSize(self, LeadingSize):
        self.LeadingSize = LeadingSize

    def get_TerminationChar(self):
        return self.TerminationChar

    def set_TerminationChar(self, TerminationChar):
        self.TerminationChar = TerminationChar

    def get_maxSizeInBits(self):
        return self.maxSizeInBits

    def set_maxSizeInBits(self, maxSizeInBits):
        self.maxSizeInBits = maxSizeInBits

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.DynamicValue is not None or
                self.DiscreteLookupList is not None or
                self.LeadingSize is not None or
                self.TerminationChar != ""
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
               name_='VariableStringType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VariableStringType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VariableStringType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VariableStringType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VariableStringType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VariableStringType'):
        if self.maxSizeInBits is not None and 'maxSizeInBits' not in already_processed:
            already_processed.add('maxSizeInBits')
            outfile.write(
                ' maxSizeInBits="%s"' % self.gds_format_integer(self.maxSizeInBits, input_name='maxSizeInBits'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
                       name_='VariableStringType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DynamicValue is not None:
            namespaceprefix_ = self.DynamicValue_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DynamicValue_nsprefix_) else ''
            self.DynamicValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DynamicValue',
                                     pretty_print=pretty_print)
        if self.DiscreteLookupList is not None:
            namespaceprefix_ = self.DiscreteLookupList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DiscreteLookupList_nsprefix_) else ''
            self.DiscreteLookupList.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='DiscreteLookupList', pretty_print=pretty_print)
        if self.LeadingSize is not None:
            namespaceprefix_ = self.LeadingSize_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.LeadingSize_nsprefix_) else ''
            self.LeadingSize.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LeadingSize',
                                    pretty_print=pretty_print)
        if self.TerminationChar != "":
            namespaceprefix_ = self.TerminationChar_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TerminationChar_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTerminationChar>%s</%sTerminationChar>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.TerminationChar), input_name='TerminationChar')),
                                                                           namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('maxSizeInBits', node)
        if value is not None and 'maxSizeInBits' not in already_processed:
            already_processed.add('maxSizeInBits')
            self.maxSizeInBits = self.gds_parse_integer(value, node, 'maxSizeInBits')
            self.validate_PositiveLongType(self.maxSizeInBits)  # validate type PositiveLongType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DynamicValue':
            obj_ = DynamicValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DynamicValue = obj_
            obj_.original_tagname_ = 'DynamicValue'
        elif nodeName_ == 'DiscreteLookupList':
            obj_ = DiscreteLookupListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DiscreteLookupList = obj_
            obj_.original_tagname_ = 'DiscreteLookupList'
        elif nodeName_ == 'LeadingSize':
            obj_ = LeadingSizeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LeadingSize = obj_
            obj_.original_tagname_ = 'LeadingSize'
        elif nodeName_ == 'TerminationChar':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TerminationChar')
            value_ = self.gds_validate_string(value_, node, 'TerminationChar')
            self.TerminationChar = value_
            self.TerminationChar_nsprefix_ = child_.prefix


# end class VariableStringType


class ArgumentStringDataEncodingType(DataEncodingType):
    """Identical to StringDataEncodingType but supports argument instance
    references.The character set encoding of this string data type."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataEncodingType

    def __init__(self, bitOrder='mostSignificantBitFirst', byteOrder='mostSignificantByteFirst',
                 ErrorDetectCorrect=None, encoding='UTF-8', SizeInBits=None, Variable=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentStringDataEncodingType, self).__init__(bitOrder, byteOrder, ErrorDetectCorrect, **kwargs_)
        self.encoding = _cast(None, encoding)
        self.encoding_nsprefix_ = None
        self.SizeInBits = SizeInBits
        self.SizeInBits_nsprefix_ = None
        self.Variable = Variable
        self.Variable_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentStringDataEncodingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentStringDataEncodingType.subclass:
            return ArgumentStringDataEncodingType.subclass(*args_, **kwargs_)
        else:
            return ArgumentStringDataEncodingType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SizeInBits(self):
        return self.SizeInBits

    def set_SizeInBits(self, SizeInBits):
        self.SizeInBits = SizeInBits

    def get_Variable(self):
        return self.Variable

    def set_Variable(self, Variable):
        self.Variable = Variable

    def get_encoding(self):
        return self.encoding

    def set_encoding(self, encoding):
        self.encoding = encoding

    def validate_StringEncodingType(self, value):
        # Validate type xtce:StringEncodingType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['US-ASCII', 'ISO-8859-1', 'Windows-1252', 'UTF-8', 'UTF-16', 'UTF-16LE', 'UTF-16BE',
                            'UTF-32', 'UTF-32LE', 'UTF-32BE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StringEncodingType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.SizeInBits is not None or
                self.Variable is not None or
                super(ArgumentStringDataEncodingType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
               name_='ArgumentStringDataEncodingType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentStringDataEncodingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentStringDataEncodingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='ArgumentStringDataEncodingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentStringDataEncodingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentStringDataEncodingType'):
        super(ArgumentStringDataEncodingType, self).exportAttributes(outfile, level, already_processed,
                                                                     namespaceprefix_,
                                                                     name_='ArgumentStringDataEncodingType')
        if self.encoding != "UTF-8" and 'encoding' not in already_processed:
            already_processed.add('encoding')
            outfile.write(' encoding=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.encoding), input_name='encoding')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ArgumentStringDataEncodingType', fromsubclass_=False, pretty_print=True):
        super(ArgumentStringDataEncodingType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_,
                                                                   name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SizeInBits is not None:
            namespaceprefix_ = self.SizeInBits_nsprefix_ + ':' if (UseCapturedNS_ and self.SizeInBits_nsprefix_) else ''
            self.SizeInBits.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SizeInBits',
                                   pretty_print=pretty_print)
        if self.Variable is not None:
            namespaceprefix_ = self.Variable_nsprefix_ + ':' if (UseCapturedNS_ and self.Variable_nsprefix_) else ''
            self.Variable.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Variable',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('encoding', node)
        if value is not None and 'encoding' not in already_processed:
            already_processed.add('encoding')
            self.encoding = value
            self.validate_StringEncodingType(self.encoding)  # validate type StringEncodingType
        super(ArgumentStringDataEncodingType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SizeInBits':
            obj_ = SizeInBitsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SizeInBits = obj_
            obj_.original_tagname_ = 'SizeInBits'
        elif nodeName_ == 'Variable':
            obj_ = ArgumentVariableStringType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Variable = obj_
            obj_.original_tagname_ = 'Variable'
        super(ArgumentStringDataEncodingType, self).buildChildren(child_, node, nodeName_, True)


# end class ArgumentStringDataEncodingType


class StringDataEncodingType(DataEncodingType):
    """Describe common encodings of string data: UTF-8 and UTF-16. See
    StringDataType.The character set encoding of this string data type."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataEncodingType

    def __init__(self, bitOrder='mostSignificantBitFirst', byteOrder='mostSignificantByteFirst',
                 ErrorDetectCorrect=None, encoding='UTF-8', SizeInBits=None, Variable=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(StringDataEncodingType, self).__init__(bitOrder, byteOrder, ErrorDetectCorrect, **kwargs_)
        self.encoding = _cast(None, encoding)
        self.encoding_nsprefix_ = None
        self.SizeInBits = SizeInBits
        self.SizeInBits_nsprefix_ = None
        self.Variable = Variable
        self.Variable_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringDataEncodingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringDataEncodingType.subclass:
            return StringDataEncodingType.subclass(*args_, **kwargs_)
        else:
            return StringDataEncodingType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SizeInBits(self):
        return self.SizeInBits

    def set_SizeInBits(self, SizeInBits):
        self.SizeInBits = SizeInBits

    def get_Variable(self):
        return self.Variable

    def set_Variable(self, Variable):
        self.Variable = Variable

    def get_encoding(self):
        return self.encoding

    def set_encoding(self, encoding):
        self.encoding = encoding

    def validate_StringEncodingType(self, value):
        # Validate type xtce:StringEncodingType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['US-ASCII', 'ISO-8859-1', 'Windows-1252', 'UTF-8', 'UTF-16', 'UTF-16LE', 'UTF-16BE',
                            'UTF-32', 'UTF-32LE', 'UTF-32BE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StringEncodingType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.SizeInBits is not None or
                self.Variable is not None or
                super(StringDataEncodingType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='StringDataEncodingType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringDataEncodingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StringDataEncodingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringDataEncodingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringDataEncodingType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StringDataEncodingType'):
        super(StringDataEncodingType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                             name_='StringDataEncodingType')
        if self.encoding != "UTF-8" and 'encoding' not in already_processed:
            already_processed.add('encoding')
            outfile.write(' encoding=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.encoding), input_name='encoding')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='StringDataEncodingType', fromsubclass_=False, pretty_print=True):
        super(StringDataEncodingType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                           pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SizeInBits is not None:
            namespaceprefix_ = self.SizeInBits_nsprefix_ + ':' if (UseCapturedNS_ and self.SizeInBits_nsprefix_) else ''
            self.SizeInBits.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SizeInBits',
                                   pretty_print=pretty_print)
        if self.Variable is not None:
            namespaceprefix_ = self.Variable_nsprefix_ + ':' if (UseCapturedNS_ and self.Variable_nsprefix_) else ''
            self.Variable.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Variable',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('encoding', node)
        if value is not None and 'encoding' not in already_processed:
            already_processed.add('encoding')
            self.encoding = value
            self.validate_StringEncodingType(self.encoding)  # validate type StringEncodingType
        super(StringDataEncodingType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SizeInBits':
            obj_ = SizeInBitsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SizeInBits = obj_
            obj_.original_tagname_ = 'SizeInBits'
        elif nodeName_ == 'Variable':
            obj_ = VariableStringType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Variable = obj_
            obj_.original_tagname_ = 'Variable'
        super(StringDataEncodingType, self).buildChildren(child_, node, nodeName_, True)


# end class StringDataEncodingType


class ToStringType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, NumberFormat=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NumberFormat = NumberFormat
        self.NumberFormat_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ToStringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ToStringType.subclass:
            return ToStringType.subclass(*args_, **kwargs_)
        else:
            return ToStringType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_NumberFormat(self):
        return self.NumberFormat

    def set_NumberFormat(self, NumberFormat):
        self.NumberFormat = NumberFormat

    def hasContent_(self):
        if (
                self.NumberFormat is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ToStringType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ToStringType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ToStringType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ToStringType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ToStringType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ToStringType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ToStringType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumberFormat is not None:
            namespaceprefix_ = self.NumberFormat_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.NumberFormat_nsprefix_) else ''
            self.NumberFormat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NumberFormat',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NumberFormat':
            obj_ = NumberFormatType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NumberFormat = obj_
            obj_.original_tagname_ = 'NumberFormat'


# end class ToStringType


class AlgorithmSetType(GeneratedsSuper):
    """An unordered collection of algorithms"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, CustomAlgorithm=None, MathAlgorithm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if CustomAlgorithm is None:
            self.CustomAlgorithm = []
        else:
            self.CustomAlgorithm = CustomAlgorithm
        self.CustomAlgorithm_nsprefix_ = None
        if MathAlgorithm is None:
            self.MathAlgorithm = []
        else:
            self.MathAlgorithm = MathAlgorithm
        self.MathAlgorithm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlgorithmSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlgorithmSetType.subclass:
            return AlgorithmSetType.subclass(*args_, **kwargs_)
        else:
            return AlgorithmSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_CustomAlgorithm(self):
        return self.CustomAlgorithm

    def set_CustomAlgorithm(self, CustomAlgorithm):
        self.CustomAlgorithm = CustomAlgorithm

    def add_CustomAlgorithm(self, value):
        self.CustomAlgorithm.append(value)

    def insert_CustomAlgorithm_at(self, index, value):
        self.CustomAlgorithm.insert(index, value)

    def replace_CustomAlgorithm_at(self, index, value):
        self.CustomAlgorithm[index] = value

    def get_MathAlgorithm(self):
        return self.MathAlgorithm

    def set_MathAlgorithm(self, MathAlgorithm):
        self.MathAlgorithm = MathAlgorithm

    def add_MathAlgorithm(self, value):
        self.MathAlgorithm.append(value)

    def insert_MathAlgorithm_at(self, index, value):
        self.MathAlgorithm.insert(index, value)

    def replace_MathAlgorithm_at(self, index, value):
        self.MathAlgorithm[index] = value

    def hasContent_(self):
        if (
                self.CustomAlgorithm or
                self.MathAlgorithm
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AlgorithmSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlgorithmSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AlgorithmSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlgorithmSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlgorithmSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlgorithmSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AlgorithmSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CustomAlgorithm_ in self.CustomAlgorithm:
            namespaceprefix_ = self.CustomAlgorithm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CustomAlgorithm_nsprefix_) else ''
            CustomAlgorithm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CustomAlgorithm',
                                    pretty_print=pretty_print)
        for MathAlgorithm_ in self.MathAlgorithm:
            namespaceprefix_ = self.MathAlgorithm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MathAlgorithm_nsprefix_) else ''
            MathAlgorithm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MathAlgorithm',
                                  pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CustomAlgorithm':
            obj_ = InputOutputTriggerAlgorithmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CustomAlgorithm.append(obj_)
            obj_.original_tagname_ = 'CustomAlgorithm'
        elif nodeName_ == 'MathAlgorithm':
            obj_ = MathAlgorithmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MathAlgorithm.append(obj_)
            obj_.original_tagname_ = 'MathAlgorithm'


# end class AlgorithmSetType


class AliasSetType(GeneratedsSuper):
    """Contains an unordered collection of Alias elements to describe alternate
    names or IDs for this named item."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Alias=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Alias is None:
            self.Alias = []
        else:
            self.Alias = Alias
        self.Alias_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AliasSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AliasSetType.subclass:
            return AliasSetType.subclass(*args_, **kwargs_)
        else:
            return AliasSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Alias(self):
        return self.Alias

    def set_Alias(self, Alias):
        self.Alias = Alias

    def add_Alias(self, value):
        self.Alias.append(value)

    def insert_Alias_at(self, index, value):
        self.Alias.insert(index, value)

    def replace_Alias_at(self, index, value):
        self.Alias[index] = value

    def hasContent_(self):
        if (
                self.Alias
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AliasSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AliasSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AliasSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AliasSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AliasSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AliasSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AliasSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Alias_ in self.Alias:
            namespaceprefix_ = self.Alias_nsprefix_ + ':' if (UseCapturedNS_ and self.Alias_nsprefix_) else ''
            Alias_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Alias', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Alias':
            obj_ = AliasType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Alias.append(obj_)
            obj_.original_tagname_ = 'Alias'


# end class AliasSetType


class AliasType(GeneratedsSuper):
    """Used to contain an alias (alternate) name or ID for the object. For
    example, a parameter may have a mnemonic, an on-board id, and special
    IDs used by various ground software applications; all of these are
    alias's. Some ground system processing equipment has some severe naming
    restrictions on parameters (e.g., names must less then 12 characters,
    single case or integral id's only); their alias's provide a means of
    capturing each name in a "nameSpace". Note: the name is not reference-
    able (it cannot be used in a name reference substituting for the name
    of the item of interest). See NameDescriptionType.Aliases should be
    grouped together in a "namespace" so that they can be switched in and
    out of data extractions. The namespace generally identifies the purpose
    of the alternate name, whether for software variable names, additional
    operator names, or whatever the purpose.The alternate name or ID to
    use. The alias does not have the restrictions that apply to name
    attributes. This is useful for capturing legacy identifiers for systems
    with unusual naming conventions. It is also useful for capturing
    variable names in software, amongst other things."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, nameSpace=None, alias=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nameSpace = _cast(None, nameSpace)
        self.nameSpace_nsprefix_ = None
        self.alias = _cast(None, alias)
        self.alias_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AliasType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AliasType.subclass:
            return AliasType.subclass(*args_, **kwargs_)
        else:
            return AliasType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_nameSpace(self):
        return self.nameSpace

    def set_nameSpace(self, nameSpace):
        self.nameSpace = nameSpace

    def get_alias(self):
        return self.alias

    def set_alias(self, alias):
        self.alias = alias

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AliasType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AliasType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AliasType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AliasType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AliasType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AliasType'):
        if self.nameSpace is not None and 'nameSpace' not in already_processed:
            already_processed.add('nameSpace')
            outfile.write(' nameSpace=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.nameSpace), input_name='nameSpace')),))
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            outfile.write(
                ' alias=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alias), input_name='alias')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AliasType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nameSpace', node)
        if value is not None and 'nameSpace' not in already_processed:
            already_processed.add('nameSpace')
            self.nameSpace = value
        value = find_attr_value_('alias', node)
        if value is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            self.alias = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class AliasType


class AncillaryDataType(GeneratedsSuper):
    """Use for any other data associated with a named item. May be used to
    include administrative data (e.g., version, CM or tags) or potentially
    any MIME type. Data may be included or given as an href.Identifier for
    this Ancillary Data characteristic, feature, or data.Optional text
    encoding method for the element text content of this element. The
    default is "text/plain".Optional Uniform Resource Identifier for this
    characteristic, feature, or data."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, name=None, mimeType='text/plain', href=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.mimeType = _cast(None, mimeType)
        self.mimeType_nsprefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AncillaryDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AncillaryDataType.subclass:
            return AncillaryDataType.subclass(*args_, **kwargs_)
        else:
            return AncillaryDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_name(self):
        return self.name

    def set_name(self, name):
        self.name = name

    def get_mimeType(self):
        return self.mimeType

    def set_mimeType(self, mimeType):
        self.mimeType = mimeType

    def get_href(self):
        return self.href

    def set_href(self, href):
        self.href = href

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AncillaryDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AncillaryDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AncillaryDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AncillaryDataType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AncillaryDataType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AncillaryDataType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(
                ' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')),))
        if self.mimeType != "text/plain" and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            outfile.write(' mimeType=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.mimeType), input_name='mimeType')),))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(
                ' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AncillaryDataType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('mimeType', node)
        if value is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            self.mimeType = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class AncillaryDataType


class AncillaryDataSetType(GeneratedsSuper):
    """Describe an unordered collection of ancillary data. AncillaryData
    elements capture platform/program/implementation specific data about
    the parent element object that is non-standard and would not fit into
    the schema. See AncillaryDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, AncillaryData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if AncillaryData is None:
            self.AncillaryData = []
        else:
            self.AncillaryData = AncillaryData
        self.AncillaryData_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AncillaryDataSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AncillaryDataSetType.subclass:
            return AncillaryDataSetType.subclass(*args_, **kwargs_)
        else:
            return AncillaryDataSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AncillaryData(self):
        return self.AncillaryData

    def set_AncillaryData(self, AncillaryData):
        self.AncillaryData = AncillaryData

    def add_AncillaryData(self, value):
        self.AncillaryData.append(value)

    def insert_AncillaryData_at(self, index, value):
        self.AncillaryData.insert(index, value)

    def replace_AncillaryData_at(self, index, value):
        self.AncillaryData[index] = value

    def hasContent_(self):
        if (
                self.AncillaryData
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AncillaryDataSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AncillaryDataSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AncillaryDataSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AncillaryDataSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AncillaryDataSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AncillaryDataSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AncillaryDataSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AncillaryData_ in self.AncillaryData:
            namespaceprefix_ = self.AncillaryData_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AncillaryData_nsprefix_) else ''
            AncillaryData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AncillaryData',
                                  pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AncillaryData':
            obj_ = AncillaryDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AncillaryData.append(obj_)
            obj_.original_tagname_ = 'AncillaryData'


# end class AncillaryDataSetType


class AuthorSetType(GeneratedsSuper):
    """Describe an unordered collection of authors. See AuthorType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Author=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Author is None:
            self.Author = []
        else:
            self.Author = Author
        self.Author_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AuthorSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AuthorSetType.subclass:
            return AuthorSetType.subclass(*args_, **kwargs_)
        else:
            return AuthorSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Author(self):
        return self.Author

    def set_Author(self, Author):
        self.Author = Author

    def add_Author(self, value):
        self.Author.append(value)

    def insert_Author_at(self, index, value):
        self.Author.insert(index, value)

    def replace_Author_at(self, index, value):
        self.Author[index] = value

    def validate_AuthorType(self, value):
        result = True
        # Validate type AuthorType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            pass
        return result

    def hasContent_(self):
        if (
                self.Author
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AuthorSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AuthorSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AuthorSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AuthorSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AuthorSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AuthorSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AuthorSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Author_ in self.Author:
            namespaceprefix_ = self.Author_nsprefix_ + ':' if (UseCapturedNS_ and self.Author_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAuthor>%s</%sAuthor>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(Author_), input_name='Author')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Author':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Author')
            value_ = self.gds_validate_string(value_, node, 'Author')
            self.Author.append(value_)
            self.Author_nsprefix_ = child_.prefix
            # validate type AuthorType
            self.validate_AuthorType(self.Author[-1])


# end class AuthorSetType


class BaseConditionsType(GeneratedsSuper):
    """A base type for boolean expression related elements that improves the
    mapping produced by data binding tools."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseConditionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseConditionsType.subclass:
            return BaseConditionsType.subclass(*args_, **kwargs_)
        else:
            return BaseConditionsType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BaseConditionsType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseConditionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BaseConditionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseConditionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseConditionsType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseConditionsType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BaseConditionsType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class BaseConditionsType


class BooleanExpressionType(GeneratedsSuper):
    """Holds an arbitrarily complex boolean expression"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Condition=None, ANDedConditions=None, ORedConditions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Condition = Condition
        self.Condition_nsprefix_ = None
        self.ANDedConditions = ANDedConditions
        self.ANDedConditions_nsprefix_ = None
        self.ORedConditions = ORedConditions
        self.ORedConditions_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BooleanExpressionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BooleanExpressionType.subclass:
            return BooleanExpressionType.subclass(*args_, **kwargs_)
        else:
            return BooleanExpressionType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Condition(self):
        return self.Condition

    def set_Condition(self, Condition):
        self.Condition = Condition

    def get_ANDedConditions(self):
        return self.ANDedConditions

    def set_ANDedConditions(self, ANDedConditions):
        self.ANDedConditions = ANDedConditions

    def get_ORedConditions(self):
        return self.ORedConditions

    def set_ORedConditions(self, ORedConditions):
        self.ORedConditions = ORedConditions

    def hasContent_(self):
        if (
                self.Condition is not None or
                self.ANDedConditions is not None or
                self.ORedConditions is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BooleanExpressionType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BooleanExpressionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BooleanExpressionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanExpressionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BooleanExpressionType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BooleanExpressionType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='BooleanExpressionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Condition is not None:
            namespaceprefix_ = self.Condition_nsprefix_ + ':' if (UseCapturedNS_ and self.Condition_nsprefix_) else ''
            self.Condition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Condition',
                                  pretty_print=pretty_print)
        if self.ANDedConditions is not None:
            namespaceprefix_ = self.ANDedConditions_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ANDedConditions_nsprefix_) else ''
            self.ANDedConditions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANDedConditions',
                                        pretty_print=pretty_print)
        if self.ORedConditions is not None:
            namespaceprefix_ = self.ORedConditions_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ORedConditions_nsprefix_) else ''
            self.ORedConditions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ORedConditions',
                                       pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Condition':
            obj_ = ComparisonCheckType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Condition = obj_
            obj_.original_tagname_ = 'Condition'
        elif nodeName_ == 'ANDedConditions':
            obj_ = ANDedConditionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANDedConditions = obj_
            obj_.original_tagname_ = 'ANDedConditions'
        elif nodeName_ == 'ORedConditions':
            obj_ = ORedConditionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ORedConditions = obj_
            obj_.original_tagname_ = 'ORedConditions'


# end class BooleanExpressionType


class ComparisonCheckType(BaseConditionsType):
    """Describe the comparison between the instance (value) of a parameter
    against either a specified value or another parameter instance."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseConditionsType

    def __init__(self, ComparisonOperator=None, ParameterInstanceRef=None, Value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ComparisonCheckType, self).__init__(**kwargs_)
        self.ComparisonOperator = ComparisonOperator
        self.validate_ComparisonOperatorsType(self.ComparisonOperator)
        self.ComparisonOperator_nsprefix_ = None
        self.ParameterInstanceRef = ParameterInstanceRef
        self.ParameterInstanceRef_nsprefix_ = None
        self.Value = Value
        self.Value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComparisonCheckType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComparisonCheckType.subclass:
            return ComparisonCheckType.subclass(*args_, **kwargs_)
        else:
            return ComparisonCheckType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ComparisonOperator(self):
        return self.ComparisonOperator

    def set_ComparisonOperator(self, ComparisonOperator):
        self.ComparisonOperator = ComparisonOperator

    def get_ParameterInstanceRef(self):
        return self.ParameterInstanceRef

    def set_ParameterInstanceRef(self, ParameterInstanceRef):
        self.ParameterInstanceRef = ParameterInstanceRef

    def get_Value(self):
        return self.Value

    def set_Value(self, Value):
        self.Value = Value

    def validate_ComparisonOperatorsType(self, value):
        result = True
        # Validate type ComparisonOperatorsType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['==', '!=', '<', '<=', '>', '>=']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ComparisonOperatorsType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def hasContent_(self):
        if (
                self.ComparisonOperator is not None or
                self.ParameterInstanceRef is not None or
                self.Value is not None or
                super(ComparisonCheckType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
               name_='ComparisonCheckType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ComparisonCheckType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ComparisonCheckType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ComparisonCheckType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ComparisonCheckType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ComparisonCheckType'):
        super(ComparisonCheckType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                          name_='ComparisonCheckType')

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
                       name_='ComparisonCheckType', fromsubclass_=False, pretty_print=True):
        super(ComparisonCheckType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                        pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ComparisonOperator is not None:
            namespaceprefix_ = self.ComparisonOperator_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ComparisonOperator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComparisonOperator>%s</%sComparisonOperator>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.ComparisonOperator), input_name='ComparisonOperator')),
                                                                                 namespaceprefix_, eol_))
        if self.ParameterInstanceRef is not None:
            namespaceprefix_ = self.ParameterInstanceRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterInstanceRef_nsprefix_) else ''
            self.ParameterInstanceRef.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='ParameterInstanceRef', pretty_print=pretty_print)
        if self.Value is not None:
            namespaceprefix_ = self.Value_nsprefix_ + ':' if (UseCapturedNS_ and self.Value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(ComparisonCheckType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ComparisonOperator':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ComparisonOperator')
            value_ = self.gds_validate_string(value_, node, 'ComparisonOperator')
            self.ComparisonOperator = value_
            self.ComparisonOperator_nsprefix_ = child_.prefix
            # validate type ComparisonOperatorsType
            self.validate_ComparisonOperatorsType(self.ComparisonOperator)
        elif nodeName_ == 'ParameterInstanceRef':
            class_obj_ = self.get_class_obj_(child_, ParameterInstanceRefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterInstanceRef = obj_
            obj_.original_tagname_ = 'ParameterInstanceRef'
        elif nodeName_ == 'Value':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Value')
            value_ = self.gds_validate_string(value_, node, 'Value')
            self.Value = value_
            self.Value_nsprefix_ = child_.prefix
        super(ComparisonCheckType, self).buildChildren(child_, node, nodeName_, True)


# end class ComparisonCheckType


class ComparisonListType(GeneratedsSuper):
    """All comparisons must be true"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Comparison=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Comparison is None:
            self.Comparison = []
        else:
            self.Comparison = Comparison
        self.Comparison_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComparisonListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComparisonListType.subclass:
            return ComparisonListType.subclass(*args_, **kwargs_)
        else:
            return ComparisonListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Comparison(self):
        return self.Comparison

    def set_Comparison(self, Comparison):
        self.Comparison = Comparison

    def add_Comparison(self, value):
        self.Comparison.append(value)

    def insert_Comparison_at(self, index, value):
        self.Comparison.insert(index, value)

    def replace_Comparison_at(self, index, value):
        self.Comparison[index] = value

    def hasContent_(self):
        if (
                self.Comparison
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ComparisonListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ComparisonListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ComparisonListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ComparisonListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ComparisonListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ComparisonListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ComparisonListType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Comparison_ in self.Comparison:
            namespaceprefix_ = self.Comparison_nsprefix_ + ':' if (UseCapturedNS_ and self.Comparison_nsprefix_) else ''
            Comparison_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comparison',
                               pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Comparison':
            obj_ = ComparisonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comparison.append(obj_)
            obj_.original_tagname_ = 'Comparison'


# end class ComparisonListType


class ContextCalibratorType(GeneratedsSuper):
    """Context calibrations are applied when the ContextMatch is true. Context
    calibrators overide Default calibrators"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ContextMatch=None, Calibrator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ContextMatch = ContextMatch
        self.ContextMatch_nsprefix_ = None
        self.Calibrator = Calibrator
        self.Calibrator_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContextCalibratorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContextCalibratorType.subclass:
            return ContextCalibratorType.subclass(*args_, **kwargs_)
        else:
            return ContextCalibratorType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextMatch(self):
        return self.ContextMatch

    def set_ContextMatch(self, ContextMatch):
        self.ContextMatch = ContextMatch

    def get_Calibrator(self):
        return self.Calibrator

    def set_Calibrator(self, Calibrator):
        self.Calibrator = Calibrator

    def hasContent_(self):
        if (
                self.ContextMatch is not None or
                self.Calibrator is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ContextCalibratorType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContextCalibratorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContextCalibratorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContextCalibratorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContextCalibratorType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContextCalibratorType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ContextCalibratorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContextMatch is not None:
            namespaceprefix_ = self.ContextMatch_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextMatch_nsprefix_) else ''
            self.ContextMatch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextMatch',
                                     pretty_print=pretty_print)
        if self.Calibrator is not None:
            namespaceprefix_ = self.Calibrator_nsprefix_ + ':' if (UseCapturedNS_ and self.Calibrator_nsprefix_) else ''
            self.Calibrator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Calibrator',
                                   pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextMatch':
            obj_ = ContextMatchType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextMatch = obj_
            obj_.original_tagname_ = 'ContextMatch'
        elif nodeName_ == 'Calibrator':
            obj_ = CalibratorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Calibrator = obj_
            obj_.original_tagname_ = 'Calibrator'


# end class ContextCalibratorType


class CustomAlarmType(BaseAlarmType):
    """Describe a custom, algorithmic alarm condition. The algorithm is assumed
    to return a boolean value: true or false. See AlarmType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseAlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, InputAlgorithm=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CustomAlarmType, self).__init__(name, shortDescription, AncillaryDataSet, **kwargs_)
        self.InputAlgorithm = InputAlgorithm
        self.InputAlgorithm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomAlarmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomAlarmType.subclass:
            return CustomAlarmType.subclass(*args_, **kwargs_)
        else:
            return CustomAlarmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_InputAlgorithm(self):
        return self.InputAlgorithm

    def set_InputAlgorithm(self, InputAlgorithm):
        self.InputAlgorithm = InputAlgorithm

    def hasContent_(self):
        if (
                self.InputAlgorithm is not None or
                super(CustomAlarmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='CustomAlarmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomAlarmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomAlarmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomAlarmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomAlarmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CustomAlarmType'):
        super(CustomAlarmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                      name_='CustomAlarmType')

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='CustomAlarmType',
                       fromsubclass_=False, pretty_print=True):
        super(CustomAlarmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                    pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InputAlgorithm is not None:
            namespaceprefix_ = self.InputAlgorithm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.InputAlgorithm_nsprefix_) else ''
            self.InputAlgorithm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InputAlgorithm',
                                       pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(CustomAlarmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'InputAlgorithm':
            class_obj_ = self.get_class_obj_(child_, InputAlgorithmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InputAlgorithm = obj_
            obj_.original_tagname_ = 'InputAlgorithm'
        super(CustomAlarmType, self).buildChildren(child_, node, nodeName_, True)


# end class CustomAlarmType


class PercentCompleteType(GeneratedsSuper):
    """Describe a percentage complete that is fixed from 0 to 100, or as value
    from a parameter. See ExecutionVerifierType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, FixedValue=None, DynamicValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.FixedValue = FixedValue
        self.validate_FixedValueType(self.FixedValue)
        self.FixedValue_nsprefix_ = None
        self.DynamicValue = DynamicValue
        self.DynamicValue_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PercentCompleteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PercentCompleteType.subclass:
            return PercentCompleteType.subclass(*args_, **kwargs_)
        else:
            return PercentCompleteType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_FixedValue(self):
        return self.FixedValue

    def set_FixedValue(self, FixedValue):
        self.FixedValue = FixedValue

    def get_DynamicValue(self):
        return self.DynamicValue

    def set_DynamicValue(self, DynamicValue):
        self.DynamicValue = DynamicValue

    def validate_FixedValueType(self, value):
        result = True
        # Validate type FixedValueType, a restriction on double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value,
                                                                                                    "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on FixedValueType' % {
                        "value": value, "lineno": lineno})
                result = False
            if value > 100.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on FixedValueType' % {
                        "value": value, "lineno": lineno})
                result = False
        return result

    def hasContent_(self):
        if (
                self.FixedValue is not None or
                self.DynamicValue is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
               name_='PercentCompleteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PercentCompleteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PercentCompleteType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PercentCompleteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PercentCompleteType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PercentCompleteType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
                       name_='PercentCompleteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FixedValue is not None:
            namespaceprefix_ = self.FixedValue_nsprefix_ + ':' if (UseCapturedNS_ and self.FixedValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFixedValue>%s</%sFixedValue>%s' % (
            namespaceprefix_, self.gds_format_double(self.FixedValue, input_name='FixedValue'), namespaceprefix_, eol_))
        if self.DynamicValue is not None:
            namespaceprefix_ = self.DynamicValue_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DynamicValue_nsprefix_) else ''
            self.DynamicValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DynamicValue',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FixedValue' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'FixedValue')
            fval_ = self.gds_validate_double(fval_, node, 'FixedValue')
            self.FixedValue = fval_
            self.FixedValue_nsprefix_ = child_.prefix
            # validate type FixedValueType
            self.validate_FixedValueType(self.FixedValue)
        elif nodeName_ == 'DynamicValue':
            obj_ = DynamicValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DynamicValue = obj_
            obj_.original_tagname_ = 'DynamicValue'


# end class PercentCompleteType


class DescriptionType(GeneratedsSuper):
    """Defines an abstract schema type used as basis for NameDescriptionType
    and OptionalNameDescriptionType, includes an attribute for a short
    description and an element for a longer unbounded description. This
    type also provides alias set and ancillary data set See AliasSetType
    and AncillaryDataSetType.Optional short description to be used for
    explanation of this item. It is recommended that the short description
    be kept under 80 characters in length."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None,
                 extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.shortDescription = _cast(None, shortDescription)
        self.shortDescription_nsprefix_ = None
        self.LongDescription = LongDescription
        self.validate_LongDescriptionType(self.LongDescription)
        self.LongDescription_nsprefix_ = None
        self.AliasSet = AliasSet
        self.AliasSet_nsprefix_ = None
        self.AncillaryDataSet = AncillaryDataSet
        self.AncillaryDataSet_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DescriptionType.subclass:
            return DescriptionType.subclass(*args_, **kwargs_)
        else:
            return DescriptionType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_LongDescription(self):
        return self.LongDescription

    def set_LongDescription(self, LongDescription):
        self.LongDescription = LongDescription

    def get_AliasSet(self):
        return self.AliasSet

    def set_AliasSet(self, AliasSet):
        self.AliasSet = AliasSet

    def get_AncillaryDataSet(self):
        return self.AncillaryDataSet

    def set_AncillaryDataSet(self, AncillaryDataSet):
        self.AncillaryDataSet = AncillaryDataSet

    def get_shortDescription(self):
        return self.shortDescription

    def set_shortDescription(self, shortDescription):
        self.shortDescription = shortDescription

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_LongDescriptionType(self, value):
        result = True
        # Validate type LongDescriptionType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            pass
        return result

    def validate_ShortDescriptionType(self, value):
        # Validate type xtce:ShortDescriptionType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            pass

    def hasContent_(self):
        if (
                self.LongDescription is not None or
                self.AliasSet is not None or
                self.AncillaryDataSet is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='DescriptionType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DescriptionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DescriptionType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DescriptionType'):
        if self.shortDescription is not None and 'shortDescription' not in already_processed:
            already_processed.add('shortDescription')
            outfile.write(' shortDescription=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.shortDescription), input_name='shortDescription')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='DescriptionType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LongDescription is not None:
            namespaceprefix_ = self.LongDescription_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.LongDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLongDescription>%s</%sLongDescription>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.LongDescription), input_name='LongDescription')),
                                                                           namespaceprefix_, eol_))
        if self.AliasSet is not None:
            namespaceprefix_ = self.AliasSet_nsprefix_ + ':' if (UseCapturedNS_ and self.AliasSet_nsprefix_) else ''
            self.AliasSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AliasSet',
                                 pretty_print=pretty_print)
        if self.AncillaryDataSet is not None:
            namespaceprefix_ = self.AncillaryDataSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AncillaryDataSet_nsprefix_) else ''
            self.AncillaryDataSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AncillaryDataSet',
                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('shortDescription', node)
        if value is not None and 'shortDescription' not in already_processed:
            already_processed.add('shortDescription')
            self.shortDescription = value
            self.validate_ShortDescriptionType(self.shortDescription)  # validate type ShortDescriptionType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LongDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LongDescription')
            value_ = self.gds_validate_string(value_, node, 'LongDescription')
            self.LongDescription = value_
            self.LongDescription_nsprefix_ = child_.prefix
            # validate type LongDescriptionType
            self.validate_LongDescriptionType(self.LongDescription)
        elif nodeName_ == 'AliasSet':
            obj_ = AliasSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AliasSet = obj_
            obj_.original_tagname_ = 'AliasSet'
        elif nodeName_ == 'AncillaryDataSet':
            obj_ = AncillaryDataSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AncillaryDataSet = obj_
            obj_.original_tagname_ = 'AncillaryDataSet'


# end class DescriptionType


class DiscreteLookupListType(GeneratedsSuper):
    """Describe an ordered table of integer values and associated conditions,
    forming a lookup table. The list may have duplicates. The table is
    evaluated from first to last, the first condition to be true returns
    the value associated with it. See DiscreteLookupType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, DiscreteLookup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DiscreteLookup is None:
            self.DiscreteLookup = []
        else:
            self.DiscreteLookup = DiscreteLookup
        self.DiscreteLookup_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiscreteLookupListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiscreteLookupListType.subclass:
            return DiscreteLookupListType.subclass(*args_, **kwargs_)
        else:
            return DiscreteLookupListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DiscreteLookup(self):
        return self.DiscreteLookup

    def set_DiscreteLookup(self, DiscreteLookup):
        self.DiscreteLookup = DiscreteLookup

    def add_DiscreteLookup(self, value):
        self.DiscreteLookup.append(value)

    def insert_DiscreteLookup_at(self, index, value):
        self.DiscreteLookup.insert(index, value)

    def replace_DiscreteLookup_at(self, index, value):
        self.DiscreteLookup[index] = value

    def hasContent_(self):
        if (
                self.DiscreteLookup
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='DiscreteLookupListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DiscreteLookupListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DiscreteLookupListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DiscreteLookupListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DiscreteLookupListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DiscreteLookupListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='DiscreteLookupListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DiscreteLookup_ in self.DiscreteLookup:
            namespaceprefix_ = self.DiscreteLookup_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DiscreteLookup_nsprefix_) else ''
            DiscreteLookup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DiscreteLookup',
                                   pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DiscreteLookup':
            obj_ = DiscreteLookupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DiscreteLookup.append(obj_)
            obj_.original_tagname_ = 'DiscreteLookup'


# end class DiscreteLookupListType


class DynamicValueType(GeneratedsSuper):
    """Uses a parameter instance to obtain the value. The parameter value may
    be optionally adjusted by a Linear function or use a series of boolean
    expressions to lookup the value. Anything more complex and a
    DynamicValue with a CustomAlgorithm may be used"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ParameterInstanceRef=None, LinearAdjustment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ParameterInstanceRef = ParameterInstanceRef
        self.ParameterInstanceRef_nsprefix_ = None
        self.LinearAdjustment = LinearAdjustment
        self.LinearAdjustment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DynamicValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DynamicValueType.subclass:
            return DynamicValueType.subclass(*args_, **kwargs_)
        else:
            return DynamicValueType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ParameterInstanceRef(self):
        return self.ParameterInstanceRef

    def set_ParameterInstanceRef(self, ParameterInstanceRef):
        self.ParameterInstanceRef = ParameterInstanceRef

    def get_LinearAdjustment(self):
        return self.LinearAdjustment

    def set_LinearAdjustment(self, LinearAdjustment):
        self.LinearAdjustment = LinearAdjustment

    def hasContent_(self):
        if (
                self.ParameterInstanceRef is not None or
                self.LinearAdjustment is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='DynamicValueType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DynamicValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DynamicValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DynamicValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DynamicValueType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DynamicValueType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='DynamicValueType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ParameterInstanceRef is not None:
            namespaceprefix_ = self.ParameterInstanceRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterInstanceRef_nsprefix_) else ''
            self.ParameterInstanceRef.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='ParameterInstanceRef', pretty_print=pretty_print)
        if self.LinearAdjustment is not None:
            namespaceprefix_ = self.LinearAdjustment_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.LinearAdjustment_nsprefix_) else ''
            self.LinearAdjustment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LinearAdjustment',
                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ParameterInstanceRef':
            class_obj_ = self.get_class_obj_(child_, ParameterInstanceRefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterInstanceRef = obj_
            obj_.original_tagname_ = 'ParameterInstanceRef'
        elif nodeName_ == 'LinearAdjustment':
            obj_ = LinearAdjustmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LinearAdjustment = obj_
            obj_.original_tagname_ = 'LinearAdjustment'


# end class DynamicValueType


class ErrorDetectCorrectType(GeneratedsSuper):
    """Describe error detection/correction algorithm."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Checksum=None, CRC=None, Parity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Checksum = Checksum
        self.Checksum_nsprefix_ = None
        self.CRC = CRC
        self.CRC_nsprefix_ = None
        self.Parity = Parity
        self.Parity_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ErrorDetectCorrectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ErrorDetectCorrectType.subclass:
            return ErrorDetectCorrectType.subclass(*args_, **kwargs_)
        else:
            return ErrorDetectCorrectType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Checksum(self):
        return self.Checksum

    def set_Checksum(self, Checksum):
        self.Checksum = Checksum

    def get_CRC(self):
        return self.CRC

    def set_CRC(self, CRC):
        self.CRC = CRC

    def get_Parity(self):
        return self.Parity

    def set_Parity(self, Parity):
        self.Parity = Parity

    def hasContent_(self):
        if (
                self.Checksum is not None or
                self.CRC is not None or
                self.Parity is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ErrorDetectCorrectType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ErrorDetectCorrectType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ErrorDetectCorrectType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ErrorDetectCorrectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ErrorDetectCorrectType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ErrorDetectCorrectType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ErrorDetectCorrectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Checksum is not None:
            namespaceprefix_ = self.Checksum_nsprefix_ + ':' if (UseCapturedNS_ and self.Checksum_nsprefix_) else ''
            self.Checksum.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Checksum',
                                 pretty_print=pretty_print)
        if self.CRC is not None:
            namespaceprefix_ = self.CRC_nsprefix_ + ':' if (UseCapturedNS_ and self.CRC_nsprefix_) else ''
            self.CRC.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CRC', pretty_print=pretty_print)
        if self.Parity is not None:
            namespaceprefix_ = self.Parity_nsprefix_ + ':' if (UseCapturedNS_ and self.Parity_nsprefix_) else ''
            self.Parity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Parity',
                               pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Checksum':
            obj_ = ChecksumType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Checksum = obj_
            obj_.original_tagname_ = 'Checksum'
        elif nodeName_ == 'CRC':
            obj_ = CRCType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CRC = obj_
            obj_.original_tagname_ = 'CRC'
        elif nodeName_ == 'Parity':
            obj_ = ParityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Parity = obj_
            obj_.original_tagname_ = 'Parity'


# end class ErrorDetectCorrectType


class HeaderType(GeneratedsSuper):
    """Schema for a Header record. A header contains general information about
    the system or subsystem.This attribute contains an optional version
    descriptor for this document.This attribute contains an optional date
    to be associated with this document.This attribute contains optional
    classification status for use by programs for which that is
    applicable.This attribute contains an optional additional instructions
    attribute to be interpreted by programs that use this attribute.This
    attribute contains a flag describing the state of this document in the
    evolution of the project using it."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, version=None, date=None, classification='NotClassified', classificationInstructions=None,
                 validationStatus=None, AuthorSet=None, NoteSet=None, HistorySet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.date = _cast(None, date)
        self.date_nsprefix_ = None
        self.classification = _cast(None, classification)
        self.classification_nsprefix_ = None
        self.classificationInstructions = _cast(None, classificationInstructions)
        self.classificationInstructions_nsprefix_ = None
        self.validationStatus = _cast(None, validationStatus)
        self.validationStatus_nsprefix_ = None
        self.AuthorSet = AuthorSet
        self.AuthorSet_nsprefix_ = None
        self.NoteSet = NoteSet
        self.NoteSet_nsprefix_ = None
        self.HistorySet = HistorySet
        self.HistorySet_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeaderType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeaderType.subclass:
            return HeaderType.subclass(*args_, **kwargs_)
        else:
            return HeaderType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AuthorSet(self):
        return self.AuthorSet

    def set_AuthorSet(self, AuthorSet):
        self.AuthorSet = AuthorSet

    def get_NoteSet(self):
        return self.NoteSet

    def set_NoteSet(self, NoteSet):
        self.NoteSet = NoteSet

    def get_HistorySet(self):
        return self.HistorySet

    def set_HistorySet(self, HistorySet):
        self.HistorySet = HistorySet

    def get_version(self):
        return self.version

    def set_version(self, version):
        self.version = version

    def get_date(self):
        return self.date

    def set_date(self, date):
        self.date = date

    def get_classification(self):
        return self.classification

    def set_classification(self, classification):
        self.classification = classification

    def get_classificationInstructions(self):
        return self.classificationInstructions

    def set_classificationInstructions(self, classificationInstructions):
        self.classificationInstructions = classificationInstructions

    def get_validationStatus(self):
        return self.validationStatus

    def set_validationStatus(self, validationStatus):
        self.validationStatus = validationStatus

    def validate_ValidationStatusType(self, value):
        # Validate type xtce:ValidationStatusType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['Unknown', 'Working', 'Draft', 'Test', 'Validated', 'Released', 'Withdrawn']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ValidationStatusType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.AuthorSet is not None or
                self.NoteSet is not None or
                self.HistorySet is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='HeaderType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HeaderType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HeaderType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HeaderType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HeaderType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HeaderType'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')),))
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(
                ' date=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.date), input_name='date')),))
        if self.classification != "NotClassified" and 'classification' not in already_processed:
            already_processed.add('classification')
            outfile.write(' classification=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.classification), input_name='classification')),))
        if self.classificationInstructions is not None and 'classificationInstructions' not in already_processed:
            already_processed.add('classificationInstructions')
            outfile.write(' classificationInstructions=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.classificationInstructions),
                                       input_name='classificationInstructions')),))
        if self.validationStatus is not None and 'validationStatus' not in already_processed:
            already_processed.add('validationStatus')
            outfile.write(' validationStatus=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.validationStatus), input_name='validationStatus')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='HeaderType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AuthorSet is not None:
            namespaceprefix_ = self.AuthorSet_nsprefix_ + ':' if (UseCapturedNS_ and self.AuthorSet_nsprefix_) else ''
            self.AuthorSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AuthorSet',
                                  pretty_print=pretty_print)
        if self.NoteSet is not None:
            namespaceprefix_ = self.NoteSet_nsprefix_ + ':' if (UseCapturedNS_ and self.NoteSet_nsprefix_) else ''
            self.NoteSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NoteSet',
                                pretty_print=pretty_print)
        if self.HistorySet is not None:
            namespaceprefix_ = self.HistorySet_nsprefix_ + ':' if (UseCapturedNS_ and self.HistorySet_nsprefix_) else ''
            self.HistorySet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HistorySet',
                                   pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            self.date = value
        value = find_attr_value_('classification', node)
        if value is not None and 'classification' not in already_processed:
            already_processed.add('classification')
            self.classification = value
        value = find_attr_value_('classificationInstructions', node)
        if value is not None and 'classificationInstructions' not in already_processed:
            already_processed.add('classificationInstructions')
            self.classificationInstructions = value
        value = find_attr_value_('validationStatus', node)
        if value is not None and 'validationStatus' not in already_processed:
            already_processed.add('validationStatus')
            self.validationStatus = value
            self.validate_ValidationStatusType(self.validationStatus)  # validate type ValidationStatusType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AuthorSet':
            obj_ = AuthorSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AuthorSet = obj_
            obj_.original_tagname_ = 'AuthorSet'
        elif nodeName_ == 'NoteSet':
            obj_ = NoteSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NoteSet = obj_
            obj_.original_tagname_ = 'NoteSet'
        elif nodeName_ == 'HistorySet':
            obj_ = HistorySetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HistorySet = obj_
            obj_.original_tagname_ = 'HistorySet'


# end class HeaderType


class HistorySetType(GeneratedsSuper):
    """Describe an unordered collection of History elements. Usage is user
    defined. See HistoryType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, History=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if History is None:
            self.History = []
        else:
            self.History = History
        self.History_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HistorySetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HistorySetType.subclass:
            return HistorySetType.subclass(*args_, **kwargs_)
        else:
            return HistorySetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_History(self):
        return self.History

    def set_History(self, History):
        self.History = History

    def add_History(self, value):
        self.History.append(value)

    def insert_History_at(self, index, value):
        self.History.insert(index, value)

    def replace_History_at(self, index, value):
        self.History[index] = value

    def validate_HistoryType(self, value):
        result = True
        # Validate type HistoryType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            pass
        return result

    def hasContent_(self):
        if (
                self.History
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='HistorySetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HistorySetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HistorySetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HistorySetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HistorySetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HistorySetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='HistorySetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for History_ in self.History:
            namespaceprefix_ = self.History_nsprefix_ + ':' if (UseCapturedNS_ and self.History_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHistory>%s</%sHistory>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(History_), input_name='History')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'History':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'History')
            value_ = self.gds_validate_string(value_, node, 'History')
            self.History.append(value_)
            self.History_nsprefix_ = child_.prefix
            # validate type HistoryType
            self.validate_HistoryType(self.History[-1])


# end class HistorySetType


class IntegerValueType(GeneratedsSuper):
    """Contains an Integer value; value may be provided directly or via the
    value in a parameter."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, FixedValue=None, DynamicValue=None, DiscreteLookupList=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.FixedValue = FixedValue
        self.FixedValue_nsprefix_ = None
        self.DynamicValue = DynamicValue
        self.DynamicValue_nsprefix_ = None
        self.DiscreteLookupList = DiscreteLookupList
        self.DiscreteLookupList_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntegerValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntegerValueType.subclass:
            return IntegerValueType.subclass(*args_, **kwargs_)
        else:
            return IntegerValueType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_FixedValue(self):
        return self.FixedValue

    def set_FixedValue(self, FixedValue):
        self.FixedValue = FixedValue

    def get_DynamicValue(self):
        return self.DynamicValue

    def set_DynamicValue(self, DynamicValue):
        self.DynamicValue = DynamicValue

    def get_DiscreteLookupList(self):
        return self.DiscreteLookupList

    def set_DiscreteLookupList(self, DiscreteLookupList):
        self.DiscreteLookupList = DiscreteLookupList

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.FixedValue is not None or
                self.DynamicValue is not None or
                self.DiscreteLookupList is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
               name_='IntegerValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IntegerValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IntegerValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IntegerValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IntegerValueType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IntegerValueType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
                       name_='IntegerValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FixedValue is not None:
            namespaceprefix_ = self.FixedValue_nsprefix_ + ':' if (UseCapturedNS_ and self.FixedValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFixedValue>%s</%sFixedValue>%s' % (
            namespaceprefix_, self.gds_format_integer(self.FixedValue, input_name='FixedValue'), namespaceprefix_,
            eol_))
        if self.DynamicValue is not None:
            namespaceprefix_ = self.DynamicValue_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DynamicValue_nsprefix_) else ''
            self.DynamicValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DynamicValue',
                                     pretty_print=pretty_print)
        if self.DiscreteLookupList is not None:
            namespaceprefix_ = self.DiscreteLookupList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DiscreteLookupList_nsprefix_) else ''
            self.DiscreteLookupList.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='DiscreteLookupList', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FixedValue' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'FixedValue')
            ival_ = self.gds_validate_integer(ival_, node, 'FixedValue')
            self.FixedValue = ival_
            self.FixedValue_nsprefix_ = child_.prefix
        elif nodeName_ == 'DynamicValue':
            obj_ = DynamicValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DynamicValue = obj_
            obj_.original_tagname_ = 'DynamicValue'
        elif nodeName_ == 'DiscreteLookupList':
            obj_ = DiscreteLookupListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DiscreteLookupList = obj_
            obj_.original_tagname_ = 'DiscreteLookupList'


# end class IntegerValueType


class ArgumentIntegerValueType(GeneratedsSuper):
    """Identical to IntegerValueType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, FixedValue=None, DynamicValue=None, DiscreteLookupList=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.FixedValue = FixedValue
        self.FixedValue_nsprefix_ = None
        self.DynamicValue = DynamicValue
        self.DynamicValue_nsprefix_ = None
        self.DiscreteLookupList = DiscreteLookupList
        self.DiscreteLookupList_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentIntegerValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentIntegerValueType.subclass:
            return ArgumentIntegerValueType.subclass(*args_, **kwargs_)
        else:
            return ArgumentIntegerValueType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_FixedValue(self):
        return self.FixedValue

    def set_FixedValue(self, FixedValue):
        self.FixedValue = FixedValue

    def get_DynamicValue(self):
        return self.DynamicValue

    def set_DynamicValue(self, DynamicValue):
        self.DynamicValue = DynamicValue

    def get_DiscreteLookupList(self):
        return self.DiscreteLookupList

    def set_DiscreteLookupList(self, DiscreteLookupList):
        self.DiscreteLookupList = DiscreteLookupList

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.FixedValue is not None or
                self.DynamicValue is not None or
                self.DiscreteLookupList is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
               name_='ArgumentIntegerValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentIntegerValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentIntegerValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentIntegerValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentIntegerValueType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentIntegerValueType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204" xmlns:None="http://www.w3.org/2001/XMLSchema" ',
                       name_='ArgumentIntegerValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FixedValue is not None:
            namespaceprefix_ = self.FixedValue_nsprefix_ + ':' if (UseCapturedNS_ and self.FixedValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFixedValue>%s</%sFixedValue>%s' % (
            namespaceprefix_, self.gds_format_integer(self.FixedValue, input_name='FixedValue'), namespaceprefix_,
            eol_))
        if self.DynamicValue is not None:
            namespaceprefix_ = self.DynamicValue_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DynamicValue_nsprefix_) else ''
            self.DynamicValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DynamicValue',
                                     pretty_print=pretty_print)
        if self.DiscreteLookupList is not None:
            namespaceprefix_ = self.DiscreteLookupList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DiscreteLookupList_nsprefix_) else ''
            self.DiscreteLookupList.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='DiscreteLookupList', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FixedValue' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'FixedValue')
            ival_ = self.gds_validate_integer(ival_, node, 'FixedValue')
            self.FixedValue = ival_
            self.FixedValue_nsprefix_ = child_.prefix
        elif nodeName_ == 'DynamicValue':
            obj_ = ArgumentDynamicValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DynamicValue = obj_
            obj_.original_tagname_ = 'DynamicValue'
        elif nodeName_ == 'DiscreteLookupList':
            obj_ = ArgumentDiscreteLookupListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DiscreteLookupList = obj_
            obj_.original_tagname_ = 'DiscreteLookupList'


# end class ArgumentIntegerValueType


class MatchCriteriaType(GeneratedsSuper):
    """Contains either a simple Comparison, a ComparisonList, an arbitrarily
    complex BooleanExpression or an escape to an externally defined
    algorithm"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Comparison=None, ComparisonList=None, BooleanExpression=None, CustomAlgorithm=None,
                 extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Comparison = Comparison
        self.Comparison_nsprefix_ = None
        self.ComparisonList = ComparisonList
        self.ComparisonList_nsprefix_ = None
        self.BooleanExpression = BooleanExpression
        self.BooleanExpression_nsprefix_ = None
        self.CustomAlgorithm = CustomAlgorithm
        self.CustomAlgorithm_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MatchCriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MatchCriteriaType.subclass:
            return MatchCriteriaType.subclass(*args_, **kwargs_)
        else:
            return MatchCriteriaType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Comparison(self):
        return self.Comparison

    def set_Comparison(self, Comparison):
        self.Comparison = Comparison

    def get_ComparisonList(self):
        return self.ComparisonList

    def set_ComparisonList(self, ComparisonList):
        self.ComparisonList = ComparisonList

    def get_BooleanExpression(self):
        return self.BooleanExpression

    def set_BooleanExpression(self, BooleanExpression):
        self.BooleanExpression = BooleanExpression

    def get_CustomAlgorithm(self):
        return self.CustomAlgorithm

    def set_CustomAlgorithm(self, CustomAlgorithm):
        self.CustomAlgorithm = CustomAlgorithm

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.Comparison is not None or
                self.ComparisonList is not None or
                self.BooleanExpression is not None or
                self.CustomAlgorithm is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MatchCriteriaType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MatchCriteriaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MatchCriteriaType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MatchCriteriaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MatchCriteriaType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MatchCriteriaType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MatchCriteriaType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comparison is not None:
            namespaceprefix_ = self.Comparison_nsprefix_ + ':' if (UseCapturedNS_ and self.Comparison_nsprefix_) else ''
            self.Comparison.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comparison',
                                   pretty_print=pretty_print)
        if self.ComparisonList is not None:
            namespaceprefix_ = self.ComparisonList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ComparisonList_nsprefix_) else ''
            self.ComparisonList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ComparisonList',
                                       pretty_print=pretty_print)
        if self.BooleanExpression is not None:
            namespaceprefix_ = self.BooleanExpression_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BooleanExpression_nsprefix_) else ''
            self.BooleanExpression.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BooleanExpression',
                                          pretty_print=pretty_print)
        if self.CustomAlgorithm is not None:
            namespaceprefix_ = self.CustomAlgorithm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CustomAlgorithm_nsprefix_) else ''
            self.CustomAlgorithm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CustomAlgorithm',
                                        pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Comparison':
            obj_ = ComparisonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comparison = obj_
            obj_.original_tagname_ = 'Comparison'
        elif nodeName_ == 'ComparisonList':
            obj_ = ComparisonListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ComparisonList = obj_
            obj_.original_tagname_ = 'ComparisonList'
        elif nodeName_ == 'BooleanExpression':
            obj_ = BooleanExpressionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BooleanExpression = obj_
            obj_.original_tagname_ = 'BooleanExpression'
        elif nodeName_ == 'CustomAlgorithm':
            class_obj_ = self.get_class_obj_(child_, InputAlgorithmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CustomAlgorithm = obj_
            obj_.original_tagname_ = 'CustomAlgorithm'


# end class MatchCriteriaType


class MathOperationType(MathOperationCalibratorType):
    """Postfix (aka Reverse Polish Notation (RPN)) notation is used to describe
    mathmatical equations. It uses a stack where operands (either fixed
    values or ParameterInstances) are pushed onto the stack from first to
    last in the XML. As the operators are specified, each pops off operands
    as it evaluates them, and pushes the result back onto the stack. In
    this case postfix is used to avoid having to specify parenthesis. To
    convert from infix to postfix, use Dijkstra's "shunting yard"
    algorithm."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MathOperationCalibratorType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, ValueOperand=None,
                 ThisParameterOperand=None, Operator=None, ParameterInstanceRefOperand=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MathOperationType, self).__init__(name, shortDescription, AncillaryDataSet, ValueOperand,
                                                ThisParameterOperand, Operator, ParameterInstanceRefOperand,
                                                extensiontype_, **kwargs_)
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MathOperationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MathOperationType.subclass:
            return MathOperationType.subclass(*args_, **kwargs_)
        else:
            return MathOperationType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                super(MathOperationType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MathOperationType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MathOperationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MathOperationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MathOperationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MathOperationType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MathOperationType'):
        super(MathOperationType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                        name_='MathOperationType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MathOperationType',
                       fromsubclass_=False, pretty_print=True):
        super(MathOperationType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(MathOperationType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(MathOperationType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class MathOperationType


class NameDescriptionType(DescriptionType):
    """Defines a base schema type definition used by many other schema types
    throughout schema. Use it to describe a name with optional
    descriptions, aliases, and ancillary data. See NameType,
    LongDescriptionType, ShortDescriptionType, AliasSetType and
    AncillaryDataSetType.The name of this defined item. See NameType for
    restriction information."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.qualified_name = None
        super(NameDescriptionType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                  extensiontype_, **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameDescriptionType.subclass:
            return NameDescriptionType.subclass(*args_, **kwargs_)
        else:
            return NameDescriptionType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def set_qualified_name(self, q_name):
        self.qualified_name = q_name

    def get_qualified_name(self):
        return self.qualified_name

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_name(self):
        return self.name

    def set_name(self, name):
        self.name = name

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_NameType(self, value):
        # Validate type xtce:NameType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameType_patterns_,))

    validate_NameType_patterns_ = [['^([^./:\\[\\] ]+)$']]

    def hasContent_(self):
        if (
                super(NameDescriptionType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='NameDescriptionType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NameDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NameDescriptionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NameDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NameDescriptionType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NameDescriptionType'):
        super(NameDescriptionType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                          name_='NameDescriptionType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(
                ' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='NameDescriptionType',
                       fromsubclass_=False, pretty_print=True):
        super(NameDescriptionType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                        pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_NameType(self.name)  # validate type NameType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NameDescriptionType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(NameDescriptionType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class NameDescriptionType


class NoteSetType(GeneratedsSuper):
    """Contains an unordered collection of Notes. Usage is user defined. See
    NoteType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Note=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Note is None:
            self.Note = []
        else:
            self.Note = Note
        self.Note_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoteSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoteSetType.subclass:
            return NoteSetType.subclass(*args_, **kwargs_)
        else:
            return NoteSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Note(self):
        return self.Note

    def set_Note(self, Note):
        self.Note = Note

    def add_Note(self, value):
        self.Note.append(value)

    def insert_Note_at(self, index, value):
        self.Note.insert(index, value)

    def replace_Note_at(self, index, value):
        self.Note[index] = value

    def validate_NoteType(self, value):
        result = True
        # Validate type NoteType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            pass
        return result

    def hasContent_(self):
        if (
                self.Note
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='NoteSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NoteSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NoteSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoteSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NoteSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NoteSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='NoteSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Note_ in self.Note:
            namespaceprefix_ = self.Note_nsprefix_ + ':' if (UseCapturedNS_ and self.Note_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNote>%s</%sNote>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(Note_), input_name='Note')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Note':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Note')
            value_ = self.gds_validate_string(value_, node, 'Note')
            self.Note.append(value_)
            self.Note_nsprefix_ = child_.prefix
            # validate type NoteType
            self.validate_NoteType(self.Note[-1])


# end class NoteSetType


class NumberFormatType(GeneratedsSuper):
    """This type describes how a numeric value should be represented in
    engineering/calibrated form. The defaults reflect the most common
    form.Describes how the engineering/calibrated value of this number
    should be displayed with respect to the radix. Default is base
    10.Describes how the engineering/calibrated value of this number should
    be displayed with respect to the minimum number of fractional digits.
    The default is 0.Describes how the engineering/calibrated value of this
    number should be displayed with respect to the maximum or upper bound
    of the number of digits. There is no default. No value specified should
    be interpreted as no upper bound such that all requires digits are used
    to fully characterize the value.Describes how the
    engineering/calibrated value of this number should be displayed with
    respect to the minimum number of integer digits. The default is
    1.Describes how the engineering/calibrated value of this number should
    be displayed with respect to the maximum or upper bound of the integer
    digits. There is no default. No value specified should be interpreted
    as no upper bound such that all requires digits are used to fully
    characterize the value.Describes how the engineering/calibrated value
    of this number should be displayed with respect to negative values.
    This attribute specifies the character or characters that should be
    appended to the numeric value to indicate negative values. The default
    is none.Describes how the engineering/calibrated value of this number
    should be displayed with respect to positive values. This attribute
    specifies the character or characters that should be appended to the
    numeric value to indicate positive values. The default is none. Zero is
    considered to be specific to the implementation/platform and is not
    implied here.Describes how the engineering/calibrated value of this
    number should be displayed with respect to negative values. This
    attribute specifies the character or characters that should be
    prepended to the numeric value to indicate negative values. The default
    is a minus character "-".Describes how the engineering/calibrated value
    of this number should be displayed with respect to positive values.
    This attribute specifies the character or characters that should be
    prepended to the numeric value to indicate positive values. The default
    is none. Zero is considered to be specific to the
    implementation/platform and is not implied here.Describes how the
    engineering/calibrated value of this number should be displayed with
    respect to larger values. Groupings by thousand are specific to locale,
    so the schema only specifies whether they will be present and not which
    character separators are used. The default is false.Describes how the
    engineering/calibrated value of this number should be displayed with
    respect to notation. Engineering, scientific, or traditional decimal
    notation may be specified. The precise characters used is locale
    specific for the implementation/platform. The default is "normal" for
    the traditional notation."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, numberBase='Decimal', minimumFractionDigits='0', maximumFractionDigits=None,
                 minimumIntegerDigits='1', maximumIntegerDigits=None, negativeSuffix='', positiveSuffix='',
                 negativePrefix='-', positivePrefix='', showThousandsGrouping=False, notation='normal',
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.numberBase = _cast(None, numberBase)
        self.numberBase_nsprefix_ = None
        self.minimumFractionDigits = _cast(int, minimumFractionDigits)
        self.minimumFractionDigits_nsprefix_ = None
        self.maximumFractionDigits = _cast(int, maximumFractionDigits)
        self.maximumFractionDigits_nsprefix_ = None
        self.minimumIntegerDigits = _cast(int, minimumIntegerDigits)
        self.minimumIntegerDigits_nsprefix_ = None
        self.maximumIntegerDigits = _cast(int, maximumIntegerDigits)
        self.maximumIntegerDigits_nsprefix_ = None
        self.negativeSuffix = _cast(None, negativeSuffix)
        self.negativeSuffix_nsprefix_ = None
        self.positiveSuffix = _cast(None, positiveSuffix)
        self.positiveSuffix_nsprefix_ = None
        self.negativePrefix = _cast(None, negativePrefix)
        self.negativePrefix_nsprefix_ = None
        self.positivePrefix = _cast(None, positivePrefix)
        self.positivePrefix_nsprefix_ = None
        self.showThousandsGrouping = _cast(bool, showThousandsGrouping)
        self.showThousandsGrouping_nsprefix_ = None
        self.notation = _cast(None, notation)
        self.notation_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberFormatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberFormatType.subclass:
            return NumberFormatType.subclass(*args_, **kwargs_)
        else:
            return NumberFormatType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_numberBase(self):
        return self.numberBase

    def set_numberBase(self, numberBase):
        self.numberBase = numberBase

    def get_minimumFractionDigits(self):
        return self.minimumFractionDigits

    def set_minimumFractionDigits(self, minimumFractionDigits):
        self.minimumFractionDigits = minimumFractionDigits

    def get_maximumFractionDigits(self):
        return self.maximumFractionDigits

    def set_maximumFractionDigits(self, maximumFractionDigits):
        self.maximumFractionDigits = maximumFractionDigits

    def get_minimumIntegerDigits(self):
        return self.minimumIntegerDigits

    def set_minimumIntegerDigits(self, minimumIntegerDigits):
        self.minimumIntegerDigits = minimumIntegerDigits

    def get_maximumIntegerDigits(self):
        return self.maximumIntegerDigits

    def set_maximumIntegerDigits(self, maximumIntegerDigits):
        self.maximumIntegerDigits = maximumIntegerDigits

    def get_negativeSuffix(self):
        return self.negativeSuffix

    def set_negativeSuffix(self, negativeSuffix):
        self.negativeSuffix = negativeSuffix

    def get_positiveSuffix(self):
        return self.positiveSuffix

    def set_positiveSuffix(self, positiveSuffix):
        self.positiveSuffix = positiveSuffix

    def get_negativePrefix(self):
        return self.negativePrefix

    def set_negativePrefix(self, negativePrefix):
        self.negativePrefix = negativePrefix

    def get_positivePrefix(self):
        return self.positivePrefix

    def set_positivePrefix(self, positivePrefix):
        self.positivePrefix = positivePrefix

    def get_showThousandsGrouping(self):
        return self.showThousandsGrouping

    def set_showThousandsGrouping(self, showThousandsGrouping):
        self.showThousandsGrouping = showThousandsGrouping

    def get_notation(self):
        return self.notation

    def set_notation(self, notation):
        self.notation = notation

    def validate_RadixType(self, value):
        # Validate type xtce:RadixType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['Decimal', 'Hexadecimal', 'Octal', 'Binary']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RadixType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_NonNegativeLongType(self, value):
        # Validate type xtce:NonNegativeLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on NonNegativeLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def validate_FloatingPointNotationType(self, value):
        # Validate type xtce:FloatingPointNotationType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'scientific', 'engineering']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FloatingPointNotationType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='NumberFormatType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumberFormatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NumberFormatType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumberFormatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NumberFormatType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NumberFormatType'):
        if self.numberBase != "Decimal" and 'numberBase' not in already_processed:
            already_processed.add('numberBase')
            outfile.write(' numberBase=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.numberBase), input_name='numberBase')),))
        if self.minimumFractionDigits != 0 and 'minimumFractionDigits' not in already_processed:
            already_processed.add('minimumFractionDigits')
            outfile.write(' minimumFractionDigits="%s"' % self.gds_format_integer(self.minimumFractionDigits,
                                                                                  input_name='minimumFractionDigits'))
        if self.maximumFractionDigits is not None and 'maximumFractionDigits' not in already_processed:
            already_processed.add('maximumFractionDigits')
            outfile.write(' maximumFractionDigits="%s"' % self.gds_format_integer(self.maximumFractionDigits,
                                                                                  input_name='maximumFractionDigits'))
        if self.minimumIntegerDigits != 1 and 'minimumIntegerDigits' not in already_processed:
            already_processed.add('minimumIntegerDigits')
            outfile.write(' minimumIntegerDigits="%s"' % self.gds_format_integer(self.minimumIntegerDigits,
                                                                                 input_name='minimumIntegerDigits'))
        if self.maximumIntegerDigits is not None and 'maximumIntegerDigits' not in already_processed:
            already_processed.add('maximumIntegerDigits')
            outfile.write(' maximumIntegerDigits="%s"' % self.gds_format_integer(self.maximumIntegerDigits,
                                                                                 input_name='maximumIntegerDigits'))
        if self.negativeSuffix != "" and 'negativeSuffix' not in already_processed:
            already_processed.add('negativeSuffix')
            outfile.write(' negativeSuffix=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.negativeSuffix), input_name='negativeSuffix')),))
        if self.positiveSuffix != "" and 'positiveSuffix' not in already_processed:
            already_processed.add('positiveSuffix')
            outfile.write(' positiveSuffix=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.positiveSuffix), input_name='positiveSuffix')),))
        if self.negativePrefix != "-" and 'negativePrefix' not in already_processed:
            already_processed.add('negativePrefix')
            outfile.write(' negativePrefix=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.negativePrefix), input_name='negativePrefix')),))
        if self.positivePrefix != "" and 'positivePrefix' not in already_processed:
            already_processed.add('positivePrefix')
            outfile.write(' positivePrefix=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.positivePrefix), input_name='positivePrefix')),))
        if self.showThousandsGrouping and 'showThousandsGrouping' not in already_processed:
            already_processed.add('showThousandsGrouping')
            outfile.write(' showThousandsGrouping="%s"' % self.gds_format_boolean(self.showThousandsGrouping,
                                                                                  input_name='showThousandsGrouping'))
        if self.notation != "normal" and 'notation' not in already_processed:
            already_processed.add('notation')
            outfile.write(' notation=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.notation), input_name='notation')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='NumberFormatType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberBase', node)
        if value is not None and 'numberBase' not in already_processed:
            already_processed.add('numberBase')
            self.numberBase = value
            self.validate_RadixType(self.numberBase)  # validate type RadixType
        value = find_attr_value_('minimumFractionDigits', node)
        if value is not None and 'minimumFractionDigits' not in already_processed:
            already_processed.add('minimumFractionDigits')
            self.minimumFractionDigits = self.gds_parse_integer(value, node, 'minimumFractionDigits')
            self.validate_NonNegativeLongType(self.minimumFractionDigits)  # validate type NonNegativeLongType
        value = find_attr_value_('maximumFractionDigits', node)
        if value is not None and 'maximumFractionDigits' not in already_processed:
            already_processed.add('maximumFractionDigits')
            self.maximumFractionDigits = self.gds_parse_integer(value, node, 'maximumFractionDigits')
            self.validate_NonNegativeLongType(self.maximumFractionDigits)  # validate type NonNegativeLongType
        value = find_attr_value_('minimumIntegerDigits', node)
        if value is not None and 'minimumIntegerDigits' not in already_processed:
            already_processed.add('minimumIntegerDigits')
            self.minimumIntegerDigits = self.gds_parse_integer(value, node, 'minimumIntegerDigits')
            self.validate_NonNegativeLongType(self.minimumIntegerDigits)  # validate type NonNegativeLongType
        value = find_attr_value_('maximumIntegerDigits', node)
        if value is not None and 'maximumIntegerDigits' not in already_processed:
            already_processed.add('maximumIntegerDigits')
            self.maximumIntegerDigits = self.gds_parse_integer(value, node, 'maximumIntegerDigits')
            self.validate_NonNegativeLongType(self.maximumIntegerDigits)  # validate type NonNegativeLongType
        value = find_attr_value_('negativeSuffix', node)
        if value is not None and 'negativeSuffix' not in already_processed:
            already_processed.add('negativeSuffix')
            self.negativeSuffix = value
        value = find_attr_value_('positiveSuffix', node)
        if value is not None and 'positiveSuffix' not in already_processed:
            already_processed.add('positiveSuffix')
            self.positiveSuffix = value
        value = find_attr_value_('negativePrefix', node)
        if value is not None and 'negativePrefix' not in already_processed:
            already_processed.add('negativePrefix')
            self.negativePrefix = value
        value = find_attr_value_('positivePrefix', node)
        if value is not None and 'positivePrefix' not in already_processed:
            already_processed.add('positivePrefix')
            self.positivePrefix = value
        value = find_attr_value_('showThousandsGrouping', node)
        if value is not None and 'showThousandsGrouping' not in already_processed:
            already_processed.add('showThousandsGrouping')
            if value in ('true', '1'):
                self.showThousandsGrouping = True
            elif value in ('false', '0'):
                self.showThousandsGrouping = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('notation', node)
        if value is not None and 'notation' not in already_processed:
            already_processed.add('notation')
            self.notation = value
            self.validate_FloatingPointNotationType(self.notation)  # validate type FloatingPointNotationType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class NumberFormatType


class OptionalNameDescriptionType(DescriptionType):
    """The type definition used by most elements that have an optional name
    with optional descriptions.Optional name of this defined item. See
    NameType for restriction information."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(OptionalNameDescriptionType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                          extensiontype_, **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptionalNameDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptionalNameDescriptionType.subclass:
            return OptionalNameDescriptionType.subclass(*args_, **kwargs_)
        else:
            return OptionalNameDescriptionType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_name(self):
        return self.name

    def set_name(self, name):
        self.name = name

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_NameType(self, value):
        # Validate type xtce:NameType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameType_patterns_,))

    validate_NameType_patterns_ = [['^([^./:\\[\\] ]+)$']]

    def hasContent_(self):
        if (
                super(OptionalNameDescriptionType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='OptionalNameDescriptionType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OptionalNameDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OptionalNameDescriptionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OptionalNameDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='OptionalNameDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='OptionalNameDescriptionType'):
        super(OptionalNameDescriptionType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                  name_='OptionalNameDescriptionType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(
                ' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='OptionalNameDescriptionType', fromsubclass_=False, pretty_print=True):
        super(OptionalNameDescriptionType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                                True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_NameType(self.name)  # validate type NameType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(OptionalNameDescriptionType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(OptionalNameDescriptionType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class OptionalNameDescriptionType


class ORedConditionsType(BaseConditionsType):
    """Describe two or more conditions that are logically ored together.
    Conditions may be a mix of Condition and ANDedCondition. See
    ORedConditionType and BooleanExpressionType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseConditionsType

    def __init__(self, Condition=None, ANDedConditions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ORedConditionsType, self).__init__(**kwargs_)
        if Condition is None:
            self.Condition = []
        else:
            self.Condition = Condition
        self.Condition_nsprefix_ = None
        if ANDedConditions is None:
            self.ANDedConditions = []
        else:
            self.ANDedConditions = ANDedConditions
        self.ANDedConditions_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ORedConditionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ORedConditionsType.subclass:
            return ORedConditionsType.subclass(*args_, **kwargs_)
        else:
            return ORedConditionsType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Condition(self):
        return self.Condition

    def set_Condition(self, Condition):
        self.Condition = Condition

    def add_Condition(self, value):
        self.Condition.append(value)

    def insert_Condition_at(self, index, value):
        self.Condition.insert(index, value)

    def replace_Condition_at(self, index, value):
        self.Condition[index] = value

    def get_ANDedConditions(self):
        return self.ANDedConditions

    def set_ANDedConditions(self, ANDedConditions):
        self.ANDedConditions = ANDedConditions

    def add_ANDedConditions(self, value):
        self.ANDedConditions.append(value)

    def insert_ANDedConditions_at(self, index, value):
        self.ANDedConditions.insert(index, value)

    def replace_ANDedConditions_at(self, index, value):
        self.ANDedConditions[index] = value

    def hasContent_(self):
        if (
                self.Condition or
                self.ANDedConditions or
                super(ORedConditionsType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ORedConditionsType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ORedConditionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ORedConditionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ORedConditionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ORedConditionsType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ORedConditionsType'):
        super(ORedConditionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                         name_='ORedConditionsType')

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ORedConditionsType',
                       fromsubclass_=False, pretty_print=True):
        super(ORedConditionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                       pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Condition_ in self.Condition:
            namespaceprefix_ = self.Condition_nsprefix_ + ':' if (UseCapturedNS_ and self.Condition_nsprefix_) else ''
            Condition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Condition',
                              pretty_print=pretty_print)
        for ANDedConditions_ in self.ANDedConditions:
            namespaceprefix_ = self.ANDedConditions_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ANDedConditions_nsprefix_) else ''
            ANDedConditions_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANDedConditions',
                                    pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(ORedConditionsType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Condition':
            obj_ = ComparisonCheckType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Condition.append(obj_)
            obj_.original_tagname_ = 'Condition'
        elif nodeName_ == 'ANDedConditions':
            obj_ = ANDedConditionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANDedConditions.append(obj_)
            obj_.original_tagname_ = 'ANDedConditions'
        super(ORedConditionsType, self).buildChildren(child_, node, nodeName_, True)


# end class ORedConditionsType


class ParameterSetType(GeneratedsSuper):
    """Describe an unordered collection of parameters where duplicates defined
    by the Parameter name attribute are invalid. The ParameterSet exists in
    both the TelemetryMetaData and the CommandMetaData element so that each
    may be built independently but from a single namespace. See
    TelemetryMetaDataType and CommandMetaDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Parameter=None, ParameterRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
        self.Parameter_nsprefix_ = None
        if ParameterRef is None:
            self.ParameterRef = []
        else:
            self.ParameterRef = ParameterRef
        self.ParameterRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterSetType.subclass:
            return ParameterSetType.subclass(*args_, **kwargs_)
        else:
            return ParameterSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Parameter(self):
        return self.Parameter

    def set_Parameter(self, Parameter):
        self.Parameter = Parameter

    def add_Parameter(self, value):
        self.Parameter.append(value)

    def insert_Parameter_at(self, index, value):
        self.Parameter.insert(index, value)

    def replace_Parameter_at(self, index, value):
        self.Parameter[index] = value

    def get_ParameterRef(self):
        return self.ParameterRef

    def set_ParameterRef(self, ParameterRef):
        self.ParameterRef = ParameterRef

    def add_ParameterRef(self, value):
        self.ParameterRef.append(value)

    def insert_ParameterRef_at(self, index, value):
        self.ParameterRef.insert(index, value)

    def replace_ParameterRef_at(self, index, value):
        self.ParameterRef[index] = value

    def hasContent_(self):
        if (
                self.Parameter or
                self.ParameterRef
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ParameterSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParameterSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParameterSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ParameterSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Parameter_ in self.Parameter:
            namespaceprefix_ = self.Parameter_nsprefix_ + ':' if (UseCapturedNS_ and self.Parameter_nsprefix_) else ''
            Parameter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Parameter',
                              pretty_print=pretty_print)
        for ParameterRef_ in self.ParameterRef:
            namespaceprefix_ = self.ParameterRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterRef_nsprefix_) else ''
            ParameterRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ParameterRef',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Parameter':
            obj_ = ParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Parameter.append(obj_)
            obj_.original_tagname_ = 'Parameter'
        elif nodeName_ == 'ParameterRef':
            class_obj_ = self.get_class_obj_(child_, ParameterRefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterRef.append(obj_)
            obj_.original_tagname_ = 'ParameterRef'


# end class ParameterSetType


class ReferenceTimeType(GeneratedsSuper):
    """Most time values are relative to another time e.g. seconds are relative
    to minutes, minutes are relative to hours. This type is used to
    describe this relationship starting with the least significant time
    Parameter to and progressing to the most significant time parameter."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, OffsetFrom=None, Epoch=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OffsetFrom = OffsetFrom
        self.OffsetFrom_nsprefix_ = None
        self.Epoch = Epoch
        self.validate_EpochType(self.Epoch)
        self.Epoch_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceTimeType.subclass:
            return ReferenceTimeType.subclass(*args_, **kwargs_)
        else:
            return ReferenceTimeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_OffsetFrom(self):
        return self.OffsetFrom

    def set_OffsetFrom(self, OffsetFrom):
        self.OffsetFrom = OffsetFrom

    def get_Epoch(self):
        return self.Epoch

    def set_Epoch(self, Epoch):
        self.Epoch = Epoch

    def validate_EpochType(self, value):
        result = True
        # Validate type EpochType, a restriction on None.
        pass
        return result

    def hasContent_(self):
        if (
                self.OffsetFrom is not None or
                self.Epoch is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ReferenceTimeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferenceTimeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferenceTimeType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReferenceTimeType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ReferenceTimeType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OffsetFrom is not None:
            namespaceprefix_ = self.OffsetFrom_nsprefix_ + ':' if (UseCapturedNS_ and self.OffsetFrom_nsprefix_) else ''
            self.OffsetFrom.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OffsetFrom',
                                   pretty_print=pretty_print)
        if self.Epoch is not None:
            namespaceprefix_ = self.Epoch_nsprefix_ + ':' if (UseCapturedNS_ and self.Epoch_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEpoch>%s</%sEpoch>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Epoch), input_name='Epoch')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OffsetFrom':
            class_obj_ = self.get_class_obj_(child_, ParameterInstanceRefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OffsetFrom = obj_
            obj_.original_tagname_ = 'OffsetFrom'
        elif nodeName_ == 'Epoch':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Epoch')
            value_ = self.gds_validate_string(value_, node, 'Epoch')
            self.Epoch = value_
            self.Epoch_nsprefix_ = child_.prefix
            # validate type EpochType
            self.validate_EpochType(self.Epoch)


# end class ReferenceTimeType


class RepeatType(GeneratedsSuper):
    """Hold a structure that can be repeated X times, where X is the Count"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Count=None, Offset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Count = Count
        self.Count_nsprefix_ = None
        self.Offset = Offset
        self.Offset_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RepeatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RepeatType.subclass:
            return RepeatType.subclass(*args_, **kwargs_)
        else:
            return RepeatType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Count(self):
        return self.Count

    def set_Count(self, Count):
        self.Count = Count

    def get_Offset(self):
        return self.Offset

    def set_Offset(self, Offset):
        self.Offset = Offset

    def hasContent_(self):
        if (
                self.Count is not None or
                self.Offset is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='RepeatType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RepeatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RepeatType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RepeatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RepeatType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RepeatType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='RepeatType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Count is not None:
            namespaceprefix_ = self.Count_nsprefix_ + ':' if (UseCapturedNS_ and self.Count_nsprefix_) else ''
            self.Count.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Count',
                              pretty_print=pretty_print)
        if self.Offset is not None:
            namespaceprefix_ = self.Offset_nsprefix_ + ':' if (UseCapturedNS_ and self.Offset_nsprefix_) else ''
            self.Offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Offset',
                               pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Count':
            class_obj_ = self.get_class_obj_(child_, IntegerValueType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Count = obj_
            obj_.original_tagname_ = 'Count'
        elif nodeName_ == 'Offset':
            class_obj_ = self.get_class_obj_(child_, IntegerValueType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Offset = obj_
            obj_.original_tagname_ = 'Offset'


# end class RepeatType


class ArgumentRepeatType(GeneratedsSuper):
    """Identical to RepeatType but supports argument instance references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Count=None, Offset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Count = Count
        self.Count_nsprefix_ = None
        self.Offset = Offset
        self.Offset_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentRepeatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentRepeatType.subclass:
            return ArgumentRepeatType.subclass(*args_, **kwargs_)
        else:
            return ArgumentRepeatType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Count(self):
        return self.Count

    def set_Count(self, Count):
        self.Count = Count

    def get_Offset(self):
        return self.Offset

    def set_Offset(self, Offset):
        self.Offset = Offset

    def hasContent_(self):
        if (
                self.Count is not None or
                self.Offset is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentRepeatType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentRepeatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentRepeatType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentRepeatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentRepeatType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArgumentRepeatType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ArgumentRepeatType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Count is not None:
            namespaceprefix_ = self.Count_nsprefix_ + ':' if (UseCapturedNS_ and self.Count_nsprefix_) else ''
            self.Count.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Count',
                              pretty_print=pretty_print)
        if self.Offset is not None:
            namespaceprefix_ = self.Offset_nsprefix_ + ':' if (UseCapturedNS_ and self.Offset_nsprefix_) else ''
            self.Offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Offset',
                               pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Count':
            class_obj_ = self.get_class_obj_(child_, ArgumentIntegerValueType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Count = obj_
            obj_.original_tagname_ = 'Count'
        elif nodeName_ == 'Offset':
            class_obj_ = self.get_class_obj_(child_, ArgumentIntegerValueType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Offset = obj_
            obj_.original_tagname_ = 'Offset'


# end class ArgumentRepeatType


class ServiceRefType(GeneratedsSuper):
    """A reference to a Service"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, serviceRef=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.serviceRef = _cast(None, serviceRef)
        self.serviceRef_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceRefType.subclass:
            return ServiceRefType.subclass(*args_, **kwargs_)
        else:
            return ServiceRefType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_serviceRef(self):
        return self.serviceRef

    def set_serviceRef(self, serviceRef):
        self.serviceRef = serviceRef

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ServiceRefType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ServiceRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceRefType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceRefType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceRefType'):
        if self.serviceRef is not None and 'serviceRef' not in already_processed:
            already_processed.add('serviceRef')
            outfile.write(' serviceRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.serviceRef), input_name='serviceRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ServiceRefType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('serviceRef', node)
        if value is not None and 'serviceRef' not in already_processed:
            already_processed.add('serviceRef')
            self.serviceRef = value
            self.validate_NameReferenceType(self.serviceRef)  # validate type NameReferenceType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ServiceRefType


class SplinePointType(GeneratedsSuper):
    """A spline, or piecewise defined function, is a set on points from which a
    curve may be drawn to interpolate raw to calibrated valuesThe order of
    a SplineCalibrator refers to the interpolation function. Order 0 is a
    flat line from the defined point (inclusive) to the next point
    (exclusive). Order 1 is linear interpolation between two points. Order
    2 is quadratic fit and requires at least 3 points (unusual case). This
    order is generally not needed, but may be used to override the
    interpolation order for this point.The raw encoded value.The
    engineering/calibrated value associated with the raw value for this
    point."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, order='1', raw=None, calibrated=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.order = _cast(int, order)
        self.order_nsprefix_ = None
        self.raw = _cast(float, raw)
        self.raw_nsprefix_ = None
        self.calibrated = _cast(float, calibrated)
        self.calibrated_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SplinePointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SplinePointType.subclass:
            return SplinePointType.subclass(*args_, **kwargs_)
        else:
            return SplinePointType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_order(self):
        return self.order

    def set_order(self, order):
        self.order = order

    def get_raw(self):
        return self.raw

    def set_raw(self, raw):
        self.raw = raw

    def get_calibrated(self):
        return self.calibrated

    def set_calibrated(self, calibrated):
        self.calibrated = calibrated

    def validate_NonNegativeLongType(self, value):
        # Validate type xtce:NonNegativeLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on NonNegativeLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='SplinePointType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SplinePointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SplinePointType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SplinePointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SplinePointType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SplinePointType'):
        if self.order != 1 and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order="%s"' % self.gds_format_integer(self.order, input_name='order'))
        if self.raw is not None and 'raw' not in already_processed:
            already_processed.add('raw')
            outfile.write(' raw="%s"' % self.gds_format_double(self.raw, input_name='raw'))
        if self.calibrated is not None and 'calibrated' not in already_processed:
            already_processed.add('calibrated')
            outfile.write(' calibrated="%s"' % self.gds_format_double(self.calibrated, input_name='calibrated'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='SplinePointType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            self.order = self.gds_parse_integer(value, node, 'order')
            self.validate_NonNegativeLongType(self.order)  # validate type NonNegativeLongType
        value = find_attr_value_('raw', node)
        if value is not None and 'raw' not in already_processed:
            already_processed.add('raw')
            value = self.gds_parse_double(value, node, 'raw')
            self.raw = value
        value = find_attr_value_('calibrated', node)
        if value is not None and 'calibrated' not in already_processed:
            already_processed.add('calibrated')
            value = self.gds_parse_double(value, node, 'calibrated')
            self.calibrated = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class SplinePointType


class TermType(GeneratedsSuper):
    """A term in a polynomial expression.The coefficient in a single term of a
    polynomial expression.The exponent in a single term of a polynomial
    expression. Should negative exponents be required, use a Math
    Calibrator style of definition for this type."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, coefficient=None, exponent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.coefficient = _cast(float, coefficient)
        self.coefficient_nsprefix_ = None
        self.exponent = _cast(int, exponent)
        self.exponent_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TermType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TermType.subclass:
            return TermType.subclass(*args_, **kwargs_)
        else:
            return TermType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_coefficient(self):
        return self.coefficient

    def set_coefficient(self, coefficient):
        self.coefficient = coefficient

    def get_exponent(self):
        return self.exponent

    def set_exponent(self, exponent):
        self.exponent = exponent

    def validate_NonNegativeLongType(self, value):
        # Validate type xtce:NonNegativeLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on NonNegativeLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='TermType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TermType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TermType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TermType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TermType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TermType'):
        if self.coefficient is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            outfile.write(' coefficient="%s"' % self.gds_format_double(self.coefficient, input_name='coefficient'))
        if self.exponent is not None and 'exponent' not in already_processed:
            already_processed.add('exponent')
            outfile.write(' exponent="%s"' % self.gds_format_integer(self.exponent, input_name='exponent'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='TermType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coefficient', node)
        if value is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            value = self.gds_parse_double(value, node, 'coefficient')
            self.coefficient = value
        value = find_attr_value_('exponent', node)
        if value is not None and 'exponent' not in already_processed:
            already_processed.add('exponent')
            self.exponent = self.gds_parse_integer(value, node, 'exponent')
            self.validate_NonNegativeLongType(self.exponent)  # validate type NonNegativeLongType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class TermType


class UnitType(GeneratedsSuper):
    """Describe the exponent, factor, form, and description for a unit. The
    unit itself is in element Unit in UnitSet. See UnitSetType. The
    attributes are optional because different programs use this element in
    different ways, depending on vendor support.Optional attribute used in
    conjunction with the "factor" attribute where some programs choose to
    specify the unit definition with these machine processable algebraic
    features. For example, a unit text of "meters" may have a "power"
    attribute of 2, resulting "meters squared" as the actual unit. This is
    not commonly used. The most common method for "meters squared" is to
    use the text content of the Unit element in a form like "m^2".Optional
    attribute used in conjunction with the "power" attribute where some
    programs choose to specify the unit definition with these machine
    processable algebraic features. For example, a unit text of "meters"
    may have a "factor" attribute of 2, resulting "2 times meters" as the
    actual unit. This is not commonly used. The most common method for "2
    times meters" is to use the text content of the Unit element in a form
    like "2*m".A description of the unit, which may be for expanded human
    readability or for specification of the nature/property of the unit.
    For example, meters per second squared is of a nature/property of
    acceleration.The default value "calibrated" is most common practice to
    specify units at the engineering/calibrated value, it is possible to
    specify an additional Unit element for the raw/uncalibrated value."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, power=1, factor='1', description=None, form='calibrated', valueOf_=None, mixedclass_=None,
                 content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.power = _cast(float, power)
        self.power_nsprefix_ = None
        self.factor = _cast(None, factor)
        self.factor_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.form = _cast(None, form)
        self.form_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitType.subclass:
            return UnitType.subclass(*args_, **kwargs_)
        else:
            return UnitType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_power(self):
        return self.power

    def set_power(self, power):
        self.power = power

    def get_factor(self):
        return self.factor

    def set_factor(self, factor):
        self.factor = factor

    def get_description(self):
        return self.description

    def set_description(self, description):
        self.description = description

    def get_form(self):
        return self.form

    def set_form(self, form):
        self.form = form

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_ShortDescriptionType(self, value):
        # Validate type xtce:ShortDescriptionType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            pass

    def validate_UnitFormType(self, value):
        # Validate type xtce:UnitFormType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['calibrated', 'uncalibrated', 'raw']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on UnitFormType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_) or
                self.content_
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='UnitType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UnitType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnitType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UnitType'):
        if self.power != 1 and 'power' not in already_processed:
            already_processed.add('power')
            outfile.write(' power="%s"' % self.gds_format_double(self.power, input_name='power'))
        if self.factor != "1" and 'factor' not in already_processed:
            already_processed.add('factor')
            outfile.write(' factor=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.factor), input_name='factor')),))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')),))
        if self.form != "calibrated" and 'form' not in already_processed:
            already_processed.add('form')
            outfile.write(
                ' form=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.form), input_name='form')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='UnitType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                                    MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('power', node)
        if value is not None and 'power' not in already_processed:
            already_processed.add('power')
            value = self.gds_parse_double(value, node, 'power')
            self.power = value
        value = find_attr_value_('factor', node)
        if value is not None and 'factor' not in already_processed:
            already_processed.add('factor')
            self.factor = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
            self.validate_ShortDescriptionType(self.description)  # validate type ShortDescriptionType
        value = find_attr_value_('form', node)
        if value is not None and 'form' not in already_processed:
            already_processed.add('form')
            self.form = value
            self.validate_UnitFormType(self.form)  # validate type UnitFormType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                                    MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass


# end class UnitType


class ValueEnumerationType(GeneratedsSuper):
    """Describe a value and an associated string label, see
    EnumerationListType.Numeric raw/uncalibrated value to associate with a
    string enumeration label.If max value is given, the label maps to a
    range where value is less than or equal to maxValue. The range is
    inclusive.String enumeration label to apply to this value definition in
    the enumeration.An optional additional string description can be
    specified for this enumeration label to provide extended information if
    desired."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, value=None, maxValue=None, label=None, shortDescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = _cast(int, value)
        self.value_nsprefix_ = None
        self.maxValue = _cast(int, maxValue)
        self.maxValue_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.shortDescription = _cast(None, shortDescription)
        self.shortDescription_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValueEnumerationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValueEnumerationType.subclass:
            return ValueEnumerationType.subclass(*args_, **kwargs_)
        else:
            return ValueEnumerationType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def get_maxValue(self):
        return self.maxValue

    def set_maxValue(self, maxValue):
        self.maxValue = maxValue

    def get_label(self):
        return self.label

    def set_label(self, label):
        self.label = label

    def get_shortDescription(self):
        return self.shortDescription

    def set_shortDescription(self, shortDescription):
        self.shortDescription = shortDescription

    def validate_ShortDescriptionType(self, value):
        # Validate type xtce:ShortDescriptionType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            pass

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ValueEnumerationType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ValueEnumerationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ValueEnumerationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ValueEnumerationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ValueEnumerationType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ValueEnumerationType'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_integer(self.value, input_name='value'))
        if self.maxValue is not None and 'maxValue' not in already_processed:
            already_processed.add('maxValue')
            outfile.write(' maxValue="%s"' % self.gds_format_integer(self.maxValue, input_name='maxValue'))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(
                ' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')),))
        if self.shortDescription is not None and 'shortDescription' not in already_processed:
            already_processed.add('shortDescription')
            outfile.write(' shortDescription=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.shortDescription), input_name='shortDescription')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ValueEnumerationType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = self.gds_parse_integer(value, node, 'value')
        value = find_attr_value_('maxValue', node)
        if value is not None and 'maxValue' not in already_processed:
            already_processed.add('maxValue')
            self.maxValue = self.gds_parse_integer(value, node, 'maxValue')
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('shortDescription', node)
        if value is not None and 'shortDescription' not in already_processed:
            already_processed.add('shortDescription')
            self.shortDescription = value
            self.validate_ShortDescriptionType(self.shortDescription)  # validate type ShortDescriptionType

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ValueEnumerationType


class AlarmConditionsType(GeneratedsSuper):
    """Describe up to six levels: Normal, Watch, Warning, Distress, Critical,
    and Severe of conditions the alarm will trigger when true. The types
    are conditions available are a single comparison, a comparison list, a
    discrete lookup list, and custom algorithm. See MatchCriteriaType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, WatchAlarm=None, WarningAlarm=None, DistressAlarm=None, CriticalAlarm=None, SevereAlarm=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.WatchAlarm = WatchAlarm
        self.WatchAlarm_nsprefix_ = None
        self.WarningAlarm = WarningAlarm
        self.WarningAlarm_nsprefix_ = None
        self.DistressAlarm = DistressAlarm
        self.DistressAlarm_nsprefix_ = None
        self.CriticalAlarm = CriticalAlarm
        self.CriticalAlarm_nsprefix_ = None
        self.SevereAlarm = SevereAlarm
        self.SevereAlarm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlarmConditionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlarmConditionsType.subclass:
            return AlarmConditionsType.subclass(*args_, **kwargs_)
        else:
            return AlarmConditionsType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_WatchAlarm(self):
        return self.WatchAlarm

    def set_WatchAlarm(self, WatchAlarm):
        self.WatchAlarm = WatchAlarm

    def get_WarningAlarm(self):
        return self.WarningAlarm

    def set_WarningAlarm(self, WarningAlarm):
        self.WarningAlarm = WarningAlarm

    def get_DistressAlarm(self):
        return self.DistressAlarm

    def set_DistressAlarm(self, DistressAlarm):
        self.DistressAlarm = DistressAlarm

    def get_CriticalAlarm(self):
        return self.CriticalAlarm

    def set_CriticalAlarm(self, CriticalAlarm):
        self.CriticalAlarm = CriticalAlarm

    def get_SevereAlarm(self):
        return self.SevereAlarm

    def set_SevereAlarm(self, SevereAlarm):
        self.SevereAlarm = SevereAlarm

    def hasContent_(self):
        if (
                self.WatchAlarm is not None or
                self.WarningAlarm is not None or
                self.DistressAlarm is not None or
                self.CriticalAlarm is not None or
                self.SevereAlarm is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AlarmConditionsType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlarmConditionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AlarmConditionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlarmConditionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlarmConditionsType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlarmConditionsType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AlarmConditionsType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WatchAlarm is not None:
            namespaceprefix_ = self.WatchAlarm_nsprefix_ + ':' if (UseCapturedNS_ and self.WatchAlarm_nsprefix_) else ''
            self.WatchAlarm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='WatchAlarm',
                                   pretty_print=pretty_print)
        if self.WarningAlarm is not None:
            namespaceprefix_ = self.WarningAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.WarningAlarm_nsprefix_) else ''
            self.WarningAlarm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='WarningAlarm',
                                     pretty_print=pretty_print)
        if self.DistressAlarm is not None:
            namespaceprefix_ = self.DistressAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DistressAlarm_nsprefix_) else ''
            self.DistressAlarm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DistressAlarm',
                                      pretty_print=pretty_print)
        if self.CriticalAlarm is not None:
            namespaceprefix_ = self.CriticalAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CriticalAlarm_nsprefix_) else ''
            self.CriticalAlarm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CriticalAlarm',
                                      pretty_print=pretty_print)
        if self.SevereAlarm is not None:
            namespaceprefix_ = self.SevereAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SevereAlarm_nsprefix_) else ''
            self.SevereAlarm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SevereAlarm',
                                    pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'WatchAlarm':
            class_obj_ = self.get_class_obj_(child_, MatchCriteriaType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.WatchAlarm = obj_
            obj_.original_tagname_ = 'WatchAlarm'
        elif nodeName_ == 'WarningAlarm':
            class_obj_ = self.get_class_obj_(child_, MatchCriteriaType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.WarningAlarm = obj_
            obj_.original_tagname_ = 'WarningAlarm'
        elif nodeName_ == 'DistressAlarm':
            class_obj_ = self.get_class_obj_(child_, MatchCriteriaType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DistressAlarm = obj_
            obj_.original_tagname_ = 'DistressAlarm'
        elif nodeName_ == 'CriticalAlarm':
            class_obj_ = self.get_class_obj_(child_, MatchCriteriaType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CriticalAlarm = obj_
            obj_.original_tagname_ = 'CriticalAlarm'
        elif nodeName_ == 'SevereAlarm':
            class_obj_ = self.get_class_obj_(child_, MatchCriteriaType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SevereAlarm = obj_
            obj_.original_tagname_ = 'SevereAlarm'


# end class AlarmConditionsType


class AlarmRangesType(BaseAlarmType):
    """Describe up to six ranges where either less severe ranges are a subset
    of more severe ranges (outside), or more severe ranges are a subset of
    less severe ranges (inside). In both forms, the undefined least severe
    range is normal. Range values are in calibrated engineering units. See
    FloatRangeType.A value of outside specifies that the most severe range
    is outside all the other ranges: -severe -critical -distress -warning
    -watch normal +watch +warning +distress +critical +severe. A value of
    inside "inverts" these bands: -green -watch -warning -distress
    -critical severe +critical +distress +warning +watch. The most common
    form used is "outside" and is the default."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseAlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, rangeForm='outside', WatchRange=None,
                 WarningRange=None, DistressRange=None, CriticalRange=None, SevereRange=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AlarmRangesType, self).__init__(name, shortDescription, AncillaryDataSet, extensiontype_, **kwargs_)
        self.rangeForm = _cast(None, rangeForm)
        self.rangeForm_nsprefix_ = None
        self.WatchRange = WatchRange
        self.WatchRange_nsprefix_ = None
        self.WarningRange = WarningRange
        self.WarningRange_nsprefix_ = None
        self.DistressRange = DistressRange
        self.DistressRange_nsprefix_ = None
        self.CriticalRange = CriticalRange
        self.CriticalRange_nsprefix_ = None
        self.SevereRange = SevereRange
        self.SevereRange_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlarmRangesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlarmRangesType.subclass:
            return AlarmRangesType.subclass(*args_, **kwargs_)
        else:
            return AlarmRangesType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_WatchRange(self):
        return self.WatchRange

    def set_WatchRange(self, WatchRange):
        self.WatchRange = WatchRange

    def get_WarningRange(self):
        return self.WarningRange

    def set_WarningRange(self, WarningRange):
        self.WarningRange = WarningRange

    def get_DistressRange(self):
        return self.DistressRange

    def set_DistressRange(self, DistressRange):
        self.DistressRange = DistressRange

    def get_CriticalRange(self):
        return self.CriticalRange

    def set_CriticalRange(self, CriticalRange):
        self.CriticalRange = CriticalRange

    def get_SevereRange(self):
        return self.SevereRange

    def set_SevereRange(self, SevereRange):
        self.SevereRange = SevereRange

    def get_rangeForm(self):
        return self.rangeForm

    def set_rangeForm(self, rangeForm):
        self.rangeForm = rangeForm

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_RangeFormType(self, value):
        # Validate type xtce:RangeFormType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['outside', 'inside']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RangeFormType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.WatchRange is not None or
                self.WarningRange is not None or
                self.DistressRange is not None or
                self.CriticalRange is not None or
                self.SevereRange is not None or
                super(AlarmRangesType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AlarmRangesType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlarmRangesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AlarmRangesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlarmRangesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlarmRangesType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlarmRangesType'):
        super(AlarmRangesType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                      name_='AlarmRangesType')
        if self.rangeForm != "outside" and 'rangeForm' not in already_processed:
            already_processed.add('rangeForm')
            outfile.write(' rangeForm=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.rangeForm), input_name='rangeForm')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AlarmRangesType',
                       fromsubclass_=False, pretty_print=True):
        super(AlarmRangesType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                    pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WatchRange is not None:
            namespaceprefix_ = self.WatchRange_nsprefix_ + ':' if (UseCapturedNS_ and self.WatchRange_nsprefix_) else ''
            self.WatchRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='WatchRange',
                                   pretty_print=pretty_print)
        if self.WarningRange is not None:
            namespaceprefix_ = self.WarningRange_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.WarningRange_nsprefix_) else ''
            self.WarningRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='WarningRange',
                                     pretty_print=pretty_print)
        if self.DistressRange is not None:
            namespaceprefix_ = self.DistressRange_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DistressRange_nsprefix_) else ''
            self.DistressRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DistressRange',
                                      pretty_print=pretty_print)
        if self.CriticalRange is not None:
            namespaceprefix_ = self.CriticalRange_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CriticalRange_nsprefix_) else ''
            self.CriticalRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CriticalRange',
                                      pretty_print=pretty_print)
        if self.SevereRange is not None:
            namespaceprefix_ = self.SevereRange_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SevereRange_nsprefix_) else ''
            self.SevereRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SevereRange',
                                    pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rangeForm', node)
        if value is not None and 'rangeForm' not in already_processed:
            already_processed.add('rangeForm')
            self.rangeForm = value
            self.validate_RangeFormType(self.rangeForm)  # validate type RangeFormType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AlarmRangesType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'WatchRange':
            class_obj_ = self.get_class_obj_(child_, FloatRangeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.WatchRange = obj_
            obj_.original_tagname_ = 'WatchRange'
        elif nodeName_ == 'WarningRange':
            class_obj_ = self.get_class_obj_(child_, FloatRangeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.WarningRange = obj_
            obj_.original_tagname_ = 'WarningRange'
        elif nodeName_ == 'DistressRange':
            class_obj_ = self.get_class_obj_(child_, FloatRangeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DistressRange = obj_
            obj_.original_tagname_ = 'DistressRange'
        elif nodeName_ == 'CriticalRange':
            class_obj_ = self.get_class_obj_(child_, FloatRangeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CriticalRange = obj_
            obj_.original_tagname_ = 'CriticalRange'
        elif nodeName_ == 'SevereRange':
            class_obj_ = self.get_class_obj_(child_, FloatRangeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SevereRange = obj_
            obj_.original_tagname_ = 'SevereRange'
        super(AlarmRangesType, self).buildChildren(child_, node, nodeName_, True)


# end class AlarmRangesType


class AlarmType(BaseAlarmType):
    """Defines a base schema type used to build up the other data type specific
    alarm types. The definition includes a count to go into alarm
    (minViolations – the counts to go out of alarm is the same), a
    condition style alarm and a custom alarm. See AlarmConditionType,
    CustomAlgorithmType, BinaryAlarmConditionType, BooleanAlarmType,
    BinaryContextAlarmType, EnumerationAlarmType, NumericAlarmType,
    StringAlarmType, TimeAlarmType, TimeAlarmConditionType.The number of
    successive instances that meet the alarm conditions for the alarm to
    trigger. The default is 1.Optionally specify the number of successive
    instances that do not meet the alarm conditions to leave the alarm
    state. If this attribute is not specified, it is treated as being equal
    to minViolations (symmetric)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseAlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, minViolations='1', minConformance=None,
                 AlarmConditions=None, CustomAlarm=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AlarmType, self).__init__(name, shortDescription, AncillaryDataSet, extensiontype_, **kwargs_)
        self.minViolations = _cast(int, minViolations)
        self.minViolations_nsprefix_ = None
        self.minConformance = _cast(int, minConformance)
        self.minConformance_nsprefix_ = None
        self.AlarmConditions = AlarmConditions
        self.AlarmConditions_nsprefix_ = None
        self.CustomAlarm = CustomAlarm
        self.CustomAlarm_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlarmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlarmType.subclass:
            return AlarmType.subclass(*args_, **kwargs_)
        else:
            return AlarmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AlarmConditions(self):
        return self.AlarmConditions

    def set_AlarmConditions(self, AlarmConditions):
        self.AlarmConditions = AlarmConditions

    def get_CustomAlarm(self):
        return self.CustomAlarm

    def set_CustomAlarm(self, CustomAlarm):
        self.CustomAlarm = CustomAlarm

    def get_minViolations(self):
        return self.minViolations

    def set_minViolations(self, minViolations):
        self.minViolations = minViolations

    def get_minConformance(self):
        return self.minConformance

    def set_minConformance(self, minConformance):
        self.minConformance = minConformance

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.AlarmConditions is not None or
                self.CustomAlarm is not None or
                super(AlarmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AlarmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlarmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AlarmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlarmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlarmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlarmType'):
        super(AlarmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlarmType')
        if self.minViolations != 1 and 'minViolations' not in already_processed:
            already_processed.add('minViolations')
            outfile.write(
                ' minViolations="%s"' % self.gds_format_integer(self.minViolations, input_name='minViolations'))
        if self.minConformance is not None and 'minConformance' not in already_processed:
            already_processed.add('minConformance')
            outfile.write(
                ' minConformance="%s"' % self.gds_format_integer(self.minConformance, input_name='minConformance'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AlarmType',
                       fromsubclass_=False, pretty_print=True):
        super(AlarmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                              pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AlarmConditions is not None:
            namespaceprefix_ = self.AlarmConditions_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AlarmConditions_nsprefix_) else ''
            self.AlarmConditions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AlarmConditions',
                                        pretty_print=pretty_print)
        if self.CustomAlarm is not None:
            namespaceprefix_ = self.CustomAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CustomAlarm_nsprefix_) else ''
            self.CustomAlarm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CustomAlarm',
                                    pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minViolations', node)
        if value is not None and 'minViolations' not in already_processed:
            already_processed.add('minViolations')
            self.minViolations = self.gds_parse_integer(value, node, 'minViolations')
            self.validate_PositiveLongType(self.minViolations)  # validate type PositiveLongType
        value = find_attr_value_('minConformance', node)
        if value is not None and 'minConformance' not in already_processed:
            already_processed.add('minConformance')
            self.minConformance = self.gds_parse_integer(value, node, 'minConformance')
            self.validate_PositiveLongType(self.minConformance)  # validate type PositiveLongType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AlarmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AlarmConditions':
            obj_ = AlarmConditionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AlarmConditions = obj_
            obj_.original_tagname_ = 'AlarmConditions'
        elif nodeName_ == 'CustomAlarm':
            obj_ = CustomAlarmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CustomAlarm = obj_
            obj_.original_tagname_ = 'CustomAlarm'
        super(AlarmType, self).buildChildren(child_, node, nodeName_, True)


# end class AlarmType


class AlarmMultiRangesType(BaseAlarmType):
    """Describe any number of alarm ranges, each with its own level (normal,
    warning, watch, distress, critical, severe) and range form (inside or
    outside). Ranges may overlap, be disjoint and so forth. Ranges within
    the value sprectrum non-specified are non-normal. The most severe range
    level of value within the ranges is the level of the alarm. Range
    values are in calibrated engineering units. See FloatRangeType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseAlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, Range=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AlarmMultiRangesType, self).__init__(name, shortDescription, AncillaryDataSet, **kwargs_)
        if Range is None:
            self.Range = []
        else:
            self.Range = Range
        self.Range_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlarmMultiRangesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlarmMultiRangesType.subclass:
            return AlarmMultiRangesType.subclass(*args_, **kwargs_)
        else:
            return AlarmMultiRangesType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Range(self):
        return self.Range

    def set_Range(self, Range):
        self.Range = Range

    def add_Range(self, value):
        self.Range.append(value)

    def insert_Range_at(self, index, value):
        self.Range.insert(index, value)

    def replace_Range_at(self, index, value):
        self.Range[index] = value

    def hasContent_(self):
        if (
                self.Range or
                super(AlarmMultiRangesType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AlarmMultiRangesType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlarmMultiRangesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AlarmMultiRangesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlarmMultiRangesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlarmMultiRangesType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlarmMultiRangesType'):
        super(AlarmMultiRangesType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='AlarmMultiRangesType')

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='AlarmMultiRangesType',
                       fromsubclass_=False, pretty_print=True):
        super(AlarmMultiRangesType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Range_ in self.Range:
            namespaceprefix_ = self.Range_nsprefix_ + ':' if (UseCapturedNS_ and self.Range_nsprefix_) else ''
            Range_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Range', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(AlarmMultiRangesType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Range':
            obj_ = MultiRangeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Range.append(obj_)
            obj_.original_tagname_ = 'Range'
        super(AlarmMultiRangesType, self).buildChildren(child_, node, nodeName_, True)


# end class AlarmMultiRangesType


class BinaryAlarmType(AlarmType):
    """Describe alarm conditions specific to the binary data type, extends the
    basic AlarmType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, minViolations='1', minConformance=None,
                 AlarmConditions=None, CustomAlarm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BinaryAlarmType, self).__init__(name, shortDescription, AncillaryDataSet, minViolations, minConformance,
                                              AlarmConditions, CustomAlarm, **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BinaryAlarmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BinaryAlarmType.subclass:
            return BinaryAlarmType.subclass(*args_, **kwargs_)
        else:
            return BinaryAlarmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(BinaryAlarmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BinaryAlarmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BinaryAlarmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BinaryAlarmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BinaryAlarmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BinaryAlarmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BinaryAlarmType'):
        super(BinaryAlarmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                      name_='BinaryAlarmType')

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BinaryAlarmType',
                       fromsubclass_=False, pretty_print=True):
        super(BinaryAlarmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                    pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(BinaryAlarmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BinaryAlarmType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class BinaryAlarmType


class BooleanAlarmType(AlarmType):
    """Alarm conditions for Boolean types"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, minViolations='1', minConformance=None,
                 AlarmConditions=None, CustomAlarm=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BooleanAlarmType, self).__init__(name, shortDescription, AncillaryDataSet, minViolations, minConformance,
                                               AlarmConditions, CustomAlarm, extensiontype_, **kwargs_)
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BooleanAlarmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BooleanAlarmType.subclass:
            return BooleanAlarmType.subclass(*args_, **kwargs_)
        else:
            return BooleanAlarmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                super(BooleanAlarmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BooleanAlarmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BooleanAlarmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BooleanAlarmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanAlarmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BooleanAlarmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BooleanAlarmType'):
        super(BooleanAlarmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                       name_='BooleanAlarmType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BooleanAlarmType',
                       fromsubclass_=False, pretty_print=True):
        super(BooleanAlarmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BooleanAlarmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BooleanAlarmType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class BooleanAlarmType


class BinaryContextAlarmListType(GeneratedsSuper):
    """Describe an ordered collection of context binary alarms, duplicates are
    valid. Process the contexts in list order. See
    BinaryContextAlarmType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ContextAlarm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ContextAlarm is None:
            self.ContextAlarm = []
        else:
            self.ContextAlarm = ContextAlarm
        self.ContextAlarm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BinaryContextAlarmListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BinaryContextAlarmListType.subclass:
            return BinaryContextAlarmListType.subclass(*args_, **kwargs_)
        else:
            return BinaryContextAlarmListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextAlarm(self):
        return self.ContextAlarm

    def set_ContextAlarm(self, ContextAlarm):
        self.ContextAlarm = ContextAlarm

    def add_ContextAlarm(self, value):
        self.ContextAlarm.append(value)

    def insert_ContextAlarm_at(self, index, value):
        self.ContextAlarm.insert(index, value)

    def replace_ContextAlarm_at(self, index, value):
        self.ContextAlarm[index] = value

    def hasContent_(self):
        if (
                self.ContextAlarm
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BinaryContextAlarmListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BinaryContextAlarmListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BinaryContextAlarmListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BinaryContextAlarmListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BinaryContextAlarmListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='BinaryContextAlarmListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='BinaryContextAlarmListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContextAlarm_ in self.ContextAlarm:
            namespaceprefix_ = self.ContextAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextAlarm_nsprefix_) else ''
            ContextAlarm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextAlarm',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextAlarm':
            obj_ = BinaryContextAlarmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextAlarm.append(obj_)
            obj_.original_tagname_ = 'ContextAlarm'


# end class BinaryContextAlarmListType


class BinaryContextAlarmType(AlarmType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, minViolations='1', minConformance=None,
                 AlarmConditions=None, CustomAlarm=None, ContextMatch=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BinaryContextAlarmType, self).__init__(name, shortDescription, AncillaryDataSet, minViolations,
                                                     minConformance, AlarmConditions, CustomAlarm, **kwargs_)
        self.ContextMatch = ContextMatch
        self.ContextMatch_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BinaryContextAlarmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BinaryContextAlarmType.subclass:
            return BinaryContextAlarmType.subclass(*args_, **kwargs_)
        else:
            return BinaryContextAlarmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextMatch(self):
        return self.ContextMatch

    def set_ContextMatch(self, ContextMatch):
        self.ContextMatch = ContextMatch

    def hasContent_(self):
        if (
                self.ContextMatch is not None or
                super(BinaryContextAlarmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BinaryContextAlarmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BinaryContextAlarmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BinaryContextAlarmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BinaryContextAlarmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BinaryContextAlarmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BinaryContextAlarmType'):
        super(BinaryContextAlarmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                             name_='BinaryContextAlarmType')

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='BinaryContextAlarmType', fromsubclass_=False, pretty_print=True):
        super(BinaryContextAlarmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                           pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContextMatch is not None:
            namespaceprefix_ = self.ContextMatch_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextMatch_nsprefix_) else ''
            self.ContextMatch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextMatch',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(BinaryContextAlarmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextMatch':
            obj_ = ContextMatchType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextMatch = obj_
            obj_.original_tagname_ = 'ContextMatch'
        super(BinaryContextAlarmType, self).buildChildren(child_, node, nodeName_, True)


# end class BinaryContextAlarmType


class BooleanContextAlarmType(BooleanAlarmType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BooleanAlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, minViolations='1', minConformance=None,
                 AlarmConditions=None, CustomAlarm=None, ContextMatch=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BooleanContextAlarmType, self).__init__(name, shortDescription, AncillaryDataSet, minViolations,
                                                      minConformance, AlarmConditions, CustomAlarm, **kwargs_)
        self.ContextMatch = ContextMatch
        self.ContextMatch_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BooleanContextAlarmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BooleanContextAlarmType.subclass:
            return BooleanContextAlarmType.subclass(*args_, **kwargs_)
        else:
            return BooleanContextAlarmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextMatch(self):
        return self.ContextMatch

    def set_ContextMatch(self, ContextMatch):
        self.ContextMatch = ContextMatch

    def hasContent_(self):
        if (
                self.ContextMatch is not None or
                super(BooleanContextAlarmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BooleanContextAlarmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BooleanContextAlarmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BooleanContextAlarmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanContextAlarmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BooleanContextAlarmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BooleanContextAlarmType'):
        super(BooleanContextAlarmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                              name_='BooleanContextAlarmType')

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='BooleanContextAlarmType', fromsubclass_=False, pretty_print=True):
        super(BooleanContextAlarmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                            True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContextMatch is not None:
            namespaceprefix_ = self.ContextMatch_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextMatch_nsprefix_) else ''
            self.ContextMatch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextMatch',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(BooleanContextAlarmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextMatch':
            obj_ = ContextMatchType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextMatch = obj_
            obj_.original_tagname_ = 'ContextMatch'
        super(BooleanContextAlarmType, self).buildChildren(child_, node, nodeName_, True)


# end class BooleanContextAlarmType


class BooleanContextAlarmListType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ContextAlarm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ContextAlarm is None:
            self.ContextAlarm = []
        else:
            self.ContextAlarm = ContextAlarm
        self.ContextAlarm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BooleanContextAlarmListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BooleanContextAlarmListType.subclass:
            return BooleanContextAlarmListType.subclass(*args_, **kwargs_)
        else:
            return BooleanContextAlarmListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextAlarm(self):
        return self.ContextAlarm

    def set_ContextAlarm(self, ContextAlarm):
        self.ContextAlarm = ContextAlarm

    def add_ContextAlarm(self, value):
        self.ContextAlarm.append(value)

    def insert_ContextAlarm_at(self, index, value):
        self.ContextAlarm.insert(index, value)

    def replace_ContextAlarm_at(self, index, value):
        self.ContextAlarm[index] = value

    def hasContent_(self):
        if (
                self.ContextAlarm
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='BooleanContextAlarmListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BooleanContextAlarmListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BooleanContextAlarmListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanContextAlarmListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='BooleanContextAlarmListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='BooleanContextAlarmListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='BooleanContextAlarmListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContextAlarm_ in self.ContextAlarm:
            namespaceprefix_ = self.ContextAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextAlarm_nsprefix_) else ''
            ContextAlarm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextAlarm',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextAlarm':
            obj_ = BooleanContextAlarmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextAlarm.append(obj_)
            obj_.original_tagname_ = 'ContextAlarm'


# end class BooleanContextAlarmListType


class ChangeAlarmRangesType(AlarmRangesType):
    """Describe an alarm when the parameter value's rate-of-change is either
    too fast or too slow. The change may be with respect to time (the
    default) or with respect to samples (delta alarms). Use the changeType
    attribute to select the type: changePerSecond (time) or changePerSample
    (delta). The change may also be ether relative (as a percentage change)
    or absolute as set by the changeBasis attribute. (Delta alarms are
    typically absolute but percentage is conceivable). The alarm also
    requires the spanOfInterest in both samples and seconds to have passed
    before it is to trigger. For time based rate of change alarms, the time
    specified in spanOfInterestInSeconds is used to calculate the change.
    For sample based rate of change alarms, the change is calculated over
    the number of samples specified in spanOfInterestInSamples. A typical
    delta alarm would set: changeType=changePerSample,
    changeBasis=absoluteChange, spanOfInterestInSamples=1. A typical time
    based version would set: changeType=changePerSecond,
    changeBasis=percentageChange, and spaceOfInterestInSeconds=1. To set
    the ranges use maxInclusive, the following definition applies: |
    Normal.maxInclusive | <= | Watch.maxInclusive | <= |
    Warning.maxInclusive | <= | Distress.maxInclusive | <= |
    Critical.maxInclusive | <= | Severe.maxInclusive |. And it is further
    assumed the absolute value of each range and sampled value it taken to
    evaluate the alarm. See NumericAlarmType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AlarmRangesType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, rangeForm='outside', WatchRange=None,
                 WarningRange=None, DistressRange=None, CriticalRange=None, SevereRange=None,
                 changeType='changePerSecond', changeBasis='absoluteChange', spanOfInterestInSamples='1',
                 spanOfInterestInSeconds=0, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ChangeAlarmRangesType, self).__init__(name, shortDescription, AncillaryDataSet, rangeForm, WatchRange,
                                                    WarningRange, DistressRange, CriticalRange, SevereRange, **kwargs_)
        self.changeType = _cast(None, changeType)
        self.changeType_nsprefix_ = None
        self.changeBasis = _cast(None, changeBasis)
        self.changeBasis_nsprefix_ = None
        self.spanOfInterestInSamples = _cast(int, spanOfInterestInSamples)
        self.spanOfInterestInSamples_nsprefix_ = None
        self.spanOfInterestInSeconds = _cast(float, spanOfInterestInSeconds)
        self.spanOfInterestInSeconds_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChangeAlarmRangesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChangeAlarmRangesType.subclass:
            return ChangeAlarmRangesType.subclass(*args_, **kwargs_)
        else:
            return ChangeAlarmRangesType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_changeType(self):
        return self.changeType

    def set_changeType(self, changeType):
        self.changeType = changeType

    def get_changeBasis(self):
        return self.changeBasis

    def set_changeBasis(self, changeBasis):
        self.changeBasis = changeBasis

    def get_spanOfInterestInSamples(self):
        return self.spanOfInterestInSamples

    def set_spanOfInterestInSamples(self, spanOfInterestInSamples):
        self.spanOfInterestInSamples = spanOfInterestInSamples

    def get_spanOfInterestInSeconds(self):
        return self.spanOfInterestInSeconds

    def set_spanOfInterestInSeconds(self, spanOfInterestInSeconds):
        self.spanOfInterestInSeconds = spanOfInterestInSeconds

    def validate_ChangeSpanType(self, value):
        # Validate type xtce:ChangeSpanType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['changePerSecond', 'changePerSample']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ChangeSpanType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_ChangeBasisType(self, value):
        # Validate type xtce:ChangeBasisType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['absoluteChange', 'percentageChange']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ChangeBasisType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(ChangeAlarmRangesType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ChangeAlarmRangesType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChangeAlarmRangesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ChangeAlarmRangesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChangeAlarmRangesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChangeAlarmRangesType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChangeAlarmRangesType'):
        super(ChangeAlarmRangesType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                            name_='ChangeAlarmRangesType')
        if self.changeType != "changePerSecond" and 'changeType' not in already_processed:
            already_processed.add('changeType')
            outfile.write(' changeType=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.changeType), input_name='changeType')),))
        if self.changeBasis != "absoluteChange" and 'changeBasis' not in already_processed:
            already_processed.add('changeBasis')
            outfile.write(' changeBasis=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.changeBasis), input_name='changeBasis')),))
        if self.spanOfInterestInSamples != 1 and 'spanOfInterestInSamples' not in already_processed:
            already_processed.add('spanOfInterestInSamples')
            outfile.write(' spanOfInterestInSamples="%s"' % self.gds_format_integer(self.spanOfInterestInSamples,
                                                                                    input_name='spanOfInterestInSamples'))
        if self.spanOfInterestInSeconds != 0 and 'spanOfInterestInSeconds' not in already_processed:
            already_processed.add('spanOfInterestInSeconds')
            outfile.write(' spanOfInterestInSeconds="%s"' % self.gds_format_double(self.spanOfInterestInSeconds,
                                                                                   input_name='spanOfInterestInSeconds'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='ChangeAlarmRangesType', fromsubclass_=False, pretty_print=True):
        super(ChangeAlarmRangesType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                          pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('changeType', node)
        if value is not None and 'changeType' not in already_processed:
            already_processed.add('changeType')
            self.changeType = value
            self.validate_ChangeSpanType(self.changeType)  # validate type ChangeSpanType
        value = find_attr_value_('changeBasis', node)
        if value is not None and 'changeBasis' not in already_processed:
            already_processed.add('changeBasis')
            self.changeBasis = value
            self.validate_ChangeBasisType(self.changeBasis)  # validate type ChangeBasisType
        value = find_attr_value_('spanOfInterestInSamples', node)
        if value is not None and 'spanOfInterestInSamples' not in already_processed:
            already_processed.add('spanOfInterestInSamples')
            self.spanOfInterestInSamples = self.gds_parse_integer(value, node, 'spanOfInterestInSamples')
            self.validate_PositiveLongType(self.spanOfInterestInSamples)  # validate type PositiveLongType
        value = find_attr_value_('spanOfInterestInSeconds', node)
        if value is not None and 'spanOfInterestInSeconds' not in already_processed:
            already_processed.add('spanOfInterestInSeconds')
            value = self.gds_parse_double(value, node, 'spanOfInterestInSeconds')
            self.spanOfInterestInSeconds = value
        super(ChangeAlarmRangesType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ChangeAlarmRangesType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ChangeAlarmRangesType


class DiscreteLookupType(MatchCriteriaType):
    """Describe a discrete value lookup and the value associated when the
    lookup evaluates to true.Value to use when the lookup conditions are
    true."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MatchCriteriaType

    def __init__(self, Comparison=None, ComparisonList=None, BooleanExpression=None, CustomAlgorithm=None, value=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DiscreteLookupType, self).__init__(Comparison, ComparisonList, BooleanExpression, CustomAlgorithm,
                                                 **kwargs_)
        self.value = _cast(int, value)
        self.value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiscreteLookupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiscreteLookupType.subclass:
            return DiscreteLookupType.subclass(*args_, **kwargs_)
        else:
            return DiscreteLookupType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def hasContent_(self):
        if (
                super(DiscreteLookupType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='DiscreteLookupType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DiscreteLookupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DiscreteLookupType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DiscreteLookupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DiscreteLookupType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DiscreteLookupType'):
        super(DiscreteLookupType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                         name_='DiscreteLookupType')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_integer(self.value, input_name='value'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='DiscreteLookupType',
                       fromsubclass_=False, pretty_print=True):
        super(DiscreteLookupType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                       pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = self.gds_parse_integer(value, node, 'value')
        super(DiscreteLookupType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DiscreteLookupType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class DiscreteLookupType


class EnumerationAlarmLevelType(GeneratedsSuper):
    """Describe an alarm level and its enumeration label to trigger from. See
    EnumeratedAlarmType and EnumeratedParameterType.Defines six levels:
    Normal, Watch, Warning, Distress, Critical and Severe. Typical
    implementations color the "normal" level as green, "warning" level as
    yellow, and "critical" level as red. In the case of enumeration alarms,
    the "normal" is assumed by implementations to be any label not
    otherwise in an alarm state.The enumeration label is the
    engineering/calibrated value for enumerated types."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, alarmLevel=None, enumerationLabel=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.alarmLevel = _cast(None, alarmLevel)
        self.alarmLevel_nsprefix_ = None
        self.enumerationLabel = _cast(None, enumerationLabel)
        self.enumerationLabel_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnumerationAlarmLevelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnumerationAlarmLevelType.subclass:
            return EnumerationAlarmLevelType.subclass(*args_, **kwargs_)
        else:
            return EnumerationAlarmLevelType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_alarmLevel(self):
        return self.alarmLevel

    def set_alarmLevel(self, alarmLevel):
        self.alarmLevel = alarmLevel

    def get_enumerationLabel(self):
        return self.enumerationLabel

    def set_enumerationLabel(self, enumerationLabel):
        self.enumerationLabel = enumerationLabel

    def validate_ConcernLevelsType(self, value):
        # Validate type xtce:ConcernLevelsType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'watch', 'warning', 'distress', 'critical', 'severe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ConcernLevelsType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='EnumerationAlarmLevelType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnumerationAlarmLevelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EnumerationAlarmLevelType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnumerationAlarmLevelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EnumerationAlarmLevelType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='EnumerationAlarmLevelType'):
        if self.alarmLevel is not None and 'alarmLevel' not in already_processed:
            already_processed.add('alarmLevel')
            outfile.write(' alarmLevel=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.alarmLevel), input_name='alarmLevel')),))
        if self.enumerationLabel is not None and 'enumerationLabel' not in already_processed:
            already_processed.add('enumerationLabel')
            outfile.write(' enumerationLabel=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.enumerationLabel), input_name='enumerationLabel')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='EnumerationAlarmLevelType', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alarmLevel', node)
        if value is not None and 'alarmLevel' not in already_processed:
            already_processed.add('alarmLevel')
            self.alarmLevel = value
            self.validate_ConcernLevelsType(self.alarmLevel)  # validate type ConcernLevelsType
        value = find_attr_value_('enumerationLabel', node)
        if value is not None and 'enumerationLabel' not in already_processed:
            already_processed.add('enumerationLabel')
            self.enumerationLabel = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class EnumerationAlarmLevelType


class EnumerationAlarmListType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, EnumerationAlarm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if EnumerationAlarm is None:
            self.EnumerationAlarm = []
        else:
            self.EnumerationAlarm = EnumerationAlarm
        self.EnumerationAlarm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnumerationAlarmListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnumerationAlarmListType.subclass:
            return EnumerationAlarmListType.subclass(*args_, **kwargs_)
        else:
            return EnumerationAlarmListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_EnumerationAlarm(self):
        return self.EnumerationAlarm

    def set_EnumerationAlarm(self, EnumerationAlarm):
        self.EnumerationAlarm = EnumerationAlarm

    def add_EnumerationAlarm(self, value):
        self.EnumerationAlarm.append(value)

    def insert_EnumerationAlarm_at(self, index, value):
        self.EnumerationAlarm.insert(index, value)

    def replace_EnumerationAlarm_at(self, index, value):
        self.EnumerationAlarm[index] = value

    def hasContent_(self):
        if (
                self.EnumerationAlarm
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='EnumerationAlarmListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnumerationAlarmListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EnumerationAlarmListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnumerationAlarmListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EnumerationAlarmListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='EnumerationAlarmListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='EnumerationAlarmListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EnumerationAlarm_ in self.EnumerationAlarm:
            namespaceprefix_ = self.EnumerationAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.EnumerationAlarm_nsprefix_) else ''
            EnumerationAlarm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EnumerationAlarm',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EnumerationAlarm':
            obj_ = EnumerationAlarmLevelType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnumerationAlarm.append(obj_)
            obj_.original_tagname_ = 'EnumerationAlarm'


# end class EnumerationAlarmListType


class EnumerationAlarmType(AlarmType):
    """Describe alarm conditions specific to the enumeration data type, extends
    the basic AlarmType with an EnumerationAlarmList. The alarms are
    described using the label (engineering/calibrated value) of the
    enumerated parameter. Enumeration labels may represent several
    raw/uncalibrated values, so as a result, a single alarm definition here
    may represent multiple raw values in the enumerated parameter. It is
    not necessary to define an alarm for raw/uncalibrated values that do
    not map to an enumeration. Implementations should implicitly define
    this as an alarm case, of which the manifestation of that is
    program/implementation specific. See EnumeratedParameterType.Alarm
    state name for when no enumeration alarms evaluate to true. This
    defaults to "normal", which is almost always the case. Setting it to
    another alarm state permits a form of "inverted logic" where the alarm
    list can specify the normal states instead of the alarm states."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, minViolations='1', minConformance=None,
                 AlarmConditions=None, CustomAlarm=None, defaultAlarmLevel='normal', EnumerationAlarmList=None,
                 extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EnumerationAlarmType, self).__init__(name, shortDescription, AncillaryDataSet, minViolations,
                                                   minConformance, AlarmConditions, CustomAlarm, extensiontype_,
                                                   **kwargs_)
        self.defaultAlarmLevel = _cast(None, defaultAlarmLevel)
        self.defaultAlarmLevel_nsprefix_ = None
        self.EnumerationAlarmList = EnumerationAlarmList
        self.EnumerationAlarmList_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnumerationAlarmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnumerationAlarmType.subclass:
            return EnumerationAlarmType.subclass(*args_, **kwargs_)
        else:
            return EnumerationAlarmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_EnumerationAlarmList(self):
        return self.EnumerationAlarmList

    def set_EnumerationAlarmList(self, EnumerationAlarmList):
        self.EnumerationAlarmList = EnumerationAlarmList

    def get_defaultAlarmLevel(self):
        return self.defaultAlarmLevel

    def set_defaultAlarmLevel(self, defaultAlarmLevel):
        self.defaultAlarmLevel = defaultAlarmLevel

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_ConcernLevelsType(self, value):
        # Validate type xtce:ConcernLevelsType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'watch', 'warning', 'distress', 'critical', 'severe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ConcernLevelsType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.EnumerationAlarmList is not None or
                super(EnumerationAlarmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='EnumerationAlarmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnumerationAlarmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EnumerationAlarmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnumerationAlarmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EnumerationAlarmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EnumerationAlarmType'):
        super(EnumerationAlarmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='EnumerationAlarmType')
        if self.defaultAlarmLevel != "normal" and 'defaultAlarmLevel' not in already_processed:
            already_processed.add('defaultAlarmLevel')
            outfile.write(' defaultAlarmLevel=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.defaultAlarmLevel), input_name='defaultAlarmLevel')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='EnumerationAlarmType',
                       fromsubclass_=False, pretty_print=True):
        super(EnumerationAlarmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EnumerationAlarmList is not None:
            namespaceprefix_ = self.EnumerationAlarmList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.EnumerationAlarmList_nsprefix_) else ''
            self.EnumerationAlarmList.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='EnumerationAlarmList', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('defaultAlarmLevel', node)
        if value is not None and 'defaultAlarmLevel' not in already_processed:
            already_processed.add('defaultAlarmLevel')
            self.defaultAlarmLevel = value
            self.validate_ConcernLevelsType(self.defaultAlarmLevel)  # validate type ConcernLevelsType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EnumerationAlarmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EnumerationAlarmList':
            obj_ = EnumerationAlarmListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnumerationAlarmList = obj_
            obj_.original_tagname_ = 'EnumerationAlarmList'
        super(EnumerationAlarmType, self).buildChildren(child_, node, nodeName_, True)


# end class EnumerationAlarmType


class FloatRangeType(GeneratedsSuper):
    """Describe a floating point based range, several types of ranges are
    supported -- one sided and two sided, inclusive or exclusive. It would
    not make sense to set two mins or maxes. Used in a number of locations
    related to ranges: ValidFloatRangeSetType or AlarmRangeType for
    example.Minimum decimal/real number value including itself.Minimum
    decimal/real number value excluding itself.Maximum decimal/real number
    value including itself.Maximum decimal/real number value excluding
    itself."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, minInclusive=None, minExclusive=None, maxInclusive=None, maxExclusive=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.minInclusive = _cast(float, minInclusive)
        self.minInclusive_nsprefix_ = None
        self.minExclusive = _cast(float, minExclusive)
        self.minExclusive_nsprefix_ = None
        self.maxInclusive = _cast(float, maxInclusive)
        self.maxInclusive_nsprefix_ = None
        self.maxExclusive = _cast(float, maxExclusive)
        self.maxExclusive_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatRangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatRangeType.subclass:
            return FloatRangeType.subclass(*args_, **kwargs_)
        else:
            return FloatRangeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_minInclusive(self):
        return self.minInclusive

    def set_minInclusive(self, minInclusive):
        self.minInclusive = minInclusive

    def get_minExclusive(self):
        return self.minExclusive

    def set_minExclusive(self, minExclusive):
        self.minExclusive = minExclusive

    def get_maxInclusive(self):
        return self.maxInclusive

    def set_maxInclusive(self, maxInclusive):
        self.maxInclusive = maxInclusive

    def get_maxExclusive(self):
        return self.maxExclusive

    def set_maxExclusive(self, maxExclusive):
        self.maxExclusive = maxExclusive

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='FloatRangeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FloatRangeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FloatRangeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FloatRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FloatRangeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FloatRangeType'):
        if self.minInclusive is not None and 'minInclusive' not in already_processed:
            already_processed.add('minInclusive')
            outfile.write(' minInclusive="%s"' % self.gds_format_double(self.minInclusive, input_name='minInclusive'))
        if self.minExclusive is not None and 'minExclusive' not in already_processed:
            already_processed.add('minExclusive')
            outfile.write(' minExclusive="%s"' % self.gds_format_double(self.minExclusive, input_name='minExclusive'))
        if self.maxInclusive is not None and 'maxInclusive' not in already_processed:
            already_processed.add('maxInclusive')
            outfile.write(' maxInclusive="%s"' % self.gds_format_double(self.maxInclusive, input_name='maxInclusive'))
        if self.maxExclusive is not None and 'maxExclusive' not in already_processed:
            already_processed.add('maxExclusive')
            outfile.write(' maxExclusive="%s"' % self.gds_format_double(self.maxExclusive, input_name='maxExclusive'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='FloatRangeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minInclusive', node)
        if value is not None and 'minInclusive' not in already_processed:
            already_processed.add('minInclusive')
            value = self.gds_parse_double(value, node, 'minInclusive')
            self.minInclusive = value
        value = find_attr_value_('minExclusive', node)
        if value is not None and 'minExclusive' not in already_processed:
            already_processed.add('minExclusive')
            value = self.gds_parse_double(value, node, 'minExclusive')
            self.minExclusive = value
        value = find_attr_value_('maxInclusive', node)
        if value is not None and 'maxInclusive' not in already_processed:
            already_processed.add('maxInclusive')
            value = self.gds_parse_double(value, node, 'maxInclusive')
            self.maxInclusive = value
        value = find_attr_value_('maxExclusive', node)
        if value is not None and 'maxExclusive' not in already_processed:
            already_processed.add('maxExclusive')
            value = self.gds_parse_double(value, node, 'maxExclusive')
            self.maxExclusive = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class FloatRangeType


class IntegerRangeType(GeneratedsSuper):
    """Describe an integral based range: minInclusive and maxInclusive. Used in
    a number of locations related to ranges: ValidIntegerRangeSetType for
    example.Minimum integer value including itself.Maximum integer value
    including itself."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, minInclusive=None, maxInclusive=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.minInclusive = _cast(int, minInclusive)
        self.minInclusive_nsprefix_ = None
        self.maxInclusive = _cast(int, maxInclusive)
        self.maxInclusive_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntegerRangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntegerRangeType.subclass:
            return IntegerRangeType.subclass(*args_, **kwargs_)
        else:
            return IntegerRangeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_minInclusive(self):
        return self.minInclusive

    def set_minInclusive(self, minInclusive):
        self.minInclusive = minInclusive

    def get_maxInclusive(self):
        return self.maxInclusive

    def set_maxInclusive(self, maxInclusive):
        self.maxInclusive = maxInclusive

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='IntegerRangeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IntegerRangeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IntegerRangeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IntegerRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IntegerRangeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IntegerRangeType'):
        if self.minInclusive is not None and 'minInclusive' not in already_processed:
            already_processed.add('minInclusive')
            outfile.write(' minInclusive="%s"' % self.gds_format_integer(self.minInclusive, input_name='minInclusive'))
        if self.maxInclusive is not None and 'maxInclusive' not in already_processed:
            already_processed.add('maxInclusive')
            outfile.write(' maxInclusive="%s"' % self.gds_format_integer(self.maxInclusive, input_name='maxInclusive'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='IntegerRangeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minInclusive', node)
        if value is not None and 'minInclusive' not in already_processed:
            already_processed.add('minInclusive')
            self.minInclusive = self.gds_parse_integer(value, node, 'minInclusive')
        value = find_attr_value_('maxInclusive', node)
        if value is not None and 'maxInclusive' not in already_processed:
            already_processed.add('maxInclusive')
            self.maxInclusive = self.gds_parse_integer(value, node, 'maxInclusive')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class IntegerRangeType


class LinearAdjustmentType(GeneratedsSuper):
    """A slope and intercept may be applied to scale or shift the value of the
    parameter in the dynamic value"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, slope=None, intercept=0, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.slope = _cast(float, slope)
        self.slope_nsprefix_ = None
        self.intercept = _cast(float, intercept)
        self.intercept_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinearAdjustmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinearAdjustmentType.subclass:
            return LinearAdjustmentType.subclass(*args_, **kwargs_)
        else:
            return LinearAdjustmentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_slope(self):
        return self.slope

    def set_slope(self, slope):
        self.slope = slope

    def get_intercept(self):
        return self.intercept

    def set_intercept(self, intercept):
        self.intercept = intercept

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='LinearAdjustmentType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LinearAdjustmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LinearAdjustmentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LinearAdjustmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LinearAdjustmentType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LinearAdjustmentType'):
        if self.slope is not None and 'slope' not in already_processed:
            already_processed.add('slope')
            outfile.write(' slope="%s"' % self.gds_format_double(self.slope, input_name='slope'))
        if self.intercept != 0 and 'intercept' not in already_processed:
            already_processed.add('intercept')
            outfile.write(' intercept="%s"' % self.gds_format_double(self.intercept, input_name='intercept'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='LinearAdjustmentType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('slope', node)
        if value is not None and 'slope' not in already_processed:
            already_processed.add('slope')
            value = self.gds_parse_double(value, node, 'slope')
            self.slope = value
        value = find_attr_value_('intercept', node)
        if value is not None and 'intercept' not in already_processed:
            already_processed.add('intercept')
            value = self.gds_parse_double(value, node, 'intercept')
            self.intercept = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class LinearAdjustmentType


class MultiRangeType(FloatRangeType):
    """The alarm multi-range element type permits users to define multiple
    alarm ranges in a sequence that goes beyond the more typical "inside"
    and "outside" range definitions. It can be thought of as a "barber
    pole" definition.A value of outside specifies that the most severe
    range is outside all the other ranges: -severe -critical -distress
    -warning -watch normal +watch +warning +distress +critical +severe. A
    value of inside "inverts" these bands: -green -watch -warning -distress
    -critical severe +critical +distress +warning +watch. The most common
    form used is "outside" and is the default.The level of concern for this
    alarm definition."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FloatRangeType

    def __init__(self, minInclusive=None, minExclusive=None, maxInclusive=None, maxExclusive=None, rangeForm='outside',
                 level=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MultiRangeType, self).__init__(minInclusive, minExclusive, maxInclusive, maxExclusive, **kwargs_)
        self.rangeForm = _cast(None, rangeForm)
        self.rangeForm_nsprefix_ = None
        self.level = _cast(None, level)
        self.level_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MultiRangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MultiRangeType.subclass:
            return MultiRangeType.subclass(*args_, **kwargs_)
        else:
            return MultiRangeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_rangeForm(self):
        return self.rangeForm

    def set_rangeForm(self, rangeForm):
        self.rangeForm = rangeForm

    def get_level(self):
        return self.level

    def set_level(self, level):
        self.level = level

    def validate_RangeFormType(self, value):
        # Validate type xtce:RangeFormType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['outside', 'inside']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RangeFormType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_ConcernLevelsType(self, value):
        # Validate type xtce:ConcernLevelsType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'watch', 'warning', 'distress', 'critical', 'severe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ConcernLevelsType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(MultiRangeType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MultiRangeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MultiRangeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MultiRangeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MultiRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MultiRangeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MultiRangeType'):
        super(MultiRangeType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                     name_='MultiRangeType')
        if self.rangeForm != "outside" and 'rangeForm' not in already_processed:
            already_processed.add('rangeForm')
            outfile.write(' rangeForm=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.rangeForm), input_name='rangeForm')),))
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(
                ' level=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.level), input_name='level')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='MultiRangeType',
                       fromsubclass_=False, pretty_print=True):
        super(MultiRangeType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                   pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rangeForm', node)
        if value is not None and 'rangeForm' not in already_processed:
            already_processed.add('rangeForm')
            self.rangeForm = value
            self.validate_RangeFormType(self.rangeForm)  # validate type RangeFormType
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            self.level = value
            self.validate_ConcernLevelsType(self.level)  # validate type ConcernLevelsType
        super(MultiRangeType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(MultiRangeType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class MultiRangeType


class NumericAlarmType(AlarmType):
    """Describe alarm conditions specific to the numeric data types, extends
    the basic AlarmType with StaticAlarmRanges and ChangeAlarmRanges. See
    FloatParameterType and IntegerParameterType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, minViolations='1', minConformance=None,
                 AlarmConditions=None, CustomAlarm=None, StaticAlarmRanges=None, ChangeAlarmRanges=None,
                 AlarmMultiRanges=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NumericAlarmType, self).__init__(name, shortDescription, AncillaryDataSet, minViolations, minConformance,
                                               AlarmConditions, CustomAlarm, extensiontype_, **kwargs_)
        self.StaticAlarmRanges = StaticAlarmRanges
        self.StaticAlarmRanges_nsprefix_ = None
        self.ChangeAlarmRanges = ChangeAlarmRanges
        self.ChangeAlarmRanges_nsprefix_ = None
        self.AlarmMultiRanges = AlarmMultiRanges
        self.AlarmMultiRanges_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumericAlarmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumericAlarmType.subclass:
            return NumericAlarmType.subclass(*args_, **kwargs_)
        else:
            return NumericAlarmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_StaticAlarmRanges(self):
        return self.StaticAlarmRanges

    def set_StaticAlarmRanges(self, StaticAlarmRanges):
        self.StaticAlarmRanges = StaticAlarmRanges

    def get_ChangeAlarmRanges(self):
        return self.ChangeAlarmRanges

    def set_ChangeAlarmRanges(self, ChangeAlarmRanges):
        self.ChangeAlarmRanges = ChangeAlarmRanges

    def get_AlarmMultiRanges(self):
        return self.AlarmMultiRanges

    def set_AlarmMultiRanges(self, AlarmMultiRanges):
        self.AlarmMultiRanges = AlarmMultiRanges

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.StaticAlarmRanges is not None or
                self.ChangeAlarmRanges is not None or
                self.AlarmMultiRanges is not None or
                super(NumericAlarmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='NumericAlarmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumericAlarmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NumericAlarmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumericAlarmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NumericAlarmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NumericAlarmType'):
        super(NumericAlarmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                       name_='NumericAlarmType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='NumericAlarmType',
                       fromsubclass_=False, pretty_print=True):
        super(NumericAlarmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                     pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StaticAlarmRanges is not None:
            namespaceprefix_ = self.StaticAlarmRanges_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.StaticAlarmRanges_nsprefix_) else ''
            self.StaticAlarmRanges.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StaticAlarmRanges',
                                          pretty_print=pretty_print)
        if self.ChangeAlarmRanges is not None:
            namespaceprefix_ = self.ChangeAlarmRanges_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ChangeAlarmRanges_nsprefix_) else ''
            self.ChangeAlarmRanges.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ChangeAlarmRanges',
                                          pretty_print=pretty_print)
        if self.AlarmMultiRanges is not None:
            namespaceprefix_ = self.AlarmMultiRanges_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AlarmMultiRanges_nsprefix_) else ''
            self.AlarmMultiRanges.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AlarmMultiRanges',
                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NumericAlarmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'StaticAlarmRanges':
            class_obj_ = self.get_class_obj_(child_, AlarmRangesType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StaticAlarmRanges = obj_
            obj_.original_tagname_ = 'StaticAlarmRanges'
        elif nodeName_ == 'ChangeAlarmRanges':
            obj_ = ChangeAlarmRangesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ChangeAlarmRanges = obj_
            obj_.original_tagname_ = 'ChangeAlarmRanges'
        elif nodeName_ == 'AlarmMultiRanges':
            obj_ = AlarmMultiRangesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AlarmMultiRanges = obj_
            obj_.original_tagname_ = 'AlarmMultiRanges'
        super(NumericAlarmType, self).buildChildren(child_, node, nodeName_, True)


# end class NumericAlarmType


class NumericContextAlarmType(NumericAlarmType):
    """Describe a parameter dependent context, that when evaluates to true,
    enables the use of this alarm definition. See ContextMatchType and
    NumericAlarmType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NumericAlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, minViolations='1', minConformance=None,
                 AlarmConditions=None, CustomAlarm=None, StaticAlarmRanges=None, ChangeAlarmRanges=None,
                 AlarmMultiRanges=None, ContextMatch=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NumericContextAlarmType, self).__init__(name, shortDescription, AncillaryDataSet, minViolations,
                                                      minConformance, AlarmConditions, CustomAlarm, StaticAlarmRanges,
                                                      ChangeAlarmRanges, AlarmMultiRanges, **kwargs_)
        self.ContextMatch = ContextMatch
        self.ContextMatch_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumericContextAlarmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumericContextAlarmType.subclass:
            return NumericContextAlarmType.subclass(*args_, **kwargs_)
        else:
            return NumericContextAlarmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextMatch(self):
        return self.ContextMatch

    def set_ContextMatch(self, ContextMatch):
        self.ContextMatch = ContextMatch

    def hasContent_(self):
        if (
                self.ContextMatch is not None or
                super(NumericContextAlarmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='NumericContextAlarmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumericContextAlarmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NumericContextAlarmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumericContextAlarmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NumericContextAlarmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NumericContextAlarmType'):
        super(NumericContextAlarmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                              name_='NumericContextAlarmType')

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='NumericContextAlarmType', fromsubclass_=False, pretty_print=True):
        super(NumericContextAlarmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                            True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContextMatch is not None:
            namespaceprefix_ = self.ContextMatch_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextMatch_nsprefix_) else ''
            self.ContextMatch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextMatch',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(NumericContextAlarmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextMatch':
            obj_ = ContextMatchType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextMatch = obj_
            obj_.original_tagname_ = 'ContextMatch'
        super(NumericContextAlarmType, self).buildChildren(child_, node, nodeName_, True)


# end class NumericContextAlarmType


class StringAlarmLevelType(GeneratedsSuper):
    """Describe a string alarm condition based on matching a regular
    expression. The level and regular expression are described. The
    specific implementation of the regular expression syntax is not
    specified in the schema at this time. See StringAlarmListType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, alarmLevel=None, matchPattern=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.alarmLevel = _cast(None, alarmLevel)
        self.alarmLevel_nsprefix_ = None
        self.matchPattern = _cast(None, matchPattern)
        self.matchPattern_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringAlarmLevelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringAlarmLevelType.subclass:
            return StringAlarmLevelType.subclass(*args_, **kwargs_)
        else:
            return StringAlarmLevelType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_alarmLevel(self):
        return self.alarmLevel

    def set_alarmLevel(self, alarmLevel):
        self.alarmLevel = alarmLevel

    def get_matchPattern(self):
        return self.matchPattern

    def set_matchPattern(self, matchPattern):
        self.matchPattern = matchPattern

    def validate_ConcernLevelsType(self, value):
        # Validate type xtce:ConcernLevelsType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'watch', 'warning', 'distress', 'critical', 'severe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ConcernLevelsType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='StringAlarmLevelType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringAlarmLevelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StringAlarmLevelType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringAlarmLevelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringAlarmLevelType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StringAlarmLevelType'):
        if self.alarmLevel is not None and 'alarmLevel' not in already_processed:
            already_processed.add('alarmLevel')
            outfile.write(' alarmLevel=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.alarmLevel), input_name='alarmLevel')),))
        if self.matchPattern is not None and 'matchPattern' not in already_processed:
            already_processed.add('matchPattern')
            outfile.write(' matchPattern=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.matchPattern), input_name='matchPattern')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='StringAlarmLevelType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alarmLevel', node)
        if value is not None and 'alarmLevel' not in already_processed:
            already_processed.add('alarmLevel')
            self.alarmLevel = value
            self.validate_ConcernLevelsType(self.alarmLevel)  # validate type ConcernLevelsType
        value = find_attr_value_('matchPattern', node)
        if value is not None and 'matchPattern' not in already_processed:
            already_processed.add('matchPattern')
            self.matchPattern = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class StringAlarmLevelType


class StringAlarmListType(GeneratedsSuper):
    """Describe an ordered collection of string alarms, where duplicates are
    valid. Evaluate the alarms in list order. The first to evaluate to true
    takes precedence. See StringAlarmLevelType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, StringAlarm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if StringAlarm is None:
            self.StringAlarm = []
        else:
            self.StringAlarm = StringAlarm
        self.StringAlarm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringAlarmListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringAlarmListType.subclass:
            return StringAlarmListType.subclass(*args_, **kwargs_)
        else:
            return StringAlarmListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_StringAlarm(self):
        return self.StringAlarm

    def set_StringAlarm(self, StringAlarm):
        self.StringAlarm = StringAlarm

    def add_StringAlarm(self, value):
        self.StringAlarm.append(value)

    def insert_StringAlarm_at(self, index, value):
        self.StringAlarm.insert(index, value)

    def replace_StringAlarm_at(self, index, value):
        self.StringAlarm[index] = value

    def hasContent_(self):
        if (
                self.StringAlarm
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='StringAlarmListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringAlarmListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StringAlarmListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringAlarmListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringAlarmListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StringAlarmListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='StringAlarmListType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for StringAlarm_ in self.StringAlarm:
            namespaceprefix_ = self.StringAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.StringAlarm_nsprefix_) else ''
            StringAlarm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StringAlarm',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'StringAlarm':
            obj_ = StringAlarmLevelType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StringAlarm.append(obj_)
            obj_.original_tagname_ = 'StringAlarm'


# end class StringAlarmListType


class StringAlarmType(AlarmType):
    """Describe alarms specific to the string data type, extends the basic
    AlarmType, while adding a StringAlarmList and defaultAlarmLevel
    attribute. The string alarm list is evaluated in list order. See
    ConcernsLevelsType and StringAlarmListType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, minViolations='1', minConformance=None,
                 AlarmConditions=None, CustomAlarm=None, defaultAlarmLevel='normal', StringAlarmList=None,
                 extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(StringAlarmType, self).__init__(name, shortDescription, AncillaryDataSet, minViolations, minConformance,
                                              AlarmConditions, CustomAlarm, extensiontype_, **kwargs_)
        self.defaultAlarmLevel = _cast(None, defaultAlarmLevel)
        self.defaultAlarmLevel_nsprefix_ = None
        self.StringAlarmList = StringAlarmList
        self.StringAlarmList_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringAlarmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringAlarmType.subclass:
            return StringAlarmType.subclass(*args_, **kwargs_)
        else:
            return StringAlarmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_StringAlarmList(self):
        return self.StringAlarmList

    def set_StringAlarmList(self, StringAlarmList):
        self.StringAlarmList = StringAlarmList

    def get_defaultAlarmLevel(self):
        return self.defaultAlarmLevel

    def set_defaultAlarmLevel(self, defaultAlarmLevel):
        self.defaultAlarmLevel = defaultAlarmLevel

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_ConcernLevelsType(self, value):
        # Validate type xtce:ConcernLevelsType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'watch', 'warning', 'distress', 'critical', 'severe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ConcernLevelsType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.StringAlarmList is not None or
                super(StringAlarmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='StringAlarmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringAlarmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StringAlarmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringAlarmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringAlarmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StringAlarmType'):
        super(StringAlarmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                      name_='StringAlarmType')
        if self.defaultAlarmLevel != "normal" and 'defaultAlarmLevel' not in already_processed:
            already_processed.add('defaultAlarmLevel')
            outfile.write(' defaultAlarmLevel=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.defaultAlarmLevel), input_name='defaultAlarmLevel')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='StringAlarmType',
                       fromsubclass_=False, pretty_print=True):
        super(StringAlarmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                    pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StringAlarmList is not None:
            namespaceprefix_ = self.StringAlarmList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.StringAlarmList_nsprefix_) else ''
            self.StringAlarmList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StringAlarmList',
                                        pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('defaultAlarmLevel', node)
        if value is not None and 'defaultAlarmLevel' not in already_processed:
            already_processed.add('defaultAlarmLevel')
            self.defaultAlarmLevel = value
            self.validate_ConcernLevelsType(self.defaultAlarmLevel)  # validate type ConcernLevelsType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(StringAlarmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'StringAlarmList':
            obj_ = StringAlarmListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StringAlarmList = obj_
            obj_.original_tagname_ = 'StringAlarmList'
        super(StringAlarmType, self).buildChildren(child_, node, nodeName_, True)


# end class StringAlarmType


class StringContextAlarmType(StringAlarmType):
    """Describe a context that when true the alarm may be evaluated. See
    ContextMatchType and StringAlarmType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = StringAlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, minViolations='1', minConformance=None,
                 AlarmConditions=None, CustomAlarm=None, defaultAlarmLevel='normal', StringAlarmList=None,
                 ContextMatch=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(StringContextAlarmType, self).__init__(name, shortDescription, AncillaryDataSet, minViolations,
                                                     minConformance, AlarmConditions, CustomAlarm, defaultAlarmLevel,
                                                     StringAlarmList, **kwargs_)
        self.ContextMatch = ContextMatch
        self.ContextMatch_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringContextAlarmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringContextAlarmType.subclass:
            return StringContextAlarmType.subclass(*args_, **kwargs_)
        else:
            return StringContextAlarmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextMatch(self):
        return self.ContextMatch

    def set_ContextMatch(self, ContextMatch):
        self.ContextMatch = ContextMatch

    def hasContent_(self):
        if (
                self.ContextMatch is not None or
                super(StringContextAlarmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='StringContextAlarmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringContextAlarmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StringContextAlarmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringContextAlarmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringContextAlarmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StringContextAlarmType'):
        super(StringContextAlarmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                             name_='StringContextAlarmType')

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='StringContextAlarmType', fromsubclass_=False, pretty_print=True):
        super(StringContextAlarmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                           pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContextMatch is not None:
            namespaceprefix_ = self.ContextMatch_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextMatch_nsprefix_) else ''
            self.ContextMatch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextMatch',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(StringContextAlarmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextMatch':
            obj_ = ContextMatchType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextMatch = obj_
            obj_.original_tagname_ = 'ContextMatch'
        super(StringContextAlarmType, self).buildChildren(child_, node, nodeName_, True)


# end class StringContextAlarmType


class StringContextAlarmListType(GeneratedsSuper):
    """An ordered collection of numeric alarms associated with a context.
    Process the contexts in list order. See StringContextAlarmType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ContextAlarm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ContextAlarm is None:
            self.ContextAlarm = []
        else:
            self.ContextAlarm = ContextAlarm
        self.ContextAlarm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringContextAlarmListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringContextAlarmListType.subclass:
            return StringContextAlarmListType.subclass(*args_, **kwargs_)
        else:
            return StringContextAlarmListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextAlarm(self):
        return self.ContextAlarm

    def set_ContextAlarm(self, ContextAlarm):
        self.ContextAlarm = ContextAlarm

    def add_ContextAlarm(self, value):
        self.ContextAlarm.append(value)

    def insert_ContextAlarm_at(self, index, value):
        self.ContextAlarm.insert(index, value)

    def replace_ContextAlarm_at(self, index, value):
        self.ContextAlarm[index] = value

    def hasContent_(self):
        if (
                self.ContextAlarm
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='StringContextAlarmListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringContextAlarmListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StringContextAlarmListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringContextAlarmListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringContextAlarmListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='StringContextAlarmListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='StringContextAlarmListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContextAlarm_ in self.ContextAlarm:
            namespaceprefix_ = self.ContextAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextAlarm_nsprefix_) else ''
            ContextAlarm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextAlarm',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextAlarm':
            obj_ = StringContextAlarmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextAlarm.append(obj_)
            obj_.original_tagname_ = 'ContextAlarm'


# end class StringContextAlarmListType


class TimeAlarmType(AlarmType):
    """Alarms associated with time data types"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, minViolations='1', minConformance=None,
                 AlarmConditions=None, CustomAlarm=None, StaticAlarmRanges=None, ChangePerSecondAlarmRanges=None,
                 extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TimeAlarmType, self).__init__(name, shortDescription, AncillaryDataSet, minViolations, minConformance,
                                            AlarmConditions, CustomAlarm, extensiontype_, **kwargs_)
        self.StaticAlarmRanges = StaticAlarmRanges
        self.StaticAlarmRanges_nsprefix_ = None
        self.ChangePerSecondAlarmRanges = ChangePerSecondAlarmRanges
        self.ChangePerSecondAlarmRanges_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeAlarmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeAlarmType.subclass:
            return TimeAlarmType.subclass(*args_, **kwargs_)
        else:
            return TimeAlarmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_StaticAlarmRanges(self):
        return self.StaticAlarmRanges

    def set_StaticAlarmRanges(self, StaticAlarmRanges):
        self.StaticAlarmRanges = StaticAlarmRanges

    def get_ChangePerSecondAlarmRanges(self):
        return self.ChangePerSecondAlarmRanges

    def set_ChangePerSecondAlarmRanges(self, ChangePerSecondAlarmRanges):
        self.ChangePerSecondAlarmRanges = ChangePerSecondAlarmRanges

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.StaticAlarmRanges is not None or
                self.ChangePerSecondAlarmRanges is not None or
                super(TimeAlarmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='TimeAlarmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeAlarmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeAlarmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeAlarmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeAlarmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeAlarmType'):
        super(TimeAlarmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                    name_='TimeAlarmType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='TimeAlarmType',
                       fromsubclass_=False, pretty_print=True):
        super(TimeAlarmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                  pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StaticAlarmRanges is not None:
            namespaceprefix_ = self.StaticAlarmRanges_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.StaticAlarmRanges_nsprefix_) else ''
            self.StaticAlarmRanges.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StaticAlarmRanges',
                                          pretty_print=pretty_print)
        if self.ChangePerSecondAlarmRanges is not None:
            namespaceprefix_ = self.ChangePerSecondAlarmRanges_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ChangePerSecondAlarmRanges_nsprefix_) else ''
            self.ChangePerSecondAlarmRanges.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                   name_='ChangePerSecondAlarmRanges', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(TimeAlarmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'StaticAlarmRanges':
            obj_ = TimeAlarmRangesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StaticAlarmRanges = obj_
            obj_.original_tagname_ = 'StaticAlarmRanges'
        elif nodeName_ == 'ChangePerSecondAlarmRanges':
            obj_ = TimeAlarmRangesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ChangePerSecondAlarmRanges = obj_
            obj_.original_tagname_ = 'ChangePerSecondAlarmRanges'
        super(TimeAlarmType, self).buildChildren(child_, node, nodeName_, True)


# end class TimeAlarmType


class TimeAlarmRangesType(AlarmRangesType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AlarmRangesType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, rangeForm='outside', WatchRange=None,
                 WarningRange=None, DistressRange=None, CriticalRange=None, SevereRange=None, timeUnits='seconds',
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TimeAlarmRangesType, self).__init__(name, shortDescription, AncillaryDataSet, rangeForm, WatchRange,
                                                  WarningRange, DistressRange, CriticalRange, SevereRange, **kwargs_)
        self.timeUnits = _cast(None, timeUnits)
        self.timeUnits_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeAlarmRangesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeAlarmRangesType.subclass:
            return TimeAlarmRangesType.subclass(*args_, **kwargs_)
        else:
            return TimeAlarmRangesType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_timeUnits(self):
        return self.timeUnits

    def set_timeUnits(self, timeUnits):
        self.timeUnits = timeUnits

    def validate_TimeUnitsType(self, value):
        # Validate type xtce:TimeUnitsType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['seconds', 'picoSeconds', 'days', 'months', 'years']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TimeUnitsType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(TimeAlarmRangesType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='TimeAlarmRangesType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeAlarmRangesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeAlarmRangesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeAlarmRangesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeAlarmRangesType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeAlarmRangesType'):
        super(TimeAlarmRangesType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                          name_='TimeAlarmRangesType')
        if self.timeUnits != "seconds" and 'timeUnits' not in already_processed:
            already_processed.add('timeUnits')
            outfile.write(' timeUnits=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.timeUnits), input_name='timeUnits')),))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='TimeAlarmRangesType',
                       fromsubclass_=False, pretty_print=True):
        super(TimeAlarmRangesType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                        pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timeUnits', node)
        if value is not None and 'timeUnits' not in already_processed:
            already_processed.add('timeUnits')
            self.timeUnits = value
            self.validate_TimeUnitsType(self.timeUnits)  # validate type TimeUnitsType
        super(TimeAlarmRangesType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TimeAlarmRangesType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class TimeAlarmRangesType


class TimeContextAlarmListType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ContextAlarm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ContextAlarm is None:
            self.ContextAlarm = []
        else:
            self.ContextAlarm = ContextAlarm
        self.ContextAlarm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeContextAlarmListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeContextAlarmListType.subclass:
            return TimeContextAlarmListType.subclass(*args_, **kwargs_)
        else:
            return TimeContextAlarmListType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextAlarm(self):
        return self.ContextAlarm

    def set_ContextAlarm(self, ContextAlarm):
        self.ContextAlarm = ContextAlarm

    def add_ContextAlarm(self, value):
        self.ContextAlarm.append(value)

    def insert_ContextAlarm_at(self, index, value):
        self.ContextAlarm.insert(index, value)

    def replace_ContextAlarm_at(self, index, value):
        self.ContextAlarm[index] = value

    def hasContent_(self):
        if (
                self.ContextAlarm
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='TimeContextAlarmListType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeContextAlarmListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeContextAlarmListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeContextAlarmListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeContextAlarmListType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='TimeContextAlarmListType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"',
                       name_='TimeContextAlarmListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContextAlarm_ in self.ContextAlarm:
            namespaceprefix_ = self.ContextAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextAlarm_nsprefix_) else ''
            ContextAlarm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextAlarm',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextAlarm':
            obj_ = TimeContextAlarmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextAlarm.append(obj_)
            obj_.original_tagname_ = 'ContextAlarm'


# end class TimeContextAlarmListType


class TimeContextAlarmType(TimeAlarmType):
    """Context alarms are applied when the ContextMatch is true. Context alarms
    override Default alarms"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TimeAlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, minViolations='1', minConformance=None,
                 AlarmConditions=None, CustomAlarm=None, StaticAlarmRanges=None, ChangePerSecondAlarmRanges=None,
                 ContextMatch=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TimeContextAlarmType, self).__init__(name, shortDescription, AncillaryDataSet, minViolations,
                                                   minConformance, AlarmConditions, CustomAlarm, StaticAlarmRanges,
                                                   ChangePerSecondAlarmRanges, **kwargs_)
        self.ContextMatch = ContextMatch
        self.ContextMatch_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeContextAlarmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeContextAlarmType.subclass:
            return TimeContextAlarmType.subclass(*args_, **kwargs_)
        else:
            return TimeContextAlarmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextMatch(self):
        return self.ContextMatch

    def set_ContextMatch(self, ContextMatch):
        self.ContextMatch = ContextMatch

    def hasContent_(self):
        if (
                self.ContextMatch is not None or
                super(TimeContextAlarmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='TimeContextAlarmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeContextAlarmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeContextAlarmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeContextAlarmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeContextAlarmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeContextAlarmType'):
        super(TimeContextAlarmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='TimeContextAlarmType')

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='TimeContextAlarmType',
                       fromsubclass_=False, pretty_print=True):
        super(TimeContextAlarmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContextMatch is not None:
            namespaceprefix_ = self.ContextMatch_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextMatch_nsprefix_) else ''
            self.ContextMatch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextMatch',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(TimeContextAlarmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextMatch':
            obj_ = ContextMatchType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextMatch = obj_
            obj_.original_tagname_ = 'ContextMatch'
        super(TimeContextAlarmType, self).buildChildren(child_, node, nodeName_, True)


# end class TimeContextAlarmType


class ValidRangeType(FloatRangeType):
    """The Valid Range provides additional boundary/constraint information
    beyond that of the data encoding in the range of possible values that
    are meaningful to this parameter. Not to be construed as an alarm
    definition, violations of the valid range make a parameter value
    "unreasonable", as opposed to reasonable to be reported, but in a state
    which should be of concern.By default and general recommendation, the
    valid range is specified in engineering/calibrated values, although
    this can be adjusted."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FloatRangeType

    def __init__(self, minInclusive=None, minExclusive=None, maxInclusive=None, maxExclusive=None,
                 validRangeAppliesToCalibrated=True, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ValidRangeType, self).__init__(minInclusive, minExclusive, maxInclusive, maxExclusive, **kwargs_)
        self.validRangeAppliesToCalibrated = _cast(bool, validRangeAppliesToCalibrated)
        self.validRangeAppliesToCalibrated_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValidRangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValidRangeType.subclass:
            return ValidRangeType.subclass(*args_, **kwargs_)
        else:
            return ValidRangeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_validRangeAppliesToCalibrated(self):
        return self.validRangeAppliesToCalibrated

    def set_validRangeAppliesToCalibrated(self, validRangeAppliesToCalibrated):
        self.validRangeAppliesToCalibrated = validRangeAppliesToCalibrated

    def hasContent_(self):
        if (
                super(ValidRangeType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ValidRangeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ValidRangeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ValidRangeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ValidRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ValidRangeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ValidRangeType'):
        super(ValidRangeType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                     name_='ValidRangeType')
        if not self.validRangeAppliesToCalibrated and 'validRangeAppliesToCalibrated' not in already_processed:
            already_processed.add('validRangeAppliesToCalibrated')
            outfile.write(
                ' validRangeAppliesToCalibrated="%s"' % self.gds_format_boolean(self.validRangeAppliesToCalibrated,
                                                                                input_name='validRangeAppliesToCalibrated'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ValidRangeType',
                       fromsubclass_=False, pretty_print=True):
        super(ValidRangeType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                   pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('validRangeAppliesToCalibrated', node)
        if value is not None and 'validRangeAppliesToCalibrated' not in already_processed:
            already_processed.add('validRangeAppliesToCalibrated')
            if value in ('true', '1'):
                self.validRangeAppliesToCalibrated = True
            elif value in ('false', '0'):
                self.validRangeAppliesToCalibrated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(ValidRangeType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ValidRangeType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ValidRangeType


class ValidRangeType1(IntegerRangeType):
    """The Valid Range provides additional boundary/constraint information
    beyond that of the data encoding in the range of possible values that
    are meaningful to this parameter. Not to be construed as an alarm
    definition, violations of the valid range make a parameter value
    "unreasonable", as opposed to reasonable to be reported, but in a state
    which should be of concern.By default and general recommendation, the
    valid range is specified in engineering/calibrated values, although
    this can be adjusted."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IntegerRangeType

    def __init__(self, minInclusive=None, maxInclusive=None, validRangeAppliesToCalibrated=True, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ValidRangeType1, self).__init__(minInclusive, maxInclusive, **kwargs_)
        self.validRangeAppliesToCalibrated = _cast(bool, validRangeAppliesToCalibrated)
        self.validRangeAppliesToCalibrated_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValidRangeType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValidRangeType1.subclass:
            return ValidRangeType1.subclass(*args_, **kwargs_)
        else:
            return ValidRangeType1(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_validRangeAppliesToCalibrated(self):
        return self.validRangeAppliesToCalibrated

    def set_validRangeAppliesToCalibrated(self, validRangeAppliesToCalibrated):
        self.validRangeAppliesToCalibrated = validRangeAppliesToCalibrated

    def hasContent_(self):
        if (
                super(ValidRangeType1, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ValidRangeType1',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ValidRangeType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ValidRangeType1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ValidRangeType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ValidRangeType1',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ValidRangeType1'):
        super(ValidRangeType1, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                      name_='ValidRangeType1')
        if not self.validRangeAppliesToCalibrated and 'validRangeAppliesToCalibrated' not in already_processed:
            already_processed.add('validRangeAppliesToCalibrated')
            outfile.write(
                ' validRangeAppliesToCalibrated="%s"' % self.gds_format_boolean(self.validRangeAppliesToCalibrated,
                                                                                input_name='validRangeAppliesToCalibrated'))

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='ValidRangeType1',
                       fromsubclass_=False, pretty_print=True):
        super(ValidRangeType1, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                    pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('validRangeAppliesToCalibrated', node)
        if value is not None and 'validRangeAppliesToCalibrated' not in already_processed:
            already_processed.add('validRangeAppliesToCalibrated')
            if value in ('true', '1'):
                self.validRangeAppliesToCalibrated = True
            elif value in ('false', '0'):
                self.validRangeAppliesToCalibrated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(ValidRangeType1, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ValidRangeType1, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ValidRangeType1


class FixedType(GeneratedsSuper):
    """This is the simplest case of a string data type where the encoding size
    of the string does not change."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, FixedValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.FixedValue = FixedValue
        self.validate_PositiveLongType(self.FixedValue)
        self.FixedValue_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FixedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FixedType.subclass:
            return FixedType.subclass(*args_, **kwargs_)
        else:
            return FixedType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_FixedValue(self):
        return self.FixedValue

    def set_FixedValue(self, FixedValue):
        self.FixedValue = FixedValue

    def validate_PositiveLongType(self, value):
        result = True
        # Validate type PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False
        return result

    def hasContent_(self):
        if (
                self.FixedValue is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='FixedType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FixedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FixedType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FixedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FixedType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FixedType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='',
                       namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"', name_='FixedType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FixedValue is not None:
            namespaceprefix_ = self.FixedValue_nsprefix_ + ':' if (UseCapturedNS_ and self.FixedValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFixedValue>%s</%sFixedValue>%s' % (
            namespaceprefix_, self.gds_format_integer(self.FixedValue, input_name='FixedValue'), namespaceprefix_,
            eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FixedValue' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'FixedValue')
            ival_ = self.gds_validate_integer(ival_, node, 'FixedValue')
            self.FixedValue = ival_
            self.FixedValue_nsprefix_ = child_.prefix
            # validate type PositiveLongType
            self.validate_PositiveLongType(self.FixedValue)


# end class FixedType


class EnumerationContextAlarmType(EnumerationAlarmType):
    """Describe a context that when true the alarm condition may be evaluated.
    See ContextMatchType and EnumerationAlarmType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EnumerationAlarmType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, minViolations='1', minConformance=None,
                 AlarmConditions=None, CustomAlarm=None, defaultAlarmLevel='normal', EnumerationAlarmList=None,
                 ContextMatch=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EnumerationContextAlarmType, self).__init__(name, shortDescription, AncillaryDataSet, minViolations,
                                                          minConformance, AlarmConditions, CustomAlarm,
                                                          defaultAlarmLevel, EnumerationAlarmList, **kwargs_)
        self.ContextMatch = ContextMatch
        self.ContextMatch_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnumerationContextAlarmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnumerationContextAlarmType.subclass:
            return EnumerationContextAlarmType.subclass(*args_, **kwargs_)
        else:
            return EnumerationContextAlarmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContextMatch(self):
        return self.ContextMatch

    def set_ContextMatch(self, ContextMatch):
        self.ContextMatch = ContextMatch

    def hasContent_(self):
        if (
                self.ContextMatch is not None or
                super(EnumerationContextAlarmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnumerationContextAlarmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnumerationContextAlarmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EnumerationContextAlarmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnumerationContextAlarmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='EnumerationContextAlarmType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='EnumerationContextAlarmType'):
        super(EnumerationContextAlarmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                  name_='EnumerationContextAlarmType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnumerationContextAlarmType',
                       fromsubclass_=False, pretty_print=True):
        super(EnumerationContextAlarmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                                True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContextMatch is not None:
            namespaceprefix_ = self.ContextMatch_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextMatch_nsprefix_) else ''
            self.ContextMatch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextMatch',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(EnumerationContextAlarmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContextMatch':
            obj_ = ContextMatchType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextMatch = obj_
            obj_.original_tagname_ = 'ContextMatch'
        super(EnumerationContextAlarmType, self).buildChildren(child_, node, nodeName_, True)


# end class EnumerationContextAlarmType


class ContextMatchType(MatchCriteriaType):
    """A MatchCriteriaType used for Context selection."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MatchCriteriaType

    def __init__(self, Comparison=None, ComparisonList=None, BooleanExpression=None, CustomAlgorithm=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ContextMatchType, self).__init__(Comparison, ComparisonList, BooleanExpression, CustomAlgorithm,
                                               **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContextMatchType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContextMatchType.subclass:
            return ContextMatchType.subclass(*args_, **kwargs_)
        else:
            return ContextMatchType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(ContextMatchType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContextMatchType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContextMatchType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContextMatchType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContextMatchType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContextMatchType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContextMatchType'):
        super(ContextMatchType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                       name_='ContextMatchType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContextMatchType',
                       fromsubclass_=False, pretty_print=True):
        super(ContextMatchType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(ContextMatchType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ContextMatchType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ContextMatchType


class ANDedConditionsType(BaseConditionsType):
    """Describe two or more conditions that are logically anded together.
    Conditions may be a mix of Condition and ORedCondition. See
    ORedConditionType and BooleanExpressionType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseConditionsType

    def __init__(self, Condition=None, ORedConditions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ANDedConditionsType, self).__init__(**kwargs_)
        if Condition is None:
            self.Condition = []
        else:
            self.Condition = Condition
        self.Condition_nsprefix_ = None
        if ORedConditions is None:
            self.ORedConditions = []
        else:
            self.ORedConditions = ORedConditions
        self.ORedConditions_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANDedConditionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANDedConditionsType.subclass:
            return ANDedConditionsType.subclass(*args_, **kwargs_)
        else:
            return ANDedConditionsType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Condition(self):
        return self.Condition

    def set_Condition(self, Condition):
        self.Condition = Condition

    def add_Condition(self, value):
        self.Condition.append(value)

    def insert_Condition_at(self, index, value):
        self.Condition.insert(index, value)

    def replace_Condition_at(self, index, value):
        self.Condition[index] = value

    def get_ORedConditions(self):
        return self.ORedConditions

    def set_ORedConditions(self, ORedConditions):
        self.ORedConditions = ORedConditions

    def add_ORedConditions(self, value):
        self.ORedConditions.append(value)

    def insert_ORedConditions_at(self, index, value):
        self.ORedConditions.insert(index, value)

    def replace_ORedConditions_at(self, index, value):
        self.ORedConditions[index] = value

    def hasContent_(self):
        if (
                self.Condition or
                self.ORedConditions or
                super(ANDedConditionsType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANDedConditionsType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANDedConditionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANDedConditionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANDedConditionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ANDedConditionsType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANDedConditionsType'):
        super(ANDedConditionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                          name_='ANDedConditionsType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANDedConditionsType',
                       fromsubclass_=False, pretty_print=True):
        super(ANDedConditionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                        pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Condition_ in self.Condition:
            namespaceprefix_ = self.Condition_nsprefix_ + ':' if (UseCapturedNS_ and self.Condition_nsprefix_) else ''
            Condition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Condition',
                              pretty_print=pretty_print)
        for ORedConditions_ in self.ORedConditions:
            namespaceprefix_ = self.ORedConditions_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ORedConditions_nsprefix_) else ''
            ORedConditions_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ORedConditions',
                                   pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(ANDedConditionsType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Condition':
            obj_ = ComparisonCheckType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Condition.append(obj_)
            obj_.original_tagname_ = 'Condition'
        elif nodeName_ == 'ORedConditions':
            obj_ = ORedConditionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ORedConditions.append(obj_)
            obj_.original_tagname_ = 'ORedConditions'
        super(ANDedConditionsType, self).buildChildren(child_, node, nodeName_, True)


# end class ANDedConditionsType


class BinaryDataEncodingType(DataEncodingType):
    """Describe binary data that is unmolested in the decoding/encoding or
    cannot be represented in any of the other data encoding formats.
    Optionally use the FromBinaryTransformAlgorithm and
    ToBinaryTransformAlgorithm element to describe the transformation
    process. See InputAlgorithmType for the transformation structure."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataEncodingType

    def __init__(self, bitOrder='mostSignificantBitFirst', byteOrder='mostSignificantByteFirst',
                 ErrorDetectCorrect=None, SizeInBits=None, FromBinaryTransformAlgorithm=None,
                 ToBinaryTransformAlgorithm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BinaryDataEncodingType, self).__init__(bitOrder, byteOrder, ErrorDetectCorrect, **kwargs_)
        self.SizeInBits = SizeInBits
        self.SizeInBits_nsprefix_ = None
        self.FromBinaryTransformAlgorithm = FromBinaryTransformAlgorithm
        self.FromBinaryTransformAlgorithm_nsprefix_ = None
        self.ToBinaryTransformAlgorithm = ToBinaryTransformAlgorithm
        self.ToBinaryTransformAlgorithm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BinaryDataEncodingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BinaryDataEncodingType.subclass:
            return BinaryDataEncodingType.subclass(*args_, **kwargs_)
        else:
            return BinaryDataEncodingType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SizeInBits(self):
        return self.SizeInBits

    def set_SizeInBits(self, SizeInBits):
        self.SizeInBits = SizeInBits

    def get_FromBinaryTransformAlgorithm(self):
        return self.FromBinaryTransformAlgorithm

    def set_FromBinaryTransformAlgorithm(self, FromBinaryTransformAlgorithm):
        self.FromBinaryTransformAlgorithm = FromBinaryTransformAlgorithm

    def get_ToBinaryTransformAlgorithm(self):
        return self.ToBinaryTransformAlgorithm

    def set_ToBinaryTransformAlgorithm(self, ToBinaryTransformAlgorithm):
        self.ToBinaryTransformAlgorithm = ToBinaryTransformAlgorithm

    def hasContent_(self):
        if (
                self.SizeInBits is not None or
                self.FromBinaryTransformAlgorithm is not None or
                self.ToBinaryTransformAlgorithm is not None or
                super(BinaryDataEncodingType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BinaryDataEncodingType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BinaryDataEncodingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BinaryDataEncodingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BinaryDataEncodingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BinaryDataEncodingType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BinaryDataEncodingType'):
        super(BinaryDataEncodingType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                             name_='BinaryDataEncodingType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BinaryDataEncodingType',
                       fromsubclass_=False, pretty_print=True):
        super(BinaryDataEncodingType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                           pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SizeInBits is not None:
            namespaceprefix_ = self.SizeInBits_nsprefix_ + ':' if (UseCapturedNS_ and self.SizeInBits_nsprefix_) else ''
            self.SizeInBits.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SizeInBits',
                                   pretty_print=pretty_print)
        if self.FromBinaryTransformAlgorithm is not None:
            namespaceprefix_ = self.FromBinaryTransformAlgorithm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.FromBinaryTransformAlgorithm_nsprefix_) else ''
            self.FromBinaryTransformAlgorithm.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                     name_='FromBinaryTransformAlgorithm', pretty_print=pretty_print)
        if self.ToBinaryTransformAlgorithm is not None:
            namespaceprefix_ = self.ToBinaryTransformAlgorithm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ToBinaryTransformAlgorithm_nsprefix_) else ''
            self.ToBinaryTransformAlgorithm.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                   name_='ToBinaryTransformAlgorithm', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(BinaryDataEncodingType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SizeInBits':
            class_obj_ = self.get_class_obj_(child_, IntegerValueType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SizeInBits = obj_
            obj_.original_tagname_ = 'SizeInBits'
        elif nodeName_ == 'FromBinaryTransformAlgorithm':
            class_obj_ = self.get_class_obj_(child_, InputAlgorithmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FromBinaryTransformAlgorithm = obj_
            obj_.original_tagname_ = 'FromBinaryTransformAlgorithm'
        elif nodeName_ == 'ToBinaryTransformAlgorithm':
            class_obj_ = self.get_class_obj_(child_, InputAlgorithmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ToBinaryTransformAlgorithm = obj_
            obj_.original_tagname_ = 'ToBinaryTransformAlgorithm'
        super(BinaryDataEncodingType, self).buildChildren(child_, node, nodeName_, True)


# end class BinaryDataEncodingType


class ArgumentBinaryDataEncodingType(DataEncodingType):
    """Identical to BinaryDataEncodingType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DataEncodingType

    def __init__(self, bitOrder='mostSignificantBitFirst', byteOrder='mostSignificantByteFirst',
                 ErrorDetectCorrect=None, SizeInBits=None, FromBinaryTransformAlgorithm=None,
                 ToBinaryTransformAlgorithm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentBinaryDataEncodingType, self).__init__(bitOrder, byteOrder, ErrorDetectCorrect, **kwargs_)
        self.SizeInBits = SizeInBits
        self.SizeInBits_nsprefix_ = None
        self.FromBinaryTransformAlgorithm = FromBinaryTransformAlgorithm
        self.FromBinaryTransformAlgorithm_nsprefix_ = None
        self.ToBinaryTransformAlgorithm = ToBinaryTransformAlgorithm
        self.ToBinaryTransformAlgorithm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentBinaryDataEncodingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentBinaryDataEncodingType.subclass:
            return ArgumentBinaryDataEncodingType.subclass(*args_, **kwargs_)
        else:
            return ArgumentBinaryDataEncodingType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SizeInBits(self):
        return self.SizeInBits

    def set_SizeInBits(self, SizeInBits):
        self.SizeInBits = SizeInBits

    def get_FromBinaryTransformAlgorithm(self):
        return self.FromBinaryTransformAlgorithm

    def set_FromBinaryTransformAlgorithm(self, FromBinaryTransformAlgorithm):
        self.FromBinaryTransformAlgorithm = FromBinaryTransformAlgorithm

    def get_ToBinaryTransformAlgorithm(self):
        return self.ToBinaryTransformAlgorithm

    def set_ToBinaryTransformAlgorithm(self, ToBinaryTransformAlgorithm):
        self.ToBinaryTransformAlgorithm = ToBinaryTransformAlgorithm

    def hasContent_(self):
        if (
                self.SizeInBits is not None or
                self.FromBinaryTransformAlgorithm is not None or
                self.ToBinaryTransformAlgorithm is not None or
                super(ArgumentBinaryDataEncodingType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentBinaryDataEncodingType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentBinaryDataEncodingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentBinaryDataEncodingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='ArgumentBinaryDataEncodingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentBinaryDataEncodingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentBinaryDataEncodingType'):
        super(ArgumentBinaryDataEncodingType, self).exportAttributes(outfile, level, already_processed,
                                                                     namespaceprefix_,
                                                                     name_='ArgumentBinaryDataEncodingType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ArgumentBinaryDataEncodingType', fromsubclass_=False, pretty_print=True):
        super(ArgumentBinaryDataEncodingType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_,
                                                                   name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SizeInBits is not None:
            namespaceprefix_ = self.SizeInBits_nsprefix_ + ':' if (UseCapturedNS_ and self.SizeInBits_nsprefix_) else ''
            self.SizeInBits.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SizeInBits',
                                   pretty_print=pretty_print)
        if self.FromBinaryTransformAlgorithm is not None:
            namespaceprefix_ = self.FromBinaryTransformAlgorithm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.FromBinaryTransformAlgorithm_nsprefix_) else ''
            self.FromBinaryTransformAlgorithm.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                     name_='FromBinaryTransformAlgorithm', pretty_print=pretty_print)
        if self.ToBinaryTransformAlgorithm is not None:
            namespaceprefix_ = self.ToBinaryTransformAlgorithm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ToBinaryTransformAlgorithm_nsprefix_) else ''
            self.ToBinaryTransformAlgorithm.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                   name_='ToBinaryTransformAlgorithm', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(ArgumentBinaryDataEncodingType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SizeInBits':
            class_obj_ = self.get_class_obj_(child_, ArgumentIntegerValueType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SizeInBits = obj_
            obj_.original_tagname_ = 'SizeInBits'
        elif nodeName_ == 'FromBinaryTransformAlgorithm':
            obj_ = ArgumentInputAlgorithmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FromBinaryTransformAlgorithm = obj_
            obj_.original_tagname_ = 'FromBinaryTransformAlgorithm'
        elif nodeName_ == 'ToBinaryTransformAlgorithm':
            obj_ = ArgumentInputAlgorithmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ToBinaryTransformAlgorithm = obj_
            obj_.original_tagname_ = 'ToBinaryTransformAlgorithm'
        super(ArgumentBinaryDataEncodingType, self).buildChildren(child_, node, nodeName_, True)


# end class ArgumentBinaryDataEncodingType


class MemberType(NameDescriptionType):
    """Describe a member field in an AggregateDataType. Each member has a name
    and a type reference to a data type for the aggregate member name. If
    this aggregate is a Parameter aggregate, then the typeRef is a
    parameter type reference. If this aggregate is an Argument aggregate,
    then the typeRef is an argument type reference. References to an array
    data type is currently not supported. Circular references are not
    allowed. See MemberListType. AggregateParameterType and
    AggregateArgumentType.Used to set the initial calibrated values of
    Parameters. Will overwrite an initial value defined for the
    ParameterType. For integer types base 10 (decimal) form is assumed
    unless: if proceeded by a 0b or 0B, value is in base two (binary form,
    if proceeded by a 0o or 0O, values is in base 8 (octal) form, or if
    proceeded by a 0x or 0X, value is in base 16 (hex) form. Floating point
    types may be specified in normal (100.0) or scientific (1.0e2) form.
    Time types are specified using the ISO 8601 formats described for XTCE
    time data types. Initial values for string types, may include C
    language style (\n, \t, \", \\, etc.) escape sequences."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 typeRef=None, initialValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MemberType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name, **kwargs_)
        self.typeRef = _cast(None, typeRef)
        self.typeRef_nsprefix_ = None
        self.initialValue = _cast(None, initialValue)
        self.initialValue_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MemberType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MemberType.subclass:
            return MemberType.subclass(*args_, **kwargs_)
        else:
            return MemberType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_typeRef(self):
        return self.typeRef

    def set_typeRef(self, typeRef):
        self.typeRef = typeRef

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                super(MemberType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MemberType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MemberType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MemberType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MemberType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MemberType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MemberType'):
        super(MemberType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                 name_='MemberType')
        if self.typeRef is not None and 'typeRef' not in already_processed:
            already_processed.add('typeRef')
            outfile.write(' typeRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.typeRef), input_name='typeRef')),))
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.initialValue), input_name='initialValue')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MemberType',
                       fromsubclass_=False, pretty_print=True):
        super(MemberType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                               pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('typeRef', node)
        if value is not None and 'typeRef' not in already_processed:
            already_processed.add('typeRef')
            self.typeRef = value
            self.validate_NameReferenceType(self.typeRef)  # validate type NameReferenceType
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            self.initialValue = value
        super(MemberType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(MemberType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class MemberType


class BaseTimeDataType(NameDescriptionType):
    """An abstract schema type used within the schema to derive other time
    based data types: RelativeTimeDataType and AbsoluteTimeDataType. An
    absolute time data type is a telemetered source/destination data type.
    A data encoding must be set. An optional epoch may be set. Time types
    are an exception to other primitives because, if the time data type is
    not telemetered, it still must have a data encoding set. See
    DataEncodingType, AbsoluteTimeDataType and RelativeTimeDataType.Extend
    another absolute or relative time type."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, Encoding=None, ReferenceTime=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BaseTimeDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                               extensiontype_, **kwargs_)
        self.baseType = _cast(None, baseType)
        self.baseType_nsprefix_ = None
        self.Encoding = Encoding
        self.Encoding_nsprefix_ = None
        self.ReferenceTime = ReferenceTime
        self.ReferenceTime_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseTimeDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseTimeDataType.subclass:
            return BaseTimeDataType.subclass(*args_, **kwargs_)
        else:
            return BaseTimeDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Encoding(self):
        return self.Encoding

    def set_Encoding(self, Encoding):
        self.Encoding = Encoding

    def get_ReferenceTime(self):
        return self.ReferenceTime

    def set_ReferenceTime(self, ReferenceTime):
        self.ReferenceTime = ReferenceTime

    def get_baseType(self):
        return self.baseType

    def set_baseType(self, baseType):
        self.baseType = baseType

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                self.Encoding is not None or
                self.ReferenceTime is not None or
                super(BaseTimeDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseTimeDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseTimeDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BaseTimeDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseTimeDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseTimeDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseTimeDataType'):
        super(BaseTimeDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                       name_='BaseTimeDataType')
        if self.baseType is not None and 'baseType' not in already_processed:
            already_processed.add('baseType')
            outfile.write(' baseType=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.baseType), input_name='baseType')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseTimeDataType',
                       fromsubclass_=False, pretty_print=True):
        super(BaseTimeDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                     pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Encoding is not None:
            namespaceprefix_ = self.Encoding_nsprefix_ + ':' if (UseCapturedNS_ and self.Encoding_nsprefix_) else ''
            self.Encoding.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Encoding',
                                 pretty_print=pretty_print)
        if self.ReferenceTime is not None:
            namespaceprefix_ = self.ReferenceTime_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ReferenceTime_nsprefix_) else ''
            self.ReferenceTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReferenceTime',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('baseType', node)
        if value is not None and 'baseType' not in already_processed:
            already_processed.add('baseType')
            self.baseType = value
            self.validate_NameReferenceType(self.baseType)  # validate type NameReferenceType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseTimeDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Encoding':
            obj_ = EncodingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Encoding = obj_
            obj_.original_tagname_ = 'Encoding'
        elif nodeName_ == 'ReferenceTime':
            obj_ = ReferenceTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReferenceTime = obj_
            obj_.original_tagname_ = 'ReferenceTime'
        super(BaseTimeDataType, self).buildChildren(child_, node, nodeName_, True)


# end class BaseTimeDataType


class ArgumentBaseTimeDataType(NameDescriptionType):
    """Identical to BaseTimeDataType but supports argument instance
    references.Extend another absolute or relative time type."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, Encoding=None, ReferenceTime=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentBaseTimeDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                       name, extensiontype_, **kwargs_)
        self.baseType = _cast(None, baseType)
        self.baseType_nsprefix_ = None
        self.Encoding = Encoding
        self.Encoding_nsprefix_ = None
        self.ReferenceTime = ReferenceTime
        self.ReferenceTime_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentBaseTimeDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentBaseTimeDataType.subclass:
            return ArgumentBaseTimeDataType.subclass(*args_, **kwargs_)
        else:
            return ArgumentBaseTimeDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Encoding(self):
        return self.Encoding

    def set_Encoding(self, Encoding):
        self.Encoding = Encoding

    def get_ReferenceTime(self):
        return self.ReferenceTime

    def set_ReferenceTime(self, ReferenceTime):
        self.ReferenceTime = ReferenceTime

    def get_baseType(self):
        return self.baseType

    def set_baseType(self, baseType):
        self.baseType = baseType

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                self.Encoding is not None or
                self.ReferenceTime is not None or
                super(ArgumentBaseTimeDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentBaseTimeDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentBaseTimeDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentBaseTimeDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentBaseTimeDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentBaseTimeDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentBaseTimeDataType'):
        super(ArgumentBaseTimeDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                               name_='ArgumentBaseTimeDataType')
        if self.baseType is not None and 'baseType' not in already_processed:
            already_processed.add('baseType')
            outfile.write(' baseType=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.baseType), input_name='baseType')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentBaseTimeDataType',
                       fromsubclass_=False, pretty_print=True):
        super(ArgumentBaseTimeDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                             True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Encoding is not None:
            namespaceprefix_ = self.Encoding_nsprefix_ + ':' if (UseCapturedNS_ and self.Encoding_nsprefix_) else ''
            self.Encoding.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Encoding',
                                 pretty_print=pretty_print)
        if self.ReferenceTime is not None:
            namespaceprefix_ = self.ReferenceTime_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ReferenceTime_nsprefix_) else ''
            self.ReferenceTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReferenceTime',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('baseType', node)
        if value is not None and 'baseType' not in already_processed:
            already_processed.add('baseType')
            self.baseType = value
            self.validate_NameReferenceType(self.baseType)  # validate type NameReferenceType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ArgumentBaseTimeDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Encoding':
            obj_ = EncodingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Encoding = obj_
            obj_.original_tagname_ = 'Encoding'
        elif nodeName_ == 'ReferenceTime':
            obj_ = ReferenceTimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReferenceTime = obj_
            obj_.original_tagname_ = 'ReferenceTime'
        super(ArgumentBaseTimeDataType, self).buildChildren(child_, node, nodeName_, True)


# end class ArgumentBaseTimeDataType


class ArgumentBaseDataType(NameDescriptionType):
    """Identical to BaseDataType but supports argument instance references.Used
    to derive one Data Type from another - will inherit all the attributes
    from the baseType any of which may be redefined in this type
    definition."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentBaseDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                   extensiontype_, **kwargs_)
        self.baseType = _cast(None, baseType)
        self.baseType_nsprefix_ = None
        self.UnitSet = UnitSet
        self.UnitSet_nsprefix_ = None
        self.BinaryDataEncoding = BinaryDataEncoding
        self.BinaryDataEncoding_nsprefix_ = None
        self.FloatDataEncoding = FloatDataEncoding
        self.FloatDataEncoding_nsprefix_ = None
        self.IntegerDataEncoding = IntegerDataEncoding
        self.IntegerDataEncoding_nsprefix_ = None
        self.StringDataEncoding = StringDataEncoding
        self.StringDataEncoding_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentBaseDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentBaseDataType.subclass:
            return ArgumentBaseDataType.subclass(*args_, **kwargs_)
        else:
            return ArgumentBaseDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_UnitSet(self):
        return self.UnitSet

    def set_UnitSet(self, UnitSet):
        self.UnitSet = UnitSet

    def get_BinaryDataEncoding(self):
        return self.BinaryDataEncoding

    def set_BinaryDataEncoding(self, BinaryDataEncoding):
        self.BinaryDataEncoding = BinaryDataEncoding

    def get_FloatDataEncoding(self):
        return self.FloatDataEncoding

    def set_FloatDataEncoding(self, FloatDataEncoding):
        self.FloatDataEncoding = FloatDataEncoding

    def get_IntegerDataEncoding(self):
        return self.IntegerDataEncoding

    def set_IntegerDataEncoding(self, IntegerDataEncoding):
        self.IntegerDataEncoding = IntegerDataEncoding

    def get_StringDataEncoding(self):
        return self.StringDataEncoding

    def set_StringDataEncoding(self, StringDataEncoding):
        self.StringDataEncoding = StringDataEncoding

    def get_baseType(self):
        return self.baseType

    def set_baseType(self, baseType):
        self.baseType = baseType

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                self.UnitSet is not None or
                self.BinaryDataEncoding is not None or
                self.FloatDataEncoding is not None or
                self.IntegerDataEncoding is not None or
                self.StringDataEncoding is not None or
                super(ArgumentBaseDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentBaseDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentBaseDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentBaseDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentBaseDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentBaseDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArgumentBaseDataType'):
        super(ArgumentBaseDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='ArgumentBaseDataType')
        if self.baseType is not None and 'baseType' not in already_processed:
            already_processed.add('baseType')
            outfile.write(' baseType=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.baseType), input_name='baseType')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentBaseDataType',
                       fromsubclass_=False, pretty_print=True):
        super(ArgumentBaseDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UnitSet is not None:
            namespaceprefix_ = self.UnitSet_nsprefix_ + ':' if (UseCapturedNS_ and self.UnitSet_nsprefix_) else ''
            self.UnitSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UnitSet',
                                pretty_print=pretty_print)
        if self.BinaryDataEncoding is not None:
            namespaceprefix_ = self.BinaryDataEncoding_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BinaryDataEncoding_nsprefix_) else ''
            self.BinaryDataEncoding.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='BinaryDataEncoding', pretty_print=pretty_print)
        if self.FloatDataEncoding is not None:
            namespaceprefix_ = self.FloatDataEncoding_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.FloatDataEncoding_nsprefix_) else ''
            self.FloatDataEncoding.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FloatDataEncoding',
                                          pretty_print=pretty_print)
        if self.IntegerDataEncoding is not None:
            namespaceprefix_ = self.IntegerDataEncoding_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.IntegerDataEncoding_nsprefix_) else ''
            self.IntegerDataEncoding.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='IntegerDataEncoding', pretty_print=pretty_print)
        if self.StringDataEncoding is not None:
            namespaceprefix_ = self.StringDataEncoding_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.StringDataEncoding_nsprefix_) else ''
            self.StringDataEncoding.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='StringDataEncoding', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('baseType', node)
        if value is not None and 'baseType' not in already_processed:
            already_processed.add('baseType')
            self.baseType = value
            self.validate_NameReferenceType(self.baseType)  # validate type NameReferenceType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ArgumentBaseDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'UnitSet':
            obj_ = UnitSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UnitSet = obj_
            obj_.original_tagname_ = 'UnitSet'
        elif nodeName_ == 'BinaryDataEncoding':
            obj_ = ArgumentBinaryDataEncodingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BinaryDataEncoding = obj_
            obj_.original_tagname_ = 'BinaryDataEncoding'
        elif nodeName_ == 'FloatDataEncoding':
            obj_ = FloatDataEncodingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FloatDataEncoding = obj_
            obj_.original_tagname_ = 'FloatDataEncoding'
        elif nodeName_ == 'IntegerDataEncoding':
            obj_ = IntegerDataEncodingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IntegerDataEncoding = obj_
            obj_.original_tagname_ = 'IntegerDataEncoding'
        elif nodeName_ == 'StringDataEncoding':
            obj_ = ArgumentStringDataEncodingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StringDataEncoding = obj_
            obj_.original_tagname_ = 'StringDataEncoding'
        super(ArgumentBaseDataType, self).buildChildren(child_, node, nodeName_, True)


# end class ArgumentBaseDataType


class BaseDataType(NameDescriptionType):
    """An abstract schema type used by within the schema to derive the other
    simple/primitive engineering form data types: BooleanDataType,
    BinaryDataType, StringDataType, EnumeratedDataType, FloatDataType and
    IntegerDataType. The encoding elements are optional because they
    describe the raw wire encoded form of the data type. Encoding is only
    necessary when the type is telemetered in some form. Local variables
    and derived typically do not require encoding.Used to derive one Data
    Type from another - will inherit all the attributes from the baseType
    any of which may be redefined in this type definition."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BaseDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                           extensiontype_, **kwargs_)
        self.baseType = _cast(None, baseType)
        self.baseType_nsprefix_ = None
        self.UnitSet = UnitSet
        self.UnitSet_nsprefix_ = None
        self.BinaryDataEncoding = BinaryDataEncoding
        self.BinaryDataEncoding_nsprefix_ = None
        self.FloatDataEncoding = FloatDataEncoding
        self.FloatDataEncoding_nsprefix_ = None
        self.IntegerDataEncoding = IntegerDataEncoding
        self.IntegerDataEncoding_nsprefix_ = None
        self.StringDataEncoding = StringDataEncoding
        self.StringDataEncoding_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseDataType.subclass:
            return BaseDataType.subclass(*args_, **kwargs_)
        else:
            return BaseDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_UnitSet(self):
        return self.UnitSet

    def set_UnitSet(self, UnitSet):
        self.UnitSet = UnitSet

    def get_BinaryDataEncoding(self):
        return self.BinaryDataEncoding

    def set_BinaryDataEncoding(self, BinaryDataEncoding):
        self.BinaryDataEncoding = BinaryDataEncoding

    def get_FloatDataEncoding(self):
        return self.FloatDataEncoding

    def set_FloatDataEncoding(self, FloatDataEncoding):
        self.FloatDataEncoding = FloatDataEncoding

    def get_IntegerDataEncoding(self) -> 'IntegerDataEncodingType':
        return self.IntegerDataEncoding

    def set_IntegerDataEncoding(self, IntegerDataEncoding):
        self.IntegerDataEncoding = IntegerDataEncoding

    def get_StringDataEncoding(self):
        return self.StringDataEncoding

    def set_StringDataEncoding(self, StringDataEncoding):
        self.StringDataEncoding = StringDataEncoding

    def get_baseType(self):
        return self.baseType

    def set_baseType(self, baseType):
        self.baseType = baseType

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                self.UnitSet is not None or
                self.BinaryDataEncoding is not None or
                self.FloatDataEncoding is not None or
                self.IntegerDataEncoding is not None or
                self.StringDataEncoding is not None or
                super(BaseDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BaseDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseDataType'):
        super(BaseDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                   name_='BaseDataType')
        if self.baseType is not None and 'baseType' not in already_processed:
            already_processed.add('baseType')
            outfile.write(' baseType=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.baseType), input_name='baseType')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseDataType',
                       fromsubclass_=False, pretty_print=True):
        super(BaseDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                 pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UnitSet is not None:
            namespaceprefix_ = self.UnitSet_nsprefix_ + ':' if (UseCapturedNS_ and self.UnitSet_nsprefix_) else ''
            self.UnitSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UnitSet',
                                pretty_print=pretty_print)
        if self.BinaryDataEncoding is not None:
            namespaceprefix_ = self.BinaryDataEncoding_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BinaryDataEncoding_nsprefix_) else ''
            self.BinaryDataEncoding.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='BinaryDataEncoding', pretty_print=pretty_print)
        if self.FloatDataEncoding is not None:
            namespaceprefix_ = self.FloatDataEncoding_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.FloatDataEncoding_nsprefix_) else ''
            self.FloatDataEncoding.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FloatDataEncoding',
                                          pretty_print=pretty_print)
        if self.IntegerDataEncoding is not None:
            namespaceprefix_ = self.IntegerDataEncoding_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.IntegerDataEncoding_nsprefix_) else ''
            self.IntegerDataEncoding.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='IntegerDataEncoding', pretty_print=pretty_print)
        if self.StringDataEncoding is not None:
            namespaceprefix_ = self.StringDataEncoding_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.StringDataEncoding_nsprefix_) else ''
            self.StringDataEncoding.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='StringDataEncoding', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('baseType', node)
        if value is not None and 'baseType' not in already_processed:
            already_processed.add('baseType')
            self.baseType = value
            self.validate_NameReferenceType(self.baseType)  # validate type NameReferenceType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'UnitSet':
            obj_ = UnitSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UnitSet = obj_
            obj_.original_tagname_ = 'UnitSet'
        elif nodeName_ == 'BinaryDataEncoding':
            obj_ = BinaryDataEncodingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BinaryDataEncoding = obj_
            obj_.original_tagname_ = 'BinaryDataEncoding'
        elif nodeName_ == 'FloatDataEncoding':
            obj_ = FloatDataEncodingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FloatDataEncoding = obj_
            obj_.original_tagname_ = 'FloatDataEncoding'
        elif nodeName_ == 'IntegerDataEncoding':
            obj_ = IntegerDataEncodingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IntegerDataEncoding = obj_
            obj_.original_tagname_ = 'IntegerDataEncoding'
        elif nodeName_ == 'StringDataEncoding':
            obj_ = StringDataEncodingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StringDataEncoding = obj_
            obj_.original_tagname_ = 'StringDataEncoding'
        super(BaseDataType, self).buildChildren(child_, node, nodeName_, True)


# end class BaseDataType


class ArrayDataTypeType(NameDescriptionType):
    """A base schema type for describing an array data type. The number of and
    size of each dimension is defined in its two child types. See
    NameReferenceType, ArrayArgumentType and ArrayParameterType.Reference
    to the data type that represents the type of the elements for this
    array."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 arrayTypeRef=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArrayDataTypeType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                extensiontype_, **kwargs_)
        self.arrayTypeRef = _cast(None, arrayTypeRef)
        self.arrayTypeRef_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArrayDataTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArrayDataTypeType.subclass:
            return ArrayDataTypeType.subclass(*args_, **kwargs_)
        else:
            return ArrayDataTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_arrayTypeRef(self):
        return self.arrayTypeRef

    def set_arrayTypeRef(self, arrayTypeRef):
        self.arrayTypeRef = arrayTypeRef

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                super(ArrayDataTypeType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArrayDataTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArrayDataTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArrayDataTypeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArrayDataTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArrayDataTypeType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArrayDataTypeType'):
        super(ArrayDataTypeType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                        name_='ArrayDataTypeType')
        if self.arrayTypeRef is not None and 'arrayTypeRef' not in already_processed:
            already_processed.add('arrayTypeRef')
            outfile.write(' arrayTypeRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.arrayTypeRef), input_name='arrayTypeRef')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArrayDataTypeType',
                       fromsubclass_=False, pretty_print=True):
        super(ArrayDataTypeType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('arrayTypeRef', node)
        if value is not None and 'arrayTypeRef' not in already_processed:
            already_processed.add('arrayTypeRef')
            self.arrayTypeRef = value
            self.validate_NameReferenceType(self.arrayTypeRef)  # validate type NameReferenceType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ArrayDataTypeType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ArrayDataTypeType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ArrayDataTypeType


class AggregateDataType(NameDescriptionType):
    """A base schema type for describing a complex data type analogous to a
    C-struct. Each field of the data type is called a Member. Each Member
    is part of the MemberList which forms the list of items to be placed
    under this data type’s name. The MemberList defines a data block and
    block’s size is defined by the DataEncodings of each Member’s type
    reference. The data members are ordered and contiguous in the
    MemberList element (packed). Each member may be addressed by the dot
    syntax similar to C such as P.voltage if P is the referring parameter
    and voltage is of a member of P’s aggregate type. See MemberType,
    MemberListType, DataEncodingType, NameReferenceType,
    AggregateParameterType and AggregateArgumentType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 MemberList=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AggregateDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                extensiontype_, **kwargs_)
        self.MemberList = MemberList
        self.MemberList_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AggregateDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AggregateDataType.subclass:
            return AggregateDataType.subclass(*args_, **kwargs_)
        else:
            return AggregateDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MemberList(self) -> 'MemberListType':
        return self.MemberList

    def set_MemberList(self, MemberList):
        self.MemberList = MemberList

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.MemberList is not None or
                super(AggregateDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AggregateDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AggregateDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AggregateDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregateDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AggregateDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AggregateDataType'):
        super(AggregateDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                        name_='AggregateDataType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AggregateDataType',
                       fromsubclass_=False, pretty_print=True):
        super(AggregateDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                      pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MemberList is not None:
            namespaceprefix_ = self.MemberList_nsprefix_ + ':' if (UseCapturedNS_ and self.MemberList_nsprefix_) else ''
            self.MemberList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MemberList',
                                   pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AggregateDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MemberList':
            obj_ = MemberListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MemberList = obj_
            obj_.original_tagname_ = 'MemberList'
        super(AggregateDataType, self).buildChildren(child_, node, nodeName_, True)


# end class AggregateDataType


class AbsoluteTimeDataType(BaseTimeDataType):
    """A base schema type for describing an absolute time data type. Contains
    an absolute (to a known epoch) time. Use the [ISO 8601] extended format
    CCYY-MM-DDThh:mm:ss where "CC" represents the century, "YY" the year,
    "MM" the month and "DD" the day, preceded by an optional leading "-"
    sign to indicate a negative number. If the sign is omitted, "+" is
    assumed. The letter "T" is the date/time separator and "hh", "mm", "ss"
    represent hour, minute and second respectively. Additional digits can
    be used to increase the precision of fractional seconds if desired i.e.
    the format ss.ss... with any number of digits after the decimal point
    is supported. See AbsoluteTimeParameterType and
    AbsoluteTimeArgumentType. See AbsouteTimeParameterType,
    AbsoluteTimeArgumentType and BaseTimeDataType.Default/Initial value is
    always given in calibrated form."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseTimeDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, Encoding=None, ReferenceTime=None, initialValue=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AbsoluteTimeDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                   baseType, Encoding, ReferenceTime, extensiontype_, **kwargs_)
        if isinstance(initialValue, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(initialValue, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = initialValue
        self.initialValue = initvalue_
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbsoluteTimeDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbsoluteTimeDataType.subclass:
            return AbsoluteTimeDataType.subclass(*args_, **kwargs_)
        else:
            return AbsoluteTimeDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                super(AbsoluteTimeDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AbsoluteTimeDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbsoluteTimeDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AbsoluteTimeDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbsoluteTimeDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AbsoluteTimeDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AbsoluteTimeDataType'):
        super(AbsoluteTimeDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='AbsoluteTimeDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue="%s"' % self.gds_format_datetime(self.initialValue, input_name='initialValue'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AbsoluteTimeDataType',
                       fromsubclass_=False, pretty_print=True):
        super(AbsoluteTimeDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            try:
                self.initialValue = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (initialValue): %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbsoluteTimeDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(AbsoluteTimeDataType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class AbsoluteTimeDataType


class ArgumentAbsoluteTimeDataType(ArgumentBaseTimeDataType):
    """A base schema type for describing an absolute time data type. Contains
    an absolute (to a known epoch) time. Use the [ISO 8601] extended format
    CCYY-MM-DDThh:mm:ss where "CC" represents the century, "YY" the year,
    "MM" the month and "DD" the day, preceded by an optional leading "-"
    sign to indicate a negative number. If the sign is omitted, "+" is
    assumed. The letter "T" is the date/time separator and "hh", "mm", "ss"
    represent hour, minute and second respectively. Additional digits can
    be used to increase the precision of fractional seconds if desired i.e.
    the format ss.ss... with any number of digits after the decimal point
    is supported. See AbsoluteTimeParameterType and
    AbsoluteTimeArgumentType. See AbsouteTimeParameterType,
    AbsoluteTimeArgumentType and BaseTimeDataType.Default/Initial value is
    always given in calibrated form."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentBaseTimeDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, Encoding=None, ReferenceTime=None, initialValue=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentAbsoluteTimeDataType, self).__init__(shortDescription, LongDescription, AliasSet,
                                                           AncillaryDataSet, name, baseType, Encoding, ReferenceTime,
                                                           extensiontype_, **kwargs_)
        if isinstance(initialValue, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(initialValue, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = initialValue
        self.initialValue = initvalue_
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentAbsoluteTimeDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentAbsoluteTimeDataType.subclass:
            return ArgumentAbsoluteTimeDataType.subclass(*args_, **kwargs_)
        else:
            return ArgumentAbsoluteTimeDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                super(ArgumentAbsoluteTimeDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentAbsoluteTimeDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentAbsoluteTimeDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentAbsoluteTimeDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentAbsoluteTimeDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentAbsoluteTimeDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentAbsoluteTimeDataType'):
        super(ArgumentAbsoluteTimeDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                   name_='ArgumentAbsoluteTimeDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue="%s"' % self.gds_format_datetime(self.initialValue, input_name='initialValue'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ArgumentAbsoluteTimeDataType', fromsubclass_=False, pretty_print=True):
        super(ArgumentAbsoluteTimeDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                                 True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            try:
                self.initialValue = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (initialValue): %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ArgumentAbsoluteTimeDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ArgumentAbsoluteTimeDataType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ArgumentAbsoluteTimeDataType


class PCMStreamType(NameDescriptionType):
    """A PCM Stream Type is the high level definition for all Pulse Code
    Modulated (PCM) (i.e., binary) streams."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 bitRateInBPS=None, pcmType='NRZL', inverted=False, extensiontype_=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PCMStreamType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                            extensiontype_, **kwargs_)
        self.bitRateInBPS = _cast(float, bitRateInBPS)
        self.bitRateInBPS_nsprefix_ = None
        self.pcmType = _cast(None, pcmType)
        self.pcmType_nsprefix_ = None
        self.inverted = _cast(bool, inverted)
        self.inverted_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PCMStreamType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PCMStreamType.subclass:
            return PCMStreamType.subclass(*args_, **kwargs_)
        else:
            return PCMStreamType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_bitRateInBPS(self):
        return self.bitRateInBPS

    def set_bitRateInBPS(self, bitRateInBPS):
        self.bitRateInBPS = bitRateInBPS

    def get_pcmType(self):
        return self.pcmType

    def set_pcmType(self, pcmType):
        self.pcmType = pcmType

    def get_inverted(self):
        return self.inverted

    def set_inverted(self, inverted):
        self.inverted = inverted

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_PCMType(self, value):
        # Validate type xtce:PCMType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['NRZL', 'NRZM', 'NRZS', 'BiPhaseL', 'BiPhaseM', 'BiPhaseS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PCMType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(PCMStreamType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PCMStreamType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PCMStreamType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PCMStreamType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PCMStreamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PCMStreamType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PCMStreamType'):
        super(PCMStreamType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                    name_='PCMStreamType')
        if self.bitRateInBPS is not None and 'bitRateInBPS' not in already_processed:
            already_processed.add('bitRateInBPS')
            outfile.write(' bitRateInBPS="%s"' % self.gds_format_double(self.bitRateInBPS, input_name='bitRateInBPS'))
        if self.pcmType != "NRZL" and 'pcmType' not in already_processed:
            already_processed.add('pcmType')
            outfile.write(' pcmType=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.pcmType), input_name='pcmType')),))
        if self.inverted and 'inverted' not in already_processed:
            already_processed.add('inverted')
            outfile.write(' inverted="%s"' % self.gds_format_boolean(self.inverted, input_name='inverted'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PCMStreamType',
                       fromsubclass_=False, pretty_print=True):
        super(PCMStreamType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                  pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bitRateInBPS', node)
        if value is not None and 'bitRateInBPS' not in already_processed:
            already_processed.add('bitRateInBPS')
            value = self.gds_parse_double(value, node, 'bitRateInBPS')
            self.bitRateInBPS = value
        value = find_attr_value_('pcmType', node)
        if value is not None and 'pcmType' not in already_processed:
            already_processed.add('pcmType')
            self.pcmType = value
            self.validate_PCMType(self.pcmType)  # validate type PCMType
        value = find_attr_value_('inverted', node)
        if value is not None and 'inverted' not in already_processed:
            already_processed.add('inverted')
            if value in ('true', '1'):
                self.inverted = True
            elif value in ('false', '0'):
                self.inverted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(PCMStreamType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(PCMStreamType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class PCMStreamType


class FixedFrameSyncStrategyType(SyncStrategyType):
    """Describe a sync pattern and an optional reference to an algorithm used
    to invert the stream if the frame sync pattern is not found. See
    FixedFrameStreamType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SyncStrategyType

    def __init__(self, verifyToLockGoodFrames='4', checkToLockGoodFrames='1', maxBitErrorsInSyncPattern='0',
                 AutoInvert=None, SyncPattern=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FixedFrameSyncStrategyType, self).__init__(verifyToLockGoodFrames, checkToLockGoodFrames,
                                                         maxBitErrorsInSyncPattern, AutoInvert, **kwargs_)
        self.SyncPattern = SyncPattern
        self.SyncPattern_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FixedFrameSyncStrategyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FixedFrameSyncStrategyType.subclass:
            return FixedFrameSyncStrategyType.subclass(*args_, **kwargs_)
        else:
            return FixedFrameSyncStrategyType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SyncPattern(self):
        return self.SyncPattern

    def set_SyncPattern(self, SyncPattern):
        self.SyncPattern = SyncPattern

    def hasContent_(self):
        if (
                self.SyncPattern is not None or
                super(FixedFrameSyncStrategyType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FixedFrameSyncStrategyType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FixedFrameSyncStrategyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FixedFrameSyncStrategyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FixedFrameSyncStrategyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FixedFrameSyncStrategyType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='FixedFrameSyncStrategyType'):
        super(FixedFrameSyncStrategyType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                 name_='FixedFrameSyncStrategyType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FixedFrameSyncStrategyType',
                       fromsubclass_=False, pretty_print=True):
        super(FixedFrameSyncStrategyType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                               True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SyncPattern is not None:
            namespaceprefix_ = self.SyncPattern_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SyncPattern_nsprefix_) else ''
            self.SyncPattern.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SyncPattern',
                                    pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(FixedFrameSyncStrategyType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SyncPattern':
            obj_ = SyncPatternType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SyncPattern = obj_
            obj_.original_tagname_ = 'SyncPattern'
        super(FixedFrameSyncStrategyType, self).buildChildren(child_, node, nodeName_, True)


# end class FixedFrameSyncStrategyType


class FrameStreamType(PCMStreamType):
    """The top level type definition for all data streams that are frame
    based."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PCMStreamType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 bitRateInBPS=None, pcmType='NRZL', inverted=False, ContainerRef=None, ServiceRef=None, StreamRef=None,
                 extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FrameStreamType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                              bitRateInBPS, pcmType, inverted, extensiontype_, **kwargs_)
        self.ContainerRef = ContainerRef
        self.ContainerRef_nsprefix_ = None
        self.ServiceRef = ServiceRef
        self.ServiceRef_nsprefix_ = None
        self.StreamRef = StreamRef
        self.StreamRef_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FrameStreamType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FrameStreamType.subclass:
            return FrameStreamType.subclass(*args_, **kwargs_)
        else:
            return FrameStreamType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ContainerRef(self):
        return self.ContainerRef

    def set_ContainerRef(self, ContainerRef):
        self.ContainerRef = ContainerRef

    def get_ServiceRef(self):
        return self.ServiceRef

    def set_ServiceRef(self, ServiceRef):
        self.ServiceRef = ServiceRef

    def get_StreamRef(self):
        return self.StreamRef

    def set_StreamRef(self, StreamRef):
        self.StreamRef = StreamRef

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.ContainerRef is not None or
                self.ServiceRef is not None or
                self.StreamRef is not None or
                super(FrameStreamType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FrameStreamType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FrameStreamType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FrameStreamType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FrameStreamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FrameStreamType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FrameStreamType'):
        super(FrameStreamType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                      name_='FrameStreamType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FrameStreamType',
                       fromsubclass_=False, pretty_print=True):
        super(FrameStreamType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                    pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContainerRef is not None:
            namespaceprefix_ = self.ContainerRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContainerRef_nsprefix_) else ''
            self.ContainerRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContainerRef',
                                     pretty_print=pretty_print)
        if self.ServiceRef is not None:
            namespaceprefix_ = self.ServiceRef_nsprefix_ + ':' if (UseCapturedNS_ and self.ServiceRef_nsprefix_) else ''
            self.ServiceRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ServiceRef',
                                   pretty_print=pretty_print)
        if self.StreamRef is not None:
            namespaceprefix_ = self.StreamRef_nsprefix_ + ':' if (UseCapturedNS_ and self.StreamRef_nsprefix_) else ''
            self.StreamRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StreamRef',
                                  pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(FrameStreamType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContainerRef':
            obj_ = ContainerRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContainerRef = obj_
            obj_.original_tagname_ = 'ContainerRef'
        elif nodeName_ == 'ServiceRef':
            obj_ = ServiceRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ServiceRef = obj_
            obj_.original_tagname_ = 'ServiceRef'
        elif nodeName_ == 'StreamRef':
            obj_ = StreamRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StreamRef = obj_
            obj_.original_tagname_ = 'StreamRef'
        super(FrameStreamType, self).buildChildren(child_, node, nodeName_, True)


# end class FrameStreamType


class CustomStreamType(PCMStreamType):
    """A stream type where some level of custom processing (e.g. convolutional,
    encryption, compression) is performed. Has a reference to external
    algorithms for encoding and decoding algorithms."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = PCMStreamType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 bitRateInBPS=None, pcmType='NRZL', inverted=False, encodedStreamRef=None, decodedStreamRef=None,
                 EncodingAlgorithm=None, DecodingAlgorithm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CustomStreamType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                               bitRateInBPS, pcmType, inverted, **kwargs_)
        self.encodedStreamRef = _cast(None, encodedStreamRef)
        self.encodedStreamRef_nsprefix_ = None
        self.decodedStreamRef = _cast(None, decodedStreamRef)
        self.decodedStreamRef_nsprefix_ = None
        self.EncodingAlgorithm = EncodingAlgorithm
        self.EncodingAlgorithm_nsprefix_ = None
        self.DecodingAlgorithm = DecodingAlgorithm
        self.DecodingAlgorithm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomStreamType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomStreamType.subclass:
            return CustomStreamType.subclass(*args_, **kwargs_)
        else:
            return CustomStreamType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_EncodingAlgorithm(self):
        return self.EncodingAlgorithm

    def set_EncodingAlgorithm(self, EncodingAlgorithm):
        self.EncodingAlgorithm = EncodingAlgorithm

    def get_DecodingAlgorithm(self):
        return self.DecodingAlgorithm

    def set_DecodingAlgorithm(self, DecodingAlgorithm):
        self.DecodingAlgorithm = DecodingAlgorithm

    def get_encodedStreamRef(self):
        return self.encodedStreamRef

    def set_encodedStreamRef(self, encodedStreamRef):
        self.encodedStreamRef = encodedStreamRef

    def get_decodedStreamRef(self):
        return self.decodedStreamRef

    def set_decodedStreamRef(self, decodedStreamRef):
        self.decodedStreamRef = decodedStreamRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                self.EncodingAlgorithm is not None or
                self.DecodingAlgorithm is not None or
                super(CustomStreamType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CustomStreamType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomStreamType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomStreamType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomStreamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomStreamType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CustomStreamType'):
        super(CustomStreamType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                       name_='CustomStreamType')
        if self.encodedStreamRef is not None and 'encodedStreamRef' not in already_processed:
            already_processed.add('encodedStreamRef')
            outfile.write(' encodedStreamRef=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.encodedStreamRef), input_name='encodedStreamRef')),))
        if self.decodedStreamRef is not None and 'decodedStreamRef' not in already_processed:
            already_processed.add('decodedStreamRef')
            outfile.write(' decodedStreamRef=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.decodedStreamRef), input_name='decodedStreamRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CustomStreamType',
                       fromsubclass_=False, pretty_print=True):
        super(CustomStreamType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                     pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EncodingAlgorithm is not None:
            namespaceprefix_ = self.EncodingAlgorithm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.EncodingAlgorithm_nsprefix_) else ''
            self.EncodingAlgorithm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EncodingAlgorithm',
                                          pretty_print=pretty_print)
        if self.DecodingAlgorithm is not None:
            namespaceprefix_ = self.DecodingAlgorithm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DecodingAlgorithm_nsprefix_) else ''
            self.DecodingAlgorithm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DecodingAlgorithm',
                                          pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('encodedStreamRef', node)
        if value is not None and 'encodedStreamRef' not in already_processed:
            already_processed.add('encodedStreamRef')
            self.encodedStreamRef = value
            self.validate_NameReferenceType(self.encodedStreamRef)  # validate type NameReferenceType
        value = find_attr_value_('decodedStreamRef', node)
        if value is not None and 'decodedStreamRef' not in already_processed:
            already_processed.add('decodedStreamRef')
            self.decodedStreamRef = value
            self.validate_NameReferenceType(self.decodedStreamRef)  # validate type NameReferenceType
        super(CustomStreamType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EncodingAlgorithm':
            class_obj_ = self.get_class_obj_(child_, InputAlgorithmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EncodingAlgorithm = obj_
            obj_.original_tagname_ = 'EncodingAlgorithm'
        elif nodeName_ == 'DecodingAlgorithm':
            class_obj_ = self.get_class_obj_(child_, InputOutputAlgorithmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DecodingAlgorithm = obj_
            obj_.original_tagname_ = 'DecodingAlgorithm'
        super(CustomStreamType, self).buildChildren(child_, node, nodeName_, True)


# end class CustomStreamType


class TriggeredMathOperationType(MathOperationType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MathOperationType

    def __init__(self, name=None, shortDescription=None, AncillaryDataSet=None, ValueOperand=None,
                 ThisParameterOperand=None, Operator=None, ParameterInstanceRefOperand=None, outputParameterRef=None,
                 TriggerSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TriggeredMathOperationType, self).__init__(name, shortDescription, AncillaryDataSet, ValueOperand,
                                                         ThisParameterOperand, Operator, ParameterInstanceRefOperand,
                                                         **kwargs_)
        self.outputParameterRef = _cast(None, outputParameterRef)
        self.outputParameterRef_nsprefix_ = None
        self.TriggerSet = TriggerSet
        self.TriggerSet_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TriggeredMathOperationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TriggeredMathOperationType.subclass:
            return TriggeredMathOperationType.subclass(*args_, **kwargs_)
        else:
            return TriggeredMathOperationType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_TriggerSet(self):
        return self.TriggerSet

    def set_TriggerSet(self, TriggerSet):
        self.TriggerSet = TriggerSet

    def get_outputParameterRef(self):
        return self.outputParameterRef

    def set_outputParameterRef(self, outputParameterRef):
        self.outputParameterRef = outputParameterRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                self.TriggerSet is not None or
                super(TriggeredMathOperationType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TriggeredMathOperationType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TriggeredMathOperationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TriggeredMathOperationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TriggeredMathOperationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TriggeredMathOperationType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='TriggeredMathOperationType'):
        super(TriggeredMathOperationType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                 name_='TriggeredMathOperationType')
        if self.outputParameterRef is not None and 'outputParameterRef' not in already_processed:
            already_processed.add('outputParameterRef')
            outfile.write(' outputParameterRef=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.outputParameterRef), input_name='outputParameterRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TriggeredMathOperationType',
                       fromsubclass_=False, pretty_print=True):
        super(TriggeredMathOperationType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                               True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TriggerSet is not None:
            namespaceprefix_ = self.TriggerSet_nsprefix_ + ':' if (UseCapturedNS_ and self.TriggerSet_nsprefix_) else ''
            self.TriggerSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TriggerSet',
                                   pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('outputParameterRef', node)
        if value is not None and 'outputParameterRef' not in already_processed:
            already_processed.add('outputParameterRef')
            self.outputParameterRef = value
            self.validate_NameReferenceType(self.outputParameterRef)  # validate type NameReferenceType
        super(TriggeredMathOperationType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TriggerSet':
            obj_ = TriggerSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TriggerSet = obj_
            obj_.original_tagname_ = 'TriggerSet'
        super(TriggeredMathOperationType, self).buildChildren(child_, node, nodeName_, True)


# end class TriggeredMathOperationType


class SimpleAlgorithmType(NameDescriptionType):
    """The simplest form of algorithm, a SimpleAlgorithmType contains an area
    for a free-form pseudo code description of the algorithm plus a Set of
    references to external algorithms. External algorithms are usually
    unique to a ground system type. Multiple external algorithms are
    possible because XTCE documents may be used across multiple ground
    systems."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 AlgorithmText=None, ExternalAlgorithmSet=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SimpleAlgorithmType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                  extensiontype_, **kwargs_)
        self.AlgorithmText = AlgorithmText
        self.AlgorithmText_nsprefix_ = None
        self.ExternalAlgorithmSet = ExternalAlgorithmSet
        self.ExternalAlgorithmSet_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleAlgorithmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleAlgorithmType.subclass:
            return SimpleAlgorithmType.subclass(*args_, **kwargs_)
        else:
            return SimpleAlgorithmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AlgorithmText(self):
        return self.AlgorithmText

    def set_AlgorithmText(self, AlgorithmText):
        self.AlgorithmText = AlgorithmText

    def get_ExternalAlgorithmSet(self):
        return self.ExternalAlgorithmSet

    def set_ExternalAlgorithmSet(self, ExternalAlgorithmSet):
        self.ExternalAlgorithmSet = ExternalAlgorithmSet

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.AlgorithmText is not None or
                self.ExternalAlgorithmSet is not None or
                super(SimpleAlgorithmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SimpleAlgorithmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SimpleAlgorithmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SimpleAlgorithmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SimpleAlgorithmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SimpleAlgorithmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SimpleAlgorithmType'):
        super(SimpleAlgorithmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                          name_='SimpleAlgorithmType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SimpleAlgorithmType',
                       fromsubclass_=False, pretty_print=True):
        super(SimpleAlgorithmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                        pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AlgorithmText is not None:
            namespaceprefix_ = self.AlgorithmText_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AlgorithmText_nsprefix_) else ''
            self.AlgorithmText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AlgorithmText',
                                      pretty_print=pretty_print)
        if self.ExternalAlgorithmSet is not None:
            namespaceprefix_ = self.ExternalAlgorithmSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ExternalAlgorithmSet_nsprefix_) else ''
            self.ExternalAlgorithmSet.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='ExternalAlgorithmSet', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SimpleAlgorithmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AlgorithmText':
            obj_ = AlgorithmTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AlgorithmText = obj_
            obj_.original_tagname_ = 'AlgorithmText'
        elif nodeName_ == 'ExternalAlgorithmSet':
            obj_ = ExternalAlgorithmSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ExternalAlgorithmSet = obj_
            obj_.original_tagname_ = 'ExternalAlgorithmSet'
        super(SimpleAlgorithmType, self).buildChildren(child_, node, nodeName_, True)


# end class SimpleAlgorithmType


class MathAlgorithmType(NameDescriptionType):
    """Describe a postfix (Reverse Polish Notation (RPN)) notation based
    mathmatical equations. See MathOperationType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 MathOperation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MathAlgorithmType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                **kwargs_)
        self.MathOperation = MathOperation
        self.MathOperation_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MathAlgorithmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MathAlgorithmType.subclass:
            return MathAlgorithmType.subclass(*args_, **kwargs_)
        else:
            return MathAlgorithmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MathOperation(self):
        return self.MathOperation

    def set_MathOperation(self, MathOperation):
        self.MathOperation = MathOperation

    def hasContent_(self):
        if (
                self.MathOperation is not None or
                super(MathAlgorithmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MathAlgorithmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MathAlgorithmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MathAlgorithmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MathAlgorithmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MathAlgorithmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MathAlgorithmType'):
        super(MathAlgorithmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                        name_='MathAlgorithmType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MathAlgorithmType',
                       fromsubclass_=False, pretty_print=True):
        super(MathAlgorithmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                      pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MathOperation is not None:
            namespaceprefix_ = self.MathOperation_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MathOperation_nsprefix_) else ''
            self.MathOperation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MathOperation',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(MathAlgorithmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MathOperation':
            obj_ = TriggeredMathOperationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MathOperation = obj_
            obj_.original_tagname_ = 'MathOperation'
        super(MathAlgorithmType, self).buildChildren(child_, node, nodeName_, True)


# end class MathAlgorithmType


class InputAlgorithmType(SimpleAlgorithmType):
    """A set of labeled inputs is added to the SimpleAlgorithmType"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SimpleAlgorithmType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 AlgorithmText=None, ExternalAlgorithmSet=None, InputSet=None, extensiontype_=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(InputAlgorithmType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                 AlgorithmText, ExternalAlgorithmSet, extensiontype_, **kwargs_)
        self.InputSet = InputSet
        self.InputSet_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InputAlgorithmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InputAlgorithmType.subclass:
            return InputAlgorithmType.subclass(*args_, **kwargs_)
        else:
            return InputAlgorithmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_InputSet(self):
        return self.InputSet

    def set_InputSet(self, InputSet):
        self.InputSet = InputSet

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.InputSet is not None or
                super(InputAlgorithmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InputAlgorithmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InputAlgorithmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InputAlgorithmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InputAlgorithmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InputAlgorithmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InputAlgorithmType'):
        super(InputAlgorithmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                         name_='InputAlgorithmType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InputAlgorithmType',
                       fromsubclass_=False, pretty_print=True):
        super(InputAlgorithmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                       pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InputSet is not None:
            namespaceprefix_ = self.InputSet_nsprefix_ + ':' if (UseCapturedNS_ and self.InputSet_nsprefix_) else ''
            self.InputSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InputSet',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(InputAlgorithmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'InputSet':
            obj_ = InputSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InputSet = obj_
            obj_.original_tagname_ = 'InputSet'
        super(InputAlgorithmType, self).buildChildren(child_, node, nodeName_, True)


# end class InputAlgorithmType


class TransmissionConstraintType(MatchCriteriaType):
    """A CommandTransmission constraint is used to check that the command can
    be run in the current operating mode and may block the transmission of
    the command if the constraint condition is true.Pause during timeOut,
    fail when the timeout passesIndicates whether the constraints for a
    Command may be suspended."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MatchCriteriaType

    def __init__(self, Comparison=None, ComparisonList=None, BooleanExpression=None, CustomAlgorithm=None, timeOut=None,
                 suspendable=False, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TransmissionConstraintType, self).__init__(Comparison, ComparisonList, BooleanExpression, CustomAlgorithm,
                                                         **kwargs_)
        self.timeOut = _cast(None, timeOut)
        self.timeOut_nsprefix_ = None
        self.suspendable = _cast(bool, suspendable)
        self.suspendable_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransmissionConstraintType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransmissionConstraintType.subclass:
            return TransmissionConstraintType.subclass(*args_, **kwargs_)
        else:
            return TransmissionConstraintType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_timeOut(self):
        return self.timeOut

    def set_timeOut(self, timeOut):
        self.timeOut = timeOut

    def get_suspendable(self):
        return self.suspendable

    def set_suspendable(self, suspendable):
        self.suspendable = suspendable

    def validate_RelativeTimeType(self, value):
        # Validate type xtce:RelativeTimeType, a restriction on duration.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            pass

    def hasContent_(self):
        if (
                super(TransmissionConstraintType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TransmissionConstraintType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransmissionConstraintType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransmissionConstraintType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransmissionConstraintType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransmissionConstraintType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='TransmissionConstraintType'):
        super(TransmissionConstraintType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                 name_='TransmissionConstraintType')
        if self.timeOut is not None and 'timeOut' not in already_processed:
            already_processed.add('timeOut')
            outfile.write(' timeOut=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.timeOut), input_name='timeOut')),))
        if self.suspendable and 'suspendable' not in already_processed:
            already_processed.add('suspendable')
            outfile.write(' suspendable="%s"' % self.gds_format_boolean(self.suspendable, input_name='suspendable'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TransmissionConstraintType',
                       fromsubclass_=False, pretty_print=True):
        super(TransmissionConstraintType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                               True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timeOut', node)
        if value is not None and 'timeOut' not in already_processed:
            already_processed.add('timeOut')
            self.timeOut = value
            self.validate_RelativeTimeType(self.timeOut)  # validate type RelativeTimeType
        value = find_attr_value_('suspendable', node)
        if value is not None and 'suspendable' not in already_processed:
            already_processed.add('suspendable')
            if value in ('true', '1'):
                self.suspendable = True
            elif value in ('false', '0'):
                self.suspendable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(TransmissionConstraintType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TransmissionConstraintType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class TransmissionConstraintType


class MetaCommandType(NameDescriptionType):
    """Describe a command which consists of an abstract portion (MetaCommand)
    and an optional packaging portion (MetaCommand CommandContainer). An
    argument list is provided. MetaCommand may extend other MetaCommands
    and their CommandContainer may extend other CommandContainer or
    SequenceContainers. A MetaCommand’s CommandContainer is private except
    as referred to in BaseMetaCommand (they are not visible to other
    containers and cannot be used in an entry list). MetaCommands may also
    define various other behavioral aspects of a command such as command
    verifiers. See CommandContainerType, ArgumentListType,
    BaseMetaCommandType and BaseContainerType.Abstract MetaCommand
    definitions that are not instantiated, rather only used as bases to
    inherit from to create specialized command definitions."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 abstract=False, BaseMetaCommand=None, SystemName=None, ArgumentList=None, CommandContainer=None,
                 TransmissionConstraintList=None, DefaultSignificance=None, ContextSignificanceList=None,
                 Interlock=None, VerifierSet=None, ParameterToSetList=None, ParametersToSuspendAlarmsOnSet=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MetaCommandType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                              **kwargs_)
        self.abstract = _cast(bool, abstract)
        self.abstract_nsprefix_ = None
        self.BaseMetaCommand = BaseMetaCommand
        self.BaseMetaCommand_nsprefix_ = None
        self.SystemName = SystemName
        self.SystemName_nsprefix_ = None
        self.ArgumentList = ArgumentList
        self.ArgumentList_nsprefix_ = None
        self.CommandContainer = CommandContainer
        self.CommandContainer_nsprefix_ = None
        self.TransmissionConstraintList = TransmissionConstraintList
        self.TransmissionConstraintList_nsprefix_ = None
        self.DefaultSignificance = DefaultSignificance
        self.DefaultSignificance_nsprefix_ = None
        self.ContextSignificanceList = ContextSignificanceList
        self.ContextSignificanceList_nsprefix_ = None
        self.Interlock = Interlock
        self.Interlock_nsprefix_ = None
        self.VerifierSet = VerifierSet
        self.VerifierSet_nsprefix_ = None
        self.ParameterToSetList = ParameterToSetList
        self.ParameterToSetList_nsprefix_ = None
        self.ParametersToSuspendAlarmsOnSet = ParametersToSuspendAlarmsOnSet
        self.ParametersToSuspendAlarmsOnSet_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MetaCommandType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MetaCommandType.subclass:
            return MetaCommandType.subclass(*args_, **kwargs_)
        else:
            return MetaCommandType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_BaseMetaCommand(self) -> 'BaseMetaCommandType':
        return self.BaseMetaCommand

    def set_BaseMetaCommand(self, BaseMetaCommand):
        self.BaseMetaCommand = BaseMetaCommand

    def get_SystemName(self):
        return self.SystemName

    def set_SystemName(self, SystemName):
        self.SystemName = SystemName

    def get_ArgumentList(self):
        return self.ArgumentList

    def set_ArgumentList(self, ArgumentList):
        self.ArgumentList = ArgumentList

    def get_CommandContainer(self):
        return self.CommandContainer

    def set_CommandContainer(self, CommandContainer):
        self.CommandContainer = CommandContainer

    def get_TransmissionConstraintList(self):
        return self.TransmissionConstraintList

    def set_TransmissionConstraintList(self, TransmissionConstraintList):
        self.TransmissionConstraintList = TransmissionConstraintList

    def get_DefaultSignificance(self):
        return self.DefaultSignificance

    def set_DefaultSignificance(self, DefaultSignificance):
        self.DefaultSignificance = DefaultSignificance

    def get_ContextSignificanceList(self):
        return self.ContextSignificanceList

    def set_ContextSignificanceList(self, ContextSignificanceList):
        self.ContextSignificanceList = ContextSignificanceList

    def get_Interlock(self):
        return self.Interlock

    def set_Interlock(self, Interlock):
        self.Interlock = Interlock

    def get_VerifierSet(self):
        return self.VerifierSet

    def set_VerifierSet(self, VerifierSet):
        self.VerifierSet = VerifierSet

    def get_ParameterToSetList(self):
        return self.ParameterToSetList

    def set_ParameterToSetList(self, ParameterToSetList):
        self.ParameterToSetList = ParameterToSetList

    def get_ParametersToSuspendAlarmsOnSet(self):
        return self.ParametersToSuspendAlarmsOnSet

    def set_ParametersToSuspendAlarmsOnSet(self, ParametersToSuspendAlarmsOnSet):
        self.ParametersToSuspendAlarmsOnSet = ParametersToSuspendAlarmsOnSet

    def get_abstract(self):
        return self.abstract

    def set_abstract(self, abstract):
        self.abstract = abstract

    def hasContent_(self):
        if (
                self.BaseMetaCommand is not None or
                self.SystemName is not None or
                self.ArgumentList is not None or
                self.CommandContainer is not None or
                self.TransmissionConstraintList is not None or
                self.DefaultSignificance is not None or
                self.ContextSignificanceList is not None or
                self.Interlock is not None or
                self.VerifierSet is not None or
                self.ParameterToSetList is not None or
                self.ParametersToSuspendAlarmsOnSet is not None or
                super(MetaCommandType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MetaCommandType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MetaCommandType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MetaCommandType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MetaCommandType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MetaCommandType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MetaCommandType'):
        super(MetaCommandType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                      name_='MetaCommandType')
        if self.abstract and 'abstract' not in already_processed:
            already_processed.add('abstract')
            outfile.write(' abstract="%s"' % self.gds_format_boolean(self.abstract, input_name='abstract'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MetaCommandType',
                       fromsubclass_=False, pretty_print=True):
        super(MetaCommandType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                    pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BaseMetaCommand is not None:
            namespaceprefix_ = self.BaseMetaCommand_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BaseMetaCommand_nsprefix_) else ''
            self.BaseMetaCommand.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BaseMetaCommand',
                                        pretty_print=pretty_print)
        if self.SystemName is not None:
            namespaceprefix_ = self.SystemName_nsprefix_ + ':' if (UseCapturedNS_ and self.SystemName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSystemName>%s</%sSystemName>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.SystemName), input_name='SystemName')), namespaceprefix_, eol_))
        if self.ArgumentList is not None:
            namespaceprefix_ = self.ArgumentList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ArgumentList_nsprefix_) else ''
            self.ArgumentList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ArgumentList',
                                     pretty_print=pretty_print)
        if self.CommandContainer is not None:
            namespaceprefix_ = self.CommandContainer_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CommandContainer_nsprefix_) else ''
            self.CommandContainer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CommandContainer',
                                         pretty_print=pretty_print)
        if self.TransmissionConstraintList is not None:
            namespaceprefix_ = self.TransmissionConstraintList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TransmissionConstraintList_nsprefix_) else ''
            self.TransmissionConstraintList.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                   name_='TransmissionConstraintList', pretty_print=pretty_print)
        if self.DefaultSignificance is not None:
            namespaceprefix_ = self.DefaultSignificance_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DefaultSignificance_nsprefix_) else ''
            self.DefaultSignificance.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='DefaultSignificance', pretty_print=pretty_print)
        if self.ContextSignificanceList is not None:
            namespaceprefix_ = self.ContextSignificanceList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextSignificanceList_nsprefix_) else ''
            self.ContextSignificanceList.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                name_='ContextSignificanceList', pretty_print=pretty_print)
        if self.Interlock is not None:
            namespaceprefix_ = self.Interlock_nsprefix_ + ':' if (UseCapturedNS_ and self.Interlock_nsprefix_) else ''
            self.Interlock.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Interlock',
                                  pretty_print=pretty_print)
        if self.VerifierSet is not None:
            namespaceprefix_ = self.VerifierSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.VerifierSet_nsprefix_) else ''
            self.VerifierSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VerifierSet',
                                    pretty_print=pretty_print)
        if self.ParameterToSetList is not None:
            namespaceprefix_ = self.ParameterToSetList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterToSetList_nsprefix_) else ''
            self.ParameterToSetList.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='ParameterToSetList', pretty_print=pretty_print)
        if self.ParametersToSuspendAlarmsOnSet is not None:
            namespaceprefix_ = self.ParametersToSuspendAlarmsOnSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParametersToSuspendAlarmsOnSet_nsprefix_) else ''
            self.ParametersToSuspendAlarmsOnSet.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                       name_='ParametersToSuspendAlarmsOnSet',
                                                       pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('abstract', node)
        if value is not None and 'abstract' not in already_processed:
            already_processed.add('abstract')
            if value in ('true', '1'):
                self.abstract = True
            elif value in ('false', '0'):
                self.abstract = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(MetaCommandType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BaseMetaCommand':
            obj_ = BaseMetaCommandType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BaseMetaCommand = obj_
            obj_.original_tagname_ = 'BaseMetaCommand'
        elif nodeName_ == 'SystemName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SystemName')
            value_ = self.gds_validate_string(value_, node, 'SystemName')
            self.SystemName = value_
            self.SystemName_nsprefix_ = child_.prefix
        elif nodeName_ == 'ArgumentList':
            obj_ = ArgumentListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ArgumentList = obj_
            obj_.original_tagname_ = 'ArgumentList'
        elif nodeName_ == 'CommandContainer':
            obj_ = CommandContainerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CommandContainer = obj_
            obj_.original_tagname_ = 'CommandContainer'
        elif nodeName_ == 'TransmissionConstraintList':
            obj_ = TransmissionConstraintListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TransmissionConstraintList = obj_
            obj_.original_tagname_ = 'TransmissionConstraintList'
        elif nodeName_ == 'DefaultSignificance':
            obj_ = SignificanceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DefaultSignificance = obj_
            obj_.original_tagname_ = 'DefaultSignificance'
        elif nodeName_ == 'ContextSignificanceList':
            obj_ = ContextSignificanceListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextSignificanceList = obj_
            obj_.original_tagname_ = 'ContextSignificanceList'
        elif nodeName_ == 'Interlock':
            obj_ = InterlockType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Interlock = obj_
            obj_.original_tagname_ = 'Interlock'
        elif nodeName_ == 'VerifierSet':
            obj_ = VerifierSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VerifierSet = obj_
            obj_.original_tagname_ = 'VerifierSet'
        elif nodeName_ == 'ParameterToSetList':
            obj_ = ParameterToSetListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterToSetList = obj_
            obj_.original_tagname_ = 'ParameterToSetList'
        elif nodeName_ == 'ParametersToSuspendAlarmsOnSet':
            obj_ = ParametersToSuspendAlarmsOnSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParametersToSuspendAlarmsOnSet = obj_
            obj_.original_tagname_ = 'ParametersToSuspendAlarmsOnSet'
        super(MetaCommandType, self).buildChildren(child_, node, nodeName_, True)


# end class MetaCommandType


class CommandVerifierType(OptionalNameDescriptionType):
    """A command verifier is used to check that the command has been
    successfully executed. Command Verifiers may be either a Custom
    Algorithm or a Boolean Check or the presence of a Container for a
    relative change in the value of a Parameter. The CheckWindow is a time
    period where the verification must test true to pass."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = OptionalNameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 ComparisonList=None, ContainerRef=None, ParameterValueChange=None, CustomAlgorithm=None,
                 BooleanExpression=None, Comparison=None, CheckWindow=None, CheckWindowAlgorithms=None,
                 extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CommandVerifierType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                  extensiontype_, **kwargs_)
        self.ComparisonList = ComparisonList
        self.ComparisonList_nsprefix_ = None
        self.ContainerRef = ContainerRef
        self.ContainerRef_nsprefix_ = None
        self.ParameterValueChange = ParameterValueChange
        self.ParameterValueChange_nsprefix_ = None
        self.CustomAlgorithm = CustomAlgorithm
        self.CustomAlgorithm_nsprefix_ = None
        self.BooleanExpression = BooleanExpression
        self.BooleanExpression_nsprefix_ = None
        self.Comparison = Comparison
        self.Comparison_nsprefix_ = None
        self.CheckWindow = CheckWindow
        self.CheckWindow_nsprefix_ = None
        self.CheckWindowAlgorithms = CheckWindowAlgorithms
        self.CheckWindowAlgorithms_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommandVerifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommandVerifierType.subclass:
            return CommandVerifierType.subclass(*args_, **kwargs_)
        else:
            return CommandVerifierType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ComparisonList(self):
        return self.ComparisonList

    def set_ComparisonList(self, ComparisonList):
        self.ComparisonList = ComparisonList

    def get_ContainerRef(self):
        return self.ContainerRef

    def set_ContainerRef(self, ContainerRef):
        self.ContainerRef = ContainerRef

    def get_ParameterValueChange(self):
        return self.ParameterValueChange

    def set_ParameterValueChange(self, ParameterValueChange):
        self.ParameterValueChange = ParameterValueChange

    def get_CustomAlgorithm(self):
        return self.CustomAlgorithm

    def set_CustomAlgorithm(self, CustomAlgorithm):
        self.CustomAlgorithm = CustomAlgorithm

    def get_BooleanExpression(self):
        return self.BooleanExpression

    def set_BooleanExpression(self, BooleanExpression):
        self.BooleanExpression = BooleanExpression

    def get_Comparison(self):
        return self.Comparison

    def set_Comparison(self, Comparison):
        self.Comparison = Comparison

    def get_CheckWindow(self):
        return self.CheckWindow

    def set_CheckWindow(self, CheckWindow):
        self.CheckWindow = CheckWindow

    def get_CheckWindowAlgorithms(self):
        return self.CheckWindowAlgorithms

    def set_CheckWindowAlgorithms(self, CheckWindowAlgorithms):
        self.CheckWindowAlgorithms = CheckWindowAlgorithms

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.ComparisonList is not None or
                self.ContainerRef is not None or
                self.ParameterValueChange is not None or
                self.CustomAlgorithm is not None or
                self.BooleanExpression is not None or
                self.Comparison is not None or
                self.CheckWindow is not None or
                self.CheckWindowAlgorithms is not None or
                super(CommandVerifierType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CommandVerifierType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CommandVerifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CommandVerifierType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CommandVerifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CommandVerifierType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CommandVerifierType'):
        super(CommandVerifierType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                          name_='CommandVerifierType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CommandVerifierType',
                       fromsubclass_=False, pretty_print=True):
        super(CommandVerifierType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                        pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ComparisonList is not None:
            namespaceprefix_ = self.ComparisonList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ComparisonList_nsprefix_) else ''
            self.ComparisonList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ComparisonList',
                                       pretty_print=pretty_print)
        if self.ContainerRef is not None:
            namespaceprefix_ = self.ContainerRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContainerRef_nsprefix_) else ''
            self.ContainerRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContainerRef',
                                     pretty_print=pretty_print)
        if self.ParameterValueChange is not None:
            namespaceprefix_ = self.ParameterValueChange_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterValueChange_nsprefix_) else ''
            self.ParameterValueChange.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='ParameterValueChange', pretty_print=pretty_print)
        if self.CustomAlgorithm is not None:
            namespaceprefix_ = self.CustomAlgorithm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CustomAlgorithm_nsprefix_) else ''
            self.CustomAlgorithm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CustomAlgorithm',
                                        pretty_print=pretty_print)
        if self.BooleanExpression is not None:
            namespaceprefix_ = self.BooleanExpression_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BooleanExpression_nsprefix_) else ''
            self.BooleanExpression.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BooleanExpression',
                                          pretty_print=pretty_print)
        if self.Comparison is not None:
            namespaceprefix_ = self.Comparison_nsprefix_ + ':' if (UseCapturedNS_ and self.Comparison_nsprefix_) else ''
            self.Comparison.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comparison',
                                   pretty_print=pretty_print)
        if self.CheckWindow is not None:
            namespaceprefix_ = self.CheckWindow_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CheckWindow_nsprefix_) else ''
            self.CheckWindow.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CheckWindow',
                                    pretty_print=pretty_print)
        if self.CheckWindowAlgorithms is not None:
            namespaceprefix_ = self.CheckWindowAlgorithms_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CheckWindowAlgorithms_nsprefix_) else ''
            self.CheckWindowAlgorithms.export(outfile, level, namespaceprefix_, namespacedef_='',
                                              name_='CheckWindowAlgorithms', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CommandVerifierType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ComparisonList':
            obj_ = ComparisonListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ComparisonList = obj_
            obj_.original_tagname_ = 'ComparisonList'
        elif nodeName_ == 'ContainerRef':
            obj_ = ContainerRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContainerRef = obj_
            obj_.original_tagname_ = 'ContainerRef'
        elif nodeName_ == 'ParameterValueChange':
            obj_ = ParameterValueChangeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterValueChange = obj_
            obj_.original_tagname_ = 'ParameterValueChange'
        elif nodeName_ == 'CustomAlgorithm':
            class_obj_ = self.get_class_obj_(child_, InputAlgorithmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CustomAlgorithm = obj_
            obj_.original_tagname_ = 'CustomAlgorithm'
        elif nodeName_ == 'BooleanExpression':
            obj_ = BooleanExpressionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BooleanExpression = obj_
            obj_.original_tagname_ = 'BooleanExpression'
        elif nodeName_ == 'Comparison':
            obj_ = ComparisonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comparison = obj_
            obj_.original_tagname_ = 'Comparison'
        elif nodeName_ == 'CheckWindow':
            obj_ = CheckWindowType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CheckWindow = obj_
            obj_.original_tagname_ = 'CheckWindow'
        elif nodeName_ == 'CheckWindowAlgorithms':
            obj_ = CheckWindowAlgorithmsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CheckWindowAlgorithms = obj_
            obj_.original_tagname_ = 'CheckWindowAlgorithms'
        super(CommandVerifierType, self).buildChildren(child_, node, nodeName_, True)


# end class CommandVerifierType


class BlockMetaCommandType(NameDescriptionType):
    """Describe an ordered grouping of MetaCommands into a list, duplicates are
    valid. The block contains argument values fully specified. See
    MetaCommandStepListType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 MetaCommandStepList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BlockMetaCommandType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                   **kwargs_)
        self.MetaCommandStepList = MetaCommandStepList
        self.MetaCommandStepList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BlockMetaCommandType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BlockMetaCommandType.subclass:
            return BlockMetaCommandType.subclass(*args_, **kwargs_)
        else:
            return BlockMetaCommandType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MetaCommandStepList(self):
        return self.MetaCommandStepList

    def set_MetaCommandStepList(self, MetaCommandStepList):
        self.MetaCommandStepList = MetaCommandStepList

    def hasContent_(self):
        if (
                self.MetaCommandStepList is not None or
                super(BlockMetaCommandType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BlockMetaCommandType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BlockMetaCommandType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BlockMetaCommandType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BlockMetaCommandType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BlockMetaCommandType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BlockMetaCommandType'):
        super(BlockMetaCommandType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='BlockMetaCommandType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BlockMetaCommandType',
                       fromsubclass_=False, pretty_print=True):
        super(BlockMetaCommandType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MetaCommandStepList is not None:
            namespaceprefix_ = self.MetaCommandStepList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MetaCommandStepList_nsprefix_) else ''
            self.MetaCommandStepList.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='MetaCommandStepList', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(BlockMetaCommandType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MetaCommandStepList':
            obj_ = MetaCommandStepListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MetaCommandStepList = obj_
            obj_.original_tagname_ = 'MetaCommandStepList'
        super(BlockMetaCommandType, self).buildChildren(child_, node, nodeName_, True)


# end class BlockMetaCommandType


class ArgumentType(NameDescriptionType):
    """An Argument has a name and can take on values with the underlying value
    type described by the ArgumentTypeRef. Describe the properties of a
    command argument referring to a data type (argument type). The bulk of
    properties associated with a command argument are in its argument type.
    The initial value specified here, overrides the initial value in the
    argument type. See BaseDataType, BaseTimeDataType and
    NameReferenceType.Specify the reference to the argument type from the
    ArgumentTypeSet area using the path reference rules, either local to
    this SpaceSystem, relative, or absolute.Specify as: integer data type
    using xs:integer, float data type using xs:double, string data type
    using xs:string, boolean data type using xs:boolean, binary data type
    using xs:hexBinary, enum data type using label name, relative time data
    type using xs:duration, absolute time data type using xs:dateTime.
    Values must not exceed the characteristics for the data type or this is
    a validation error. Takes precedence over an initial value given in the
    data type. Values are calibrated unless there is an option to override
    it."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 argumentTypeRef=None, initialValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                           **kwargs_)
        self.argumentTypeRef = _cast(None, argumentTypeRef)
        self.argumentTypeRef_nsprefix_ = None
        self.initialValue = _cast(None, initialValue)
        self.initialValue_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentType.subclass:
            return ArgumentType.subclass(*args_, **kwargs_)
        else:
            return ArgumentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_argumentTypeRef(self):
        return self.argumentTypeRef

    def set_argumentTypeRef(self, argumentTypeRef):
        self.argumentTypeRef = argumentTypeRef

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                super(ArgumentType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArgumentType'):
        super(ArgumentType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                   name_='ArgumentType')
        if self.argumentTypeRef is not None and 'argumentTypeRef' not in already_processed:
            already_processed.add('argumentTypeRef')
            outfile.write(' argumentTypeRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.argumentTypeRef), input_name='argumentTypeRef')),))
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.initialValue), input_name='initialValue')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentType',
                       fromsubclass_=False, pretty_print=True):
        super(ArgumentType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('argumentTypeRef', node)
        if value is not None and 'argumentTypeRef' not in already_processed:
            already_processed.add('argumentTypeRef')
            self.argumentTypeRef = value
            self.validate_NameReferenceType(self.argumentTypeRef)  # validate type NameReferenceType
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            self.initialValue = value
        super(ArgumentType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ArgumentType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ArgumentType


class ArgumentORedConditionsType(BaseConditionsType):
    """Identical to ORedConditionsType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseConditionsType

    def __init__(self, Condition=None, ANDedConditions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentORedConditionsType, self).__init__(**kwargs_)
        if Condition is None:
            self.Condition = []
        else:
            self.Condition = Condition
        self.Condition_nsprefix_ = None
        if ANDedConditions is None:
            self.ANDedConditions = []
        else:
            self.ANDedConditions = ANDedConditions
        self.ANDedConditions_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentORedConditionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentORedConditionsType.subclass:
            return ArgumentORedConditionsType.subclass(*args_, **kwargs_)
        else:
            return ArgumentORedConditionsType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Condition(self):
        return self.Condition

    def set_Condition(self, Condition):
        self.Condition = Condition

    def add_Condition(self, value):
        self.Condition.append(value)

    def insert_Condition_at(self, index, value):
        self.Condition.insert(index, value)

    def replace_Condition_at(self, index, value):
        self.Condition[index] = value

    def get_ANDedConditions(self):
        return self.ANDedConditions

    def set_ANDedConditions(self, ANDedConditions):
        self.ANDedConditions = ANDedConditions

    def add_ANDedConditions(self, value):
        self.ANDedConditions.append(value)

    def insert_ANDedConditions_at(self, index, value):
        self.ANDedConditions.insert(index, value)

    def replace_ANDedConditions_at(self, index, value):
        self.ANDedConditions[index] = value

    def hasContent_(self):
        if (
                self.Condition or
                self.ANDedConditions or
                super(ArgumentORedConditionsType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentORedConditionsType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentORedConditionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentORedConditionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentORedConditionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentORedConditionsType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentORedConditionsType'):
        super(ArgumentORedConditionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                 name_='ArgumentORedConditionsType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentORedConditionsType',
                       fromsubclass_=False, pretty_print=True):
        super(ArgumentORedConditionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                               True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Condition_ in self.Condition:
            namespaceprefix_ = self.Condition_nsprefix_ + ':' if (UseCapturedNS_ and self.Condition_nsprefix_) else ''
            Condition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Condition',
                              pretty_print=pretty_print)
        for ANDedConditions_ in self.ANDedConditions:
            namespaceprefix_ = self.ANDedConditions_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ANDedConditions_nsprefix_) else ''
            ANDedConditions_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANDedConditions',
                                    pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(ArgumentORedConditionsType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Condition':
            obj_ = ArgumentComparisonCheckType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Condition.append(obj_)
            obj_.original_tagname_ = 'Condition'
        elif nodeName_ == 'ANDedConditions':
            obj_ = ArgumentANDedConditionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANDedConditions.append(obj_)
            obj_.original_tagname_ = 'ANDedConditions'
        super(ArgumentORedConditionsType, self).buildChildren(child_, node, nodeName_, True)


# end class ArgumentORedConditionsType


class ArgumentANDedConditionsType(BaseConditionsType):
    """Identical to ANDedConditionsType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseConditionsType

    def __init__(self, Condition=None, ORedConditions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentANDedConditionsType, self).__init__(**kwargs_)
        if Condition is None:
            self.Condition = []
        else:
            self.Condition = Condition
        self.Condition_nsprefix_ = None
        if ORedConditions is None:
            self.ORedConditions = []
        else:
            self.ORedConditions = ORedConditions
        self.ORedConditions_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentANDedConditionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentANDedConditionsType.subclass:
            return ArgumentANDedConditionsType.subclass(*args_, **kwargs_)
        else:
            return ArgumentANDedConditionsType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Condition(self):
        return self.Condition

    def set_Condition(self, Condition):
        self.Condition = Condition

    def add_Condition(self, value):
        self.Condition.append(value)

    def insert_Condition_at(self, index, value):
        self.Condition.insert(index, value)

    def replace_Condition_at(self, index, value):
        self.Condition[index] = value

    def get_ORedConditions(self):
        return self.ORedConditions

    def set_ORedConditions(self, ORedConditions):
        self.ORedConditions = ORedConditions

    def add_ORedConditions(self, value):
        self.ORedConditions.append(value)

    def insert_ORedConditions_at(self, index, value):
        self.ORedConditions.insert(index, value)

    def replace_ORedConditions_at(self, index, value):
        self.ORedConditions[index] = value

    def hasContent_(self):
        if (
                self.Condition or
                self.ORedConditions or
                super(ArgumentANDedConditionsType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentANDedConditionsType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentANDedConditionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentANDedConditionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentANDedConditionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentANDedConditionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentANDedConditionsType'):
        super(ArgumentANDedConditionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                  name_='ArgumentANDedConditionsType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentANDedConditionsType',
                       fromsubclass_=False, pretty_print=True):
        super(ArgumentANDedConditionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                                True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Condition_ in self.Condition:
            namespaceprefix_ = self.Condition_nsprefix_ + ':' if (UseCapturedNS_ and self.Condition_nsprefix_) else ''
            Condition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Condition',
                              pretty_print=pretty_print)
        for ORedConditions_ in self.ORedConditions:
            namespaceprefix_ = self.ORedConditions_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ORedConditions_nsprefix_) else ''
            ORedConditions_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ORedConditions',
                                   pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(ArgumentANDedConditionsType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Condition':
            obj_ = ArgumentComparisonCheckType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Condition.append(obj_)
            obj_.original_tagname_ = 'Condition'
        elif nodeName_ == 'ORedConditions':
            obj_ = ArgumentORedConditionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ORedConditions.append(obj_)
            obj_.original_tagname_ = 'ORedConditions'
        super(ArgumentANDedConditionsType, self).buildChildren(child_, node, nodeName_, True)


# end class ArgumentANDedConditionsType


class ArgumentInputAlgorithmType(SimpleAlgorithmType):
    """Identical to InputAlgorithmType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SimpleAlgorithmType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 AlgorithmText=None, ExternalAlgorithmSet=None, InputSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentInputAlgorithmType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                         name, AlgorithmText, ExternalAlgorithmSet, **kwargs_)
        self.InputSet = InputSet
        self.InputSet_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentInputAlgorithmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentInputAlgorithmType.subclass:
            return ArgumentInputAlgorithmType.subclass(*args_, **kwargs_)
        else:
            return ArgumentInputAlgorithmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_InputSet(self):
        return self.InputSet

    def set_InputSet(self, InputSet):
        self.InputSet = InputSet

    def hasContent_(self):
        if (
                self.InputSet is not None or
                super(ArgumentInputAlgorithmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentInputAlgorithmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentInputAlgorithmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentInputAlgorithmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentInputAlgorithmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentInputAlgorithmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentInputAlgorithmType'):
        super(ArgumentInputAlgorithmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                 name_='ArgumentInputAlgorithmType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentInputAlgorithmType',
                       fromsubclass_=False, pretty_print=True):
        super(ArgumentInputAlgorithmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                               True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InputSet is not None:
            namespaceprefix_ = self.InputSet_nsprefix_ + ':' if (UseCapturedNS_ and self.InputSet_nsprefix_) else ''
            self.InputSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InputSet',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(ArgumentInputAlgorithmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'InputSet':
            obj_ = ArgumentInputSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InputSet = obj_
            obj_.original_tagname_ = 'InputSet'
        super(ArgumentInputAlgorithmType, self).buildChildren(child_, node, nodeName_, True)


# end class ArgumentInputAlgorithmType


class ArgumentDiscreteLookupType(ArgumentMatchCriteriaType):
    """Identical to ArgumentDiscreteLookupType but supports argument instance
    references.Value to use when the lookup conditions are true."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentMatchCriteriaType

    def __init__(self, Comparison=None, ComparisonList=None, BooleanExpression=None, CustomAlgorithm=None, value=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentDiscreteLookupType, self).__init__(Comparison, ComparisonList, BooleanExpression, CustomAlgorithm,
                                                         **kwargs_)
        self.value = _cast(int, value)
        self.value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentDiscreteLookupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentDiscreteLookupType.subclass:
            return ArgumentDiscreteLookupType.subclass(*args_, **kwargs_)
        else:
            return ArgumentDiscreteLookupType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def hasContent_(self):
        if (
                super(ArgumentDiscreteLookupType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentDiscreteLookupType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentDiscreteLookupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentDiscreteLookupType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentDiscreteLookupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentDiscreteLookupType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentDiscreteLookupType'):
        super(ArgumentDiscreteLookupType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                 name_='ArgumentDiscreteLookupType')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_integer(self.value, input_name='value'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentDiscreteLookupType',
                       fromsubclass_=False, pretty_print=True):
        super(ArgumentDiscreteLookupType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                               True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = self.gds_parse_integer(value, node, 'value')
        super(ArgumentDiscreteLookupType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ArgumentDiscreteLookupType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ArgumentDiscreteLookupType


class ArgumentComparisonCheckType(BaseConditionsType):
    """Identical to ComparisonCheckType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseConditionsType

    def __init__(self, ComparisonOperator=None, ParameterInstanceRef=None, ArgumentInstanceRef=None, Value=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentComparisonCheckType, self).__init__(**kwargs_)
        self.ComparisonOperator = ComparisonOperator
        self.validate_ComparisonOperatorsType(self.ComparisonOperator)
        self.ComparisonOperator_nsprefix_ = None
        self.ParameterInstanceRef = ParameterInstanceRef
        self.ParameterInstanceRef_nsprefix_ = None
        self.ArgumentInstanceRef = ArgumentInstanceRef
        self.ArgumentInstanceRef_nsprefix_ = None
        self.Value = Value
        self.Value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentComparisonCheckType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentComparisonCheckType.subclass:
            return ArgumentComparisonCheckType.subclass(*args_, **kwargs_)
        else:
            return ArgumentComparisonCheckType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ComparisonOperator(self):
        return self.ComparisonOperator

    def set_ComparisonOperator(self, ComparisonOperator):
        self.ComparisonOperator = ComparisonOperator

    def get_ParameterInstanceRef(self):
        return self.ParameterInstanceRef

    def set_ParameterInstanceRef(self, ParameterInstanceRef):
        self.ParameterInstanceRef = ParameterInstanceRef

    def get_ArgumentInstanceRef(self):
        return self.ArgumentInstanceRef

    def set_ArgumentInstanceRef(self, ArgumentInstanceRef):
        self.ArgumentInstanceRef = ArgumentInstanceRef

    def get_Value(self):
        return self.Value

    def set_Value(self, Value):
        self.Value = Value

    def validate_ComparisonOperatorsType(self, value):
        result = True
        # Validate type ComparisonOperatorsType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['==', '!=', '<', '<=', '>', '>=']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ComparisonOperatorsType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def hasContent_(self):
        if (
                self.ComparisonOperator is not None or
                self.ParameterInstanceRef is not None or
                self.ArgumentInstanceRef is not None or
                self.Value is not None or
                super(ArgumentComparisonCheckType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentComparisonCheckType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentComparisonCheckType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentComparisonCheckType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentComparisonCheckType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentComparisonCheckType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentComparisonCheckType'):
        super(ArgumentComparisonCheckType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                  name_='ArgumentComparisonCheckType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentComparisonCheckType',
                       fromsubclass_=False, pretty_print=True):
        super(ArgumentComparisonCheckType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                                True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ComparisonOperator is not None:
            namespaceprefix_ = self.ComparisonOperator_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ComparisonOperator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComparisonOperator>%s</%sComparisonOperator>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.ComparisonOperator), input_name='ComparisonOperator')),
                                                                                 namespaceprefix_, eol_))
        if self.ParameterInstanceRef is not None:
            namespaceprefix_ = self.ParameterInstanceRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterInstanceRef_nsprefix_) else ''
            self.ParameterInstanceRef.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='ParameterInstanceRef', pretty_print=pretty_print)
        if self.ArgumentInstanceRef is not None:
            namespaceprefix_ = self.ArgumentInstanceRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ArgumentInstanceRef_nsprefix_) else ''
            self.ArgumentInstanceRef.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='ArgumentInstanceRef', pretty_print=pretty_print)
        if self.Value is not None:
            namespaceprefix_ = self.Value_nsprefix_ + ':' if (UseCapturedNS_ and self.Value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(ArgumentComparisonCheckType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ComparisonOperator':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ComparisonOperator')
            value_ = self.gds_validate_string(value_, node, 'ComparisonOperator')
            self.ComparisonOperator = value_
            self.ComparisonOperator_nsprefix_ = child_.prefix
            # validate type ComparisonOperatorsType
            self.validate_ComparisonOperatorsType(self.ComparisonOperator)
        elif nodeName_ == 'ParameterInstanceRef':
            class_obj_ = self.get_class_obj_(child_, ParameterInstanceRefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterInstanceRef = obj_
            obj_.original_tagname_ = 'ParameterInstanceRef'
        elif nodeName_ == 'ArgumentInstanceRef':
            obj_ = ArgumentInstanceRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ArgumentInstanceRef = obj_
            obj_.original_tagname_ = 'ArgumentInstanceRef'
        elif nodeName_ == 'Value':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Value')
            value_ = self.gds_validate_string(value_, node, 'Value')
            self.Value = value_
            self.Value_nsprefix_ = child_.prefix
        super(ArgumentComparisonCheckType, self).buildChildren(child_, node, nodeName_, True)


# end class ArgumentComparisonCheckType


class AggregateArgumentType(AggregateDataType):
    """Describe a complex data type analogous to a C-struct. Each field of the
    data type is called a Member. Each Member is part of the MemberList
    which forms the list of items to be placed under this data type’s name.
    The MemberList defines a data block and block’s size is defined by the
    DataEncodings of each Member’s type reference. The data members are
    ordered and contiguous in the MemberList element (packed). Each member
    may be addressed by the dot syntax similar to C such as P.voltage if P
    is the referring parameter and voltage is of a member of P’s aggregate
    type. See MemberType, MemberListType, DataEncodingType,
    NameReferenceType, and AggregateDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AggregateDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 MemberList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AggregateArgumentType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                    MemberList, **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AggregateArgumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AggregateArgumentType.subclass:
            return AggregateArgumentType.subclass(*args_, **kwargs_)
        else:
            return AggregateArgumentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(AggregateArgumentType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AggregateArgumentType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AggregateArgumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AggregateArgumentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregateArgumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AggregateArgumentType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AggregateArgumentType'):
        super(AggregateArgumentType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                            name_='AggregateArgumentType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AggregateArgumentType',
                       fromsubclass_=False, pretty_print=True):
        super(AggregateArgumentType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                          pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(AggregateArgumentType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(AggregateArgumentType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class AggregateArgumentType


class ArrayArgumentType(ArrayDataTypeType):
    """Describe an array argument type. The size and number of dimension are
    described here. See ArrayParameterRefEntryType, NameReferenceType and
    ArrayDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArrayDataTypeType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 arrayTypeRef=None, DimensionList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArrayArgumentType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                arrayTypeRef, **kwargs_)
        self.DimensionList = DimensionList
        self.DimensionList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArrayArgumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArrayArgumentType.subclass:
            return ArrayArgumentType.subclass(*args_, **kwargs_)
        else:
            return ArrayArgumentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DimensionList(self):
        return self.DimensionList

    def set_DimensionList(self, DimensionList):
        self.DimensionList = DimensionList

    def hasContent_(self):
        if (
                self.DimensionList is not None or
                super(ArrayArgumentType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArrayArgumentType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArrayArgumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArrayArgumentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArrayArgumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArrayArgumentType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArrayArgumentType'):
        super(ArrayArgumentType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                        name_='ArrayArgumentType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArrayArgumentType',
                       fromsubclass_=False, pretty_print=True):
        super(ArrayArgumentType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                      pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DimensionList is not None:
            namespaceprefix_ = self.DimensionList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DimensionList_nsprefix_) else ''
            self.DimensionList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DimensionList',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(ArrayArgumentType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DimensionList':
            obj_ = ArgumentDimensionListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionList = obj_
            obj_.original_tagname_ = 'DimensionList'
        super(ArrayArgumentType, self).buildChildren(child_, node, nodeName_, True)


# end class ArrayArgumentType


class AbsoluteTimeArgumentType(ArgumentAbsoluteTimeDataType):
    """Describe an absolute time argument type relative to a known epoch (such
    as TAI). The string representation of this time should use the [ISO
    8601] extended format CCYY-MM-DDThh:mm:ss where "CC" represents the
    century, "YY" the year, "MM" the month and "DD" the day, preceded by an
    optional leading "-" sign to indicate a negative number. If the sign is
    omitted, "+" is assumed. The letter "T" is the date/time separator and
    "hh", "mm", "ss" represent hour, minute and second respectively.
    Additional digits can be used to increase the precision of fractional
    seconds if desired i.e. the format ss.ss... with any number of digits
    after the decimal point is supported. See TAIType, IntegerDataEncoding
    and AbsoluteTimeDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentAbsoluteTimeDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, Encoding=None, ReferenceTime=None, initialValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AbsoluteTimeArgumentType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                       name, baseType, Encoding, ReferenceTime, initialValue, **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbsoluteTimeArgumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbsoluteTimeArgumentType.subclass:
            return AbsoluteTimeArgumentType.subclass(*args_, **kwargs_)
        else:
            return AbsoluteTimeArgumentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(AbsoluteTimeArgumentType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AbsoluteTimeArgumentType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbsoluteTimeArgumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AbsoluteTimeArgumentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbsoluteTimeArgumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AbsoluteTimeArgumentType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='AbsoluteTimeArgumentType'):
        super(AbsoluteTimeArgumentType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                               name_='AbsoluteTimeArgumentType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AbsoluteTimeArgumentType',
                       fromsubclass_=False, pretty_print=True):
        super(AbsoluteTimeArgumentType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                             True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(AbsoluteTimeArgumentType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(AbsoluteTimeArgumentType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class AbsoluteTimeArgumentType


class ParameterType(NameDescriptionType):
    """Describe the properties of a telemetry parameter, including its data
    type (parameter type). The bulk of properties associated with a
    telemetry parameter are in its parameter type. The initial value
    specified here, overrides the initial value in the parameter type. A
    parameter may be local, in which case its parameter type would have no
    data encodings. Ideally such a definition would also set data source in
    parameter properties to ‘local’ but the syntax does not enforce this.
    See BaseDataType, BaseTimeDataType, and NameReferenceType.Specify the
    reference to the parameter type from the ParameterTypeSet area using
    the path reference rules, either local to this SpaceSystem, relative,
    or absolute.Specify as: integer data type using xs:integer, float data
    type using xs:double, string data type using xs:string, boolean data
    type using xs:boolean, binary data type using xs:hexBinary, enum data
    type using label name, relative time data type using xs:duration,
    absolute time data type using xs:dateTime. Values must not exceed the
    characteristics for the data type or this is a validation error. Takes
    precedence over an initial value given in the data type. Values are
    calibrated unless there is an option to override it."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 parameterTypeRef=None, initialValue=None, ParameterProperties=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ParameterType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                            **kwargs_)
        self.parameterTypeRef = _cast(None, parameterTypeRef)
        self.parameterTypeRef_nsprefix_ = None
        self.initialValue = _cast(None, initialValue)
        self.initialValue_nsprefix_ = None
        self.ParameterProperties = ParameterProperties
        self.ParameterProperties_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterType.subclass:
            return ParameterType.subclass(*args_, **kwargs_)
        else:
            return ParameterType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ParameterProperties(self):
        return self.ParameterProperties

    def set_ParameterProperties(self, ParameterProperties):
        self.ParameterProperties = ParameterProperties

    def get_parameterTypeRef(self):
        return self.parameterTypeRef

    def set_parameterTypeRef(self, parameterTypeRef):
        self.parameterTypeRef = parameterTypeRef

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                self.ParameterProperties is not None or
                super(ParameterType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParameterType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParameterType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParameterType'):
        super(ParameterType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                    name_='ParameterType')
        if self.parameterTypeRef is not None and 'parameterTypeRef' not in already_processed:
            already_processed.add('parameterTypeRef')
            outfile.write(' parameterTypeRef=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.parameterTypeRef), input_name='parameterTypeRef')),))
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.initialValue), input_name='initialValue')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParameterType',
                       fromsubclass_=False, pretty_print=True):
        super(ParameterType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                  pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ParameterProperties is not None:
            namespaceprefix_ = self.ParameterProperties_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterProperties_nsprefix_) else ''
            self.ParameterProperties.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='ParameterProperties', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameterTypeRef', node)
        if value is not None and 'parameterTypeRef' not in already_processed:
            already_processed.add('parameterTypeRef')
            self.parameterTypeRef = value
            self.validate_NameReferenceType(self.parameterTypeRef)  # validate type NameReferenceType
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            self.initialValue = value
        super(ParameterType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ParameterProperties':
            obj_ = ParameterPropertiesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterProperties = obj_
            obj_.original_tagname_ = 'ParameterProperties'
        super(ParameterType, self).buildChildren(child_, node, nodeName_, True)


# end class ParameterType


class ParameterInstanceRefType(ParameterRefType):
    """A reference to an instance of a Parameter. Used when the value of a
    parameter is required for a calculation or as an index value. A
    positive value for instance is forward in time, a negative value for
    count is backward in time, a 0 value for count means use the current
    value of the parameter or the first value in a container."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ParameterRefType

    def __init__(self, parameterRef=None, instance=0, useCalibratedValue=True, extensiontype_=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ParameterInstanceRefType, self).__init__(parameterRef, extensiontype_, **kwargs_)
        self.instance = _cast(int, instance)
        self.instance_nsprefix_ = None
        self.useCalibratedValue = _cast(bool, useCalibratedValue)
        self.useCalibratedValue_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterInstanceRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterInstanceRefType.subclass:
            return ParameterInstanceRefType.subclass(*args_, **kwargs_)
        else:
            return ParameterInstanceRefType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_instance(self):
        return self.instance

    def set_instance(self, instance):
        self.instance = instance

    def get_useCalibratedValue(self):
        return self.useCalibratedValue

    def set_useCalibratedValue(self, useCalibratedValue):
        self.useCalibratedValue = useCalibratedValue

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                super(ParameterInstanceRefType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParameterInstanceRefType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterInstanceRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterInstanceRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterInstanceRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParameterInstanceRefType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ParameterInstanceRefType'):
        super(ParameterInstanceRefType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                               name_='ParameterInstanceRefType')
        if self.instance != 0 and 'instance' not in already_processed:
            already_processed.add('instance')
            outfile.write(' instance="%s"' % self.gds_format_integer(self.instance, input_name='instance'))
        if not self.useCalibratedValue and 'useCalibratedValue' not in already_processed:
            already_processed.add('useCalibratedValue')
            outfile.write(' useCalibratedValue="%s"' % self.gds_format_boolean(self.useCalibratedValue,
                                                                               input_name='useCalibratedValue'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParameterInstanceRefType',
                       fromsubclass_=False, pretty_print=True):
        super(ParameterInstanceRefType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                             True, pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instance', node)
        if value is not None and 'instance' not in already_processed:
            already_processed.add('instance')
            self.instance = self.gds_parse_integer(value, node, 'instance')
        value = find_attr_value_('useCalibratedValue', node)
        if value is not None and 'useCalibratedValue' not in already_processed:
            already_processed.add('useCalibratedValue')
            if value in ('true', '1'):
                self.useCalibratedValue = True
            elif value in ('false', '0'):
                self.useCalibratedValue = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ParameterInstanceRefType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ParameterInstanceRefType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ParameterInstanceRefType


class ArrayParameterType(ArrayDataTypeType):
    """Describe an array parameter type. The size and number of dimensions are
    described here. See ArrayParameterRefEntryType, NameReferenceType and
    ArrayDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArrayDataTypeType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 arrayTypeRef=None, DimensionList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArrayParameterType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                 arrayTypeRef, **kwargs_)
        self.DimensionList = DimensionList
        self.DimensionList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArrayParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArrayParameterType.subclass:
            return ArrayParameterType.subclass(*args_, **kwargs_)
        else:
            return ArrayParameterType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DimensionList(self):
        return self.DimensionList

    def set_DimensionList(self, DimensionList):
        self.DimensionList = DimensionList

    def hasContent_(self):
        if (
                self.DimensionList is not None or
                super(ArrayParameterType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArrayParameterType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArrayParameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArrayParameterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArrayParameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArrayParameterType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArrayParameterType'):
        super(ArrayParameterType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                         name_='ArrayParameterType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArrayParameterType',
                       fromsubclass_=False, pretty_print=True):
        super(ArrayParameterType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                       pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DimensionList is not None:
            namespaceprefix_ = self.DimensionList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DimensionList_nsprefix_) else ''
            self.DimensionList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DimensionList',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(ArrayParameterType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DimensionList':
            obj_ = DimensionListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionList = obj_
            obj_.original_tagname_ = 'DimensionList'
        super(ArrayParameterType, self).buildChildren(child_, node, nodeName_, True)


# end class ArrayParameterType


class AggregateParameterType(AggregateDataType):
    """Describe a complex data type analogous to a C-struct. Each field of the
    data type is called a Member. Each Member is part of the MemberList
    which forms the list of items to be placed under this data type’s name.
    The MemberList defines a data block and block’s size is defined by the
    DataEncodings of each Member’s type reference. The data members are
    ordered and contiguous in the MemberList element (packed). Each member
    may be addressed by the dot syntax similar to C such as P.voltage if P
    is the referring parameter and voltage is of a member of P’s aggregate
    type. See MemberType, MemberListType, DataEncodingType,
    NameReferenceType, and AggregateDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AggregateDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 MemberList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AggregateParameterType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                     name, MemberList, **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AggregateParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AggregateParameterType.subclass:
            return AggregateParameterType.subclass(*args_, **kwargs_)
        else:
            return AggregateParameterType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(AggregateParameterType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AggregateParameterType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AggregateParameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AggregateParameterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregateParameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AggregateParameterType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AggregateParameterType'):
        super(AggregateParameterType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                             name_='AggregateParameterType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AggregateParameterType',
                       fromsubclass_=False, pretty_print=True):
        super(AggregateParameterType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                           pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(AggregateParameterType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(AggregateParameterType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class AggregateParameterType


class AbsoluteTimeParameterType(AbsoluteTimeDataType):
    """Describe an absolute time parameter type relative to a known epoch (such
    as TAI). The string representation of this time should use the [ISO
    8601] extended format CCYY-MM-DDThh:mm:ss where "CC" represents the
    century, "YY" the year, "MM" the month and "DD" the day, preceded by an
    optional leading "-" sign to indicate a negative number. If the sign is
    omitted, "+" is assumed. The letter "T" is the date/time separator and
    "hh", "mm", "ss" represent hour, minute and second respectively.
    Additional digits can be used to increase the precision of fractional
    seconds if desired i.e. the format ss.ss... with any number of digits
    after the decimal point is supported. See TAIType, IntegerDataEncoding
    and AbsoluteTimeDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AbsoluteTimeDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, Encoding=None, ReferenceTime=None, initialValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AbsoluteTimeParameterType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                        name, baseType, Encoding, ReferenceTime, initialValue,
                                                        **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbsoluteTimeParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbsoluteTimeParameterType.subclass:
            return AbsoluteTimeParameterType.subclass(*args_, **kwargs_)
        else:
            return AbsoluteTimeParameterType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(AbsoluteTimeParameterType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AbsoluteTimeParameterType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbsoluteTimeParameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AbsoluteTimeParameterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbsoluteTimeParameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AbsoluteTimeParameterType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='AbsoluteTimeParameterType'):
        super(AbsoluteTimeParameterType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                name_='AbsoluteTimeParameterType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AbsoluteTimeParameterType',
                       fromsubclass_=False, pretty_print=True):
        super(AbsoluteTimeParameterType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                              True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(AbsoluteTimeParameterType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(AbsoluteTimeParameterType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class AbsoluteTimeParameterType


class RestrictionCriteriaType(MatchCriteriaType):
    """Define one or more conditions (constraints) for container inheritance. A
    container is instantiable if its constraints are true. Constraint
    conditions may be a comparison, a list of comparisons, a boolean
    expression, or a graph of containers that are instantiable (if all
    containers are instantiable the condition is true). See
    BaseContainerType, ComparisonType, ComparisonListType,
    BooleanExpressionType and NextContainerType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MatchCriteriaType

    def __init__(self, Comparison=None, ComparisonList=None, BooleanExpression=None, CustomAlgorithm=None,
                 NextContainer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RestrictionCriteriaType, self).__init__(Comparison, ComparisonList, BooleanExpression, CustomAlgorithm,
                                                      **kwargs_)
        self.NextContainer = NextContainer
        self.NextContainer_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RestrictionCriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RestrictionCriteriaType.subclass:
            return RestrictionCriteriaType.subclass(*args_, **kwargs_)
        else:
            return RestrictionCriteriaType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_NextContainer(self):
        return self.NextContainer

    def set_NextContainer(self, NextContainer):
        self.NextContainer = NextContainer

    def hasContent_(self):
        if (
                self.NextContainer is not None or
                super(RestrictionCriteriaType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RestrictionCriteriaType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RestrictionCriteriaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RestrictionCriteriaType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RestrictionCriteriaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RestrictionCriteriaType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RestrictionCriteriaType'):
        super(RestrictionCriteriaType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                              name_='RestrictionCriteriaType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RestrictionCriteriaType',
                       fromsubclass_=False, pretty_print=True):
        super(RestrictionCriteriaType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                            True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NextContainer is not None:
            namespaceprefix_ = self.NextContainer_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.NextContainer_nsprefix_) else ''
            self.NextContainer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NextContainer',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(RestrictionCriteriaType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NextContainer':
            obj_ = ContainerRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NextContainer = obj_
            obj_.original_tagname_ = 'NextContainer'
        super(RestrictionCriteriaType, self).buildChildren(child_, node, nodeName_, True)


# end class RestrictionCriteriaType


class MessageSetType(OptionalNameDescriptionType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = OptionalNameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 Message=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MessageSetType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                             **kwargs_)
        if Message is None:
            self.Message = []
        else:
            self.Message = Message
        self.Message_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageSetType.subclass:
            return MessageSetType.subclass(*args_, **kwargs_)
        else:
            return MessageSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Message(self):
        return self.Message

    def set_Message(self, Message):
        self.Message = Message

    def add_Message(self, value):
        self.Message.append(value)

    def insert_Message_at(self, index, value):
        self.Message.insert(index, value)

    def replace_Message_at(self, index, value):
        self.Message[index] = value

    def hasContent_(self):
        if (
                self.Message or
                super(MessageSetType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MessageSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MessageSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MessageSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessageSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MessageSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MessageSetType'):
        super(MessageSetType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                     name_='MessageSetType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MessageSetType',
                       fromsubclass_=False, pretty_print=True):
        super(MessageSetType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                   pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Message_ in self.Message:
            namespaceprefix_ = self.Message_nsprefix_ + ':' if (UseCapturedNS_ and self.Message_nsprefix_) else ''
            Message_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Message',
                            pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(MessageSetType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Message':
            obj_ = MessageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Message.append(obj_)
            obj_.original_tagname_ = 'Message'
        super(MessageSetType, self).buildChildren(child_, node, nodeName_, True)


# end class MessageSetType


class MessageType(NameDescriptionType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 MatchCriteria=None, ContainerRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MessageType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                          **kwargs_)
        self.MatchCriteria = MatchCriteria
        self.MatchCriteria_nsprefix_ = None
        self.ContainerRef = ContainerRef
        self.ContainerRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageType.subclass:
            return MessageType.subclass(*args_, **kwargs_)
        else:
            return MessageType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MatchCriteria(self):
        return self.MatchCriteria

    def set_MatchCriteria(self, MatchCriteria):
        self.MatchCriteria = MatchCriteria

    def get_ContainerRef(self):
        return self.ContainerRef

    def set_ContainerRef(self, ContainerRef):
        self.ContainerRef = ContainerRef

    def hasContent_(self):
        if (
                self.MatchCriteria is not None or
                self.ContainerRef is not None or
                super(MessageType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MessageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MessageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MessageType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MessageType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MessageType'):
        super(MessageType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                  name_='MessageType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MessageType',
                       fromsubclass_=False, pretty_print=True):
        super(MessageType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MatchCriteria is not None:
            namespaceprefix_ = self.MatchCriteria_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MatchCriteria_nsprefix_) else ''
            self.MatchCriteria.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MatchCriteria',
                                      pretty_print=pretty_print)
        if self.ContainerRef is not None:
            namespaceprefix_ = self.ContainerRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContainerRef_nsprefix_) else ''
            self.ContainerRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContainerRef',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(MessageType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MatchCriteria':
            class_obj_ = self.get_class_obj_(child_, MatchCriteriaType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MatchCriteria = obj_
            obj_.original_tagname_ = 'MatchCriteria'
        elif nodeName_ == 'ContainerRef':
            obj_ = ContainerRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContainerRef = obj_
            obj_.original_tagname_ = 'ContainerRef'
        super(MessageType, self).buildChildren(child_, node, nodeName_, True)


# end class MessageType


class ServiceType(NameDescriptionType):
    """Holds a set of services, logical groups of containers OR messages (not
    both)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 MessageRefSet=None, ContainerRefSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ServiceType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                          **kwargs_)
        self.MessageRefSet = MessageRefSet
        self.MessageRefSet_nsprefix_ = None
        self.ContainerRefSet = ContainerRefSet
        self.ContainerRefSet_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceType.subclass:
            return ServiceType.subclass(*args_, **kwargs_)
        else:
            return ServiceType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MessageRefSet(self):
        return self.MessageRefSet

    def set_MessageRefSet(self, MessageRefSet):
        self.MessageRefSet = MessageRefSet

    def get_ContainerRefSet(self):
        return self.ContainerRefSet

    def set_ContainerRefSet(self, ContainerRefSet):
        self.ContainerRefSet = ContainerRefSet

    def hasContent_(self):
        if (
                self.MessageRefSet is not None or
                self.ContainerRefSet is not None or
                super(ServiceType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ServiceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceType'):
        super(ServiceType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                  name_='ServiceType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceType',
                       fromsubclass_=False, pretty_print=True):
        super(ServiceType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MessageRefSet is not None:
            namespaceprefix_ = self.MessageRefSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MessageRefSet_nsprefix_) else ''
            self.MessageRefSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MessageRefSet',
                                      pretty_print=pretty_print)
        if self.ContainerRefSet is not None:
            namespaceprefix_ = self.ContainerRefSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContainerRefSet_nsprefix_) else ''
            self.ContainerRefSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContainerRefSet',
                                        pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(ServiceType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MessageRefSet':
            obj_ = MessageRefSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MessageRefSet = obj_
            obj_.original_tagname_ = 'MessageRefSet'
        elif nodeName_ == 'ContainerRefSet':
            obj_ = ContainerRefSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContainerRefSet = obj_
            obj_.original_tagname_ = 'ContainerRefSet'
        super(ServiceType, self).buildChildren(child_, node, nodeName_, True)


# end class ServiceType


class ParameterSegmentRefEntryType(SequenceEntryType):
    """An entry that is only a portion of a parameter value indicating that the
    entire parameter value must be assembled from other parameter segments.
    It is assumed that parameter segments happen sequentially in time, that
    is the first part if a telemetry parameter first, however (and there's
    always a however), if this is not the case the order of this parameter
    segment may be supplied with the order attribute where the first
    segment order="0"."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 TimeAssociation=None, AncillaryDataSet=None, parameterRef=None, order=None, sizeInBits=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ParameterSegmentRefEntryType, self).__init__(shortDescription, LocationInContainerInBits, RepeatEntry,
                                                           IncludeCondition, TimeAssociation, AncillaryDataSet,
                                                           **kwargs_)
        self.parameterRef = _cast(None, parameterRef)
        self.parameterRef_nsprefix_ = None
        self.order = _cast(int, order)
        self.order_nsprefix_ = None
        self.sizeInBits = _cast(int, sizeInBits)
        self.sizeInBits_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterSegmentRefEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterSegmentRefEntryType.subclass:
            return ParameterSegmentRefEntryType.subclass(*args_, **kwargs_)
        else:
            return ParameterSegmentRefEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_parameterRef(self):
        return self.parameterRef

    def set_parameterRef(self, parameterRef):
        self.parameterRef = parameterRef

    def get_order(self):
        return self.order

    def set_order(self, order):
        self.order = order

    def get_sizeInBits(self):
        return self.sizeInBits

    def set_sizeInBits(self, sizeInBits):
        self.sizeInBits = sizeInBits

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(ParameterSegmentRefEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParameterSegmentRefEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterSegmentRefEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterSegmentRefEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterSegmentRefEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ParameterSegmentRefEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ParameterSegmentRefEntryType'):
        super(ParameterSegmentRefEntryType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                   name_='ParameterSegmentRefEntryType')
        if self.parameterRef is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            outfile.write(' parameterRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.parameterRef), input_name='parameterRef')),))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order="%s"' % self.gds_format_integer(self.order, input_name='order'))
        if self.sizeInBits is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            outfile.write(' sizeInBits="%s"' % self.gds_format_integer(self.sizeInBits, input_name='sizeInBits'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ParameterSegmentRefEntryType', fromsubclass_=False, pretty_print=True):
        super(ParameterSegmentRefEntryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                                 True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameterRef', node)
        if value is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            self.parameterRef = value
            self.validate_NameReferenceType(self.parameterRef)  # validate type NameReferenceType
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            self.order = self.gds_parse_integer(value, node, 'order')
            self.validate_PositiveLongType(self.order)  # validate type PositiveLongType
        value = find_attr_value_('sizeInBits', node)
        if value is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            self.sizeInBits = self.gds_parse_integer(value, node, 'sizeInBits')
            self.validate_PositiveLongType(self.sizeInBits)  # validate type PositiveLongType
        super(ParameterSegmentRefEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ParameterSegmentRefEntryType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ParameterSegmentRefEntryType


class ParameterRefEntryType(SequenceEntryType):
    """An entry that is a single Parameter"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 TimeAssociation=None, AncillaryDataSet=None, parameterRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ParameterRefEntryType, self).__init__(shortDescription, LocationInContainerInBits, RepeatEntry,
                                                    IncludeCondition, TimeAssociation, AncillaryDataSet, **kwargs_)
        self.parameterRef = _cast(None, parameterRef)
        self.parameterRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterRefEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterRefEntryType.subclass:
            return ParameterRefEntryType.subclass(*args_, **kwargs_)
        else:
            return ParameterRefEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_parameterRef(self):
        return self.parameterRef

    def set_parameterRef(self, parameterRef):
        self.parameterRef = parameterRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                super(ParameterRefEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParameterRefEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterRefEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterRefEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterRefEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParameterRefEntryType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParameterRefEntryType'):
        super(ParameterRefEntryType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                            name_='ParameterRefEntryType')
        if self.parameterRef is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            outfile.write(' parameterRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.parameterRef), input_name='parameterRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParameterRefEntryType',
                       fromsubclass_=False, pretty_print=True):
        super(ParameterRefEntryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                          pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameterRef', node)
        if value is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            self.parameterRef = value
            self.validate_NameReferenceType(self.parameterRef)  # validate type NameReferenceType
        super(ParameterRefEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ParameterRefEntryType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ParameterRefEntryType


class ArgumentLocationInContainerInBitsType(ArgumentIntegerValueType):
    """Identical to LocationInContainerInBitsType but supports argument
    instance references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentIntegerValueType

    def __init__(self, FixedValue=None, DynamicValue=None, DiscreteLookupList=None, referenceLocation='previousEntry',
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentLocationInContainerInBitsType, self).__init__(FixedValue, DynamicValue, DiscreteLookupList,
                                                                    **kwargs_)
        self.referenceLocation = _cast(None, referenceLocation)
        self.referenceLocation_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentLocationInContainerInBitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentLocationInContainerInBitsType.subclass:
            return ArgumentLocationInContainerInBitsType.subclass(*args_, **kwargs_)
        else:
            return ArgumentLocationInContainerInBitsType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_referenceLocation(self):
        return self.referenceLocation

    def set_referenceLocation(self, referenceLocation):
        self.referenceLocation = referenceLocation

    def validate_ReferenceLocationType(self, value):
        # Validate type xtce:ReferenceLocationType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['containerStart', 'containerEnd', 'previousEntry', 'nextEntry']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ReferenceLocationType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(ArgumentLocationInContainerInBitsType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='',
               name_='ArgumentLocationInContainerInBitsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentLocationInContainerInBitsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentLocationInContainerInBitsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='ArgumentLocationInContainerInBitsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentLocationInContainerInBitsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentLocationInContainerInBitsType'):
        super(ArgumentLocationInContainerInBitsType, self).exportAttributes(outfile, level, already_processed,
                                                                            namespaceprefix_,
                                                                            name_='ArgumentLocationInContainerInBitsType')
        if self.referenceLocation != "previousEntry" and 'referenceLocation' not in already_processed:
            already_processed.add('referenceLocation')
            outfile.write(' referenceLocation=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.referenceLocation), input_name='referenceLocation')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ArgumentLocationInContainerInBitsType', fromsubclass_=False, pretty_print=True):
        super(ArgumentLocationInContainerInBitsType, self).exportChildren(outfile, level, namespaceprefix_,
                                                                          namespacedef_, name_, True,
                                                                          pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referenceLocation', node)
        if value is not None and 'referenceLocation' not in already_processed:
            already_processed.add('referenceLocation')
            self.referenceLocation = value
            self.validate_ReferenceLocationType(self.referenceLocation)  # validate type ReferenceLocationType
        super(ArgumentLocationInContainerInBitsType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ArgumentLocationInContainerInBitsType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ArgumentLocationInContainerInBitsType


class LocationInContainerInBitsType(IntegerValueType):
    """Describe the absolute or relative bit location of an entry in a
    container. The "referenceLocation" attribute specifies the starting bit
    anchor. If no referenceLocation value is given, the entry is assumed to
    begin at the first bit position after the previous entry. Each
    container starts at bit 0, thus "containerStart" is an offset from 0.
    Negative container start bits are before the container and are
    implementation dependent – these should be flagged as likely errors.
    "containerEnd" is given as a positive offset from the end of the
    container, thus a container end of 0 is exactly at the end of the
    container. Negative container end addresses are after the container and
    are implementation dependent – these should be flagged as likely
    errors. Positive "previouEntry" values are offsets from the previous
    entry – zero (0) is the default which means it follows contiguously
    from the last occupied bit of the previous entry. A value of one means
    it is offset 1-bit from the previous entry, and a value of negative 1
    (-1) means it overlaps the previous entry by one bit, and so forth. The
    "nextEntry" attribute value is proposed for deprecation and should be
    avoided. See SequenceEntryType.Defines the relative reference used to
    interpret the start bit position. The default is 0 bits from the end of
    the previousEntry, which makes the entry contiguous."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IntegerValueType

    def __init__(self, FixedValue=None, DynamicValue=None, DiscreteLookupList=None, referenceLocation='previousEntry',
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LocationInContainerInBitsType, self).__init__(FixedValue, DynamicValue, DiscreteLookupList, **kwargs_)
        self.referenceLocation = _cast(None, referenceLocation)
        self.referenceLocation_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocationInContainerInBitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocationInContainerInBitsType.subclass:
            return LocationInContainerInBitsType.subclass(*args_, **kwargs_)
        else:
            return LocationInContainerInBitsType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_referenceLocation(self):
        return self.referenceLocation

    def set_referenceLocation(self, referenceLocation):
        self.referenceLocation = referenceLocation

    def validate_ReferenceLocationType(self, value):
        # Validate type xtce:ReferenceLocationType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['containerStart', 'containerEnd', 'previousEntry', 'nextEntry']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ReferenceLocationType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(LocationInContainerInBitsType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LocationInContainerInBitsType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocationInContainerInBitsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LocationInContainerInBitsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='LocationInContainerInBitsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='LocationInContainerInBitsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='LocationInContainerInBitsType'):
        super(LocationInContainerInBitsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                    name_='LocationInContainerInBitsType')
        if self.referenceLocation != "previousEntry" and 'referenceLocation' not in already_processed:
            already_processed.add('referenceLocation')
            outfile.write(' referenceLocation=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.referenceLocation), input_name='referenceLocation')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='LocationInContainerInBitsType', fromsubclass_=False, pretty_print=True):
        super(LocationInContainerInBitsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_,
                                                                  name_, True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referenceLocation', node)
        if value is not None and 'referenceLocation' not in already_processed:
            already_processed.add('referenceLocation')
            self.referenceLocation = value
            self.validate_ReferenceLocationType(self.referenceLocation)  # validate type ReferenceLocationType
        super(LocationInContainerInBitsType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(LocationInContainerInBitsType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class LocationInContainerInBitsType


class IndirectParameterRefEntryType(SequenceEntryType):
    """An entry whose name is given by the value of a ParamameterInstance. This
    entry may be used to implement dwell telemetry streams. The value of
    the parameter in ParameterInstance must use either the name of the
    Parameter or its alias. If it's an alias name, the alias namespace is
    supplied as an attribute."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 TimeAssociation=None, AncillaryDataSet=None, aliasNameSpace=None, ParameterInstance=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IndirectParameterRefEntryType, self).__init__(shortDescription, LocationInContainerInBits, RepeatEntry,
                                                            IncludeCondition, TimeAssociation, AncillaryDataSet,
                                                            **kwargs_)
        self.aliasNameSpace = _cast(None, aliasNameSpace)
        self.aliasNameSpace_nsprefix_ = None
        self.ParameterInstance = ParameterInstance
        self.ParameterInstance_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndirectParameterRefEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndirectParameterRefEntryType.subclass:
            return IndirectParameterRefEntryType.subclass(*args_, **kwargs_)
        else:
            return IndirectParameterRefEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ParameterInstance(self):
        return self.ParameterInstance

    def set_ParameterInstance(self, ParameterInstance):
        self.ParameterInstance = ParameterInstance

    def get_aliasNameSpace(self):
        return self.aliasNameSpace

    def set_aliasNameSpace(self, aliasNameSpace):
        self.aliasNameSpace = aliasNameSpace

    def hasContent_(self):
        if (
                self.ParameterInstance is not None or
                super(IndirectParameterRefEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IndirectParameterRefEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IndirectParameterRefEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IndirectParameterRefEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='IndirectParameterRefEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='IndirectParameterRefEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='IndirectParameterRefEntryType'):
        super(IndirectParameterRefEntryType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                    name_='IndirectParameterRefEntryType')
        if self.aliasNameSpace is not None and 'aliasNameSpace' not in already_processed:
            already_processed.add('aliasNameSpace')
            outfile.write(' aliasNameSpace=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.aliasNameSpace), input_name='aliasNameSpace')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='IndirectParameterRefEntryType', fromsubclass_=False, pretty_print=True):
        super(IndirectParameterRefEntryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_,
                                                                  name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ParameterInstance is not None:
            namespaceprefix_ = self.ParameterInstance_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterInstance_nsprefix_) else ''
            self.ParameterInstance.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ParameterInstance',
                                          pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aliasNameSpace', node)
        if value is not None and 'aliasNameSpace' not in already_processed:
            already_processed.add('aliasNameSpace')
            self.aliasNameSpace = value
        super(IndirectParameterRefEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ParameterInstance':
            class_obj_ = self.get_class_obj_(child_, ParameterInstanceRefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterInstance = obj_
            obj_.original_tagname_ = 'ParameterInstance'
        super(IndirectParameterRefEntryType, self).buildChildren(child_, node, nodeName_, True)


# end class IndirectParameterRefEntryType


class ContainerSegmentRefEntryType(SequenceEntryType):
    """An entry that is only a portion of a container indicating that the
    entire container must be assembled from other container segments. It is
    assumed that container segments happen sequentially in time, that is
    the first part of a container is first, however (and there's always a
    however), if this is not the case the order of this container segment
    may be supplied with the order attribute where the first segment
    order="0". Each instance of a container cannot overlap in the overall
    sequence with another instance"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 TimeAssociation=None, AncillaryDataSet=None, containerRef=None, order=None, sizeInBits=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ContainerSegmentRefEntryType, self).__init__(shortDescription, LocationInContainerInBits, RepeatEntry,
                                                           IncludeCondition, TimeAssociation, AncillaryDataSet,
                                                           **kwargs_)
        self.containerRef = _cast(None, containerRef)
        self.containerRef_nsprefix_ = None
        self.order = _cast(int, order)
        self.order_nsprefix_ = None
        self.sizeInBits = _cast(int, sizeInBits)
        self.sizeInBits_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContainerSegmentRefEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContainerSegmentRefEntryType.subclass:
            return ContainerSegmentRefEntryType.subclass(*args_, **kwargs_)
        else:
            return ContainerSegmentRefEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_containerRef(self):
        return self.containerRef

    def set_containerRef(self, containerRef):
        self.containerRef = containerRef

    def get_order(self):
        return self.order

    def set_order(self, order):
        self.order = order

    def get_sizeInBits(self):
        return self.sizeInBits

    def set_sizeInBits(self, sizeInBits):
        self.sizeInBits = sizeInBits

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(ContainerSegmentRefEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContainerSegmentRefEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContainerSegmentRefEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContainerSegmentRefEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContainerSegmentRefEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ContainerSegmentRefEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ContainerSegmentRefEntryType'):
        super(ContainerSegmentRefEntryType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                   name_='ContainerSegmentRefEntryType')
        if self.containerRef is not None and 'containerRef' not in already_processed:
            already_processed.add('containerRef')
            outfile.write(' containerRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.containerRef), input_name='containerRef')),))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order="%s"' % self.gds_format_integer(self.order, input_name='order'))
        if self.sizeInBits is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            outfile.write(' sizeInBits="%s"' % self.gds_format_integer(self.sizeInBits, input_name='sizeInBits'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ContainerSegmentRefEntryType', fromsubclass_=False, pretty_print=True):
        super(ContainerSegmentRefEntryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                                 True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('containerRef', node)
        if value is not None and 'containerRef' not in already_processed:
            already_processed.add('containerRef')
            self.containerRef = value
            self.validate_NameReferenceType(self.containerRef)  # validate type NameReferenceType
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            self.order = self.gds_parse_integer(value, node, 'order')
            self.validate_PositiveLongType(self.order)  # validate type PositiveLongType
        value = find_attr_value_('sizeInBits', node)
        if value is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            self.sizeInBits = self.gds_parse_integer(value, node, 'sizeInBits')
            self.validate_PositiveLongType(self.sizeInBits)  # validate type PositiveLongType
        super(ContainerSegmentRefEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ContainerSegmentRefEntryType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ContainerSegmentRefEntryType


class ContainerRefEntryType(SequenceEntryType):
    """An entry that is simply a reference to another container."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 TimeAssociation=None, AncillaryDataSet=None, containerRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ContainerRefEntryType, self).__init__(shortDescription, LocationInContainerInBits, RepeatEntry,
                                                    IncludeCondition, TimeAssociation, AncillaryDataSet, **kwargs_)
        self.containerRef = _cast(None, containerRef)
        self.containerRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContainerRefEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContainerRefEntryType.subclass:
            return ContainerRefEntryType.subclass(*args_, **kwargs_)
        else:
            return ContainerRefEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_containerRef(self):
        return self.containerRef

    def set_containerRef(self, containerRef):
        self.containerRef = containerRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                super(ContainerRefEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContainerRefEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContainerRefEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContainerRefEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContainerRefEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContainerRefEntryType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContainerRefEntryType'):
        super(ContainerRefEntryType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                            name_='ContainerRefEntryType')
        if self.containerRef is not None and 'containerRef' not in already_processed:
            already_processed.add('containerRef')
            outfile.write(' containerRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.containerRef), input_name='containerRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContainerRefEntryType',
                       fromsubclass_=False, pretty_print=True):
        super(ContainerRefEntryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                          pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('containerRef', node)
        if value is not None and 'containerRef' not in already_processed:
            already_processed.add('containerRef')
            self.containerRef = value
            self.validate_NameReferenceType(self.containerRef)  # validate type NameReferenceType
        super(ContainerRefEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ContainerRefEntryType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ContainerRefEntryType


class ContainerType(NameDescriptionType):
    """An abstract block of data; used as the base type for more specific
    container typesRateInStream is used to: a) generate alarms when the
    Container is updated too frequently or too infrequently, b) provide
    some 'guidelines' for generating forward link containers, c) provide
    some guidelines for spacecraft simulators to generate telemetry
    containers. If necessary, these rates may be defined on a per stream
    basis."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 DefaultRateInStream=None, RateInStreamSet=None, BinaryEncoding=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ContainerType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                            extensiontype_, **kwargs_)
        self.DefaultRateInStream = DefaultRateInStream
        self.DefaultRateInStream_nsprefix_ = None
        self.RateInStreamSet = RateInStreamSet
        self.RateInStreamSet_nsprefix_ = None
        self.BinaryEncoding = BinaryEncoding
        self.BinaryEncoding_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContainerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContainerType.subclass:
            return ContainerType.subclass(*args_, **kwargs_)
        else:
            return ContainerType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DefaultRateInStream(self):
        return self.DefaultRateInStream

    def set_DefaultRateInStream(self, DefaultRateInStream):
        self.DefaultRateInStream = DefaultRateInStream

    def get_RateInStreamSet(self):
        return self.RateInStreamSet

    def set_RateInStreamSet(self, RateInStreamSet):
        self.RateInStreamSet = RateInStreamSet

    def get_BinaryEncoding(self):
        return self.BinaryEncoding

    def set_BinaryEncoding(self, BinaryEncoding):
        self.BinaryEncoding = BinaryEncoding

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.DefaultRateInStream is not None or
                self.RateInStreamSet is not None or
                self.BinaryEncoding is not None or
                super(ContainerType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContainerType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContainerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContainerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContainerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContainerType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContainerType'):
        super(ContainerType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                    name_='ContainerType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContainerType',
                       fromsubclass_=False, pretty_print=True):
        super(ContainerType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                  pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultRateInStream is not None:
            namespaceprefix_ = self.DefaultRateInStream_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DefaultRateInStream_nsprefix_) else ''
            self.DefaultRateInStream.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='DefaultRateInStream', pretty_print=pretty_print)
        if self.RateInStreamSet is not None:
            namespaceprefix_ = self.RateInStreamSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.RateInStreamSet_nsprefix_) else ''
            self.RateInStreamSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RateInStreamSet',
                                        pretty_print=pretty_print)
        if self.BinaryEncoding is not None:
            namespaceprefix_ = self.BinaryEncoding_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BinaryEncoding_nsprefix_) else ''
            self.BinaryEncoding.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BinaryEncoding',
                                       pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ContainerType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DefaultRateInStream':
            class_obj_ = self.get_class_obj_(child_, RateInStreamType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DefaultRateInStream = obj_
            obj_.original_tagname_ = 'DefaultRateInStream'
        elif nodeName_ == 'RateInStreamSet':
            obj_ = RateInStreamSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RateInStreamSet = obj_
            obj_.original_tagname_ = 'RateInStreamSet'
        elif nodeName_ == 'BinaryEncoding':
            obj_ = BinaryDataEncodingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BinaryEncoding = obj_
            obj_.original_tagname_ = 'BinaryEncoding'
        super(ContainerType, self).buildChildren(child_, node, nodeName_, True)


# end class ContainerType


class ArrayParameterRefEntryType(SequenceEntryType):
    """Describe an entry that is an array parameter. Specify the dimension
    sizes if you subsetting the array (the number of dimensions shall match
    the number defined in the parameter’s type definition), otherwise the
    ones in the ParameterType are assumed. See SequenceEntryType.Only used
    for subsetting an array. The array's maximum dimension sizes are set in
    the type. When a DimensionList is not used, the array is the full size
    provided in the type."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 TimeAssociation=None, AncillaryDataSet=None, parameterRef=None, DimensionList=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArrayParameterRefEntryType, self).__init__(shortDescription, LocationInContainerInBits, RepeatEntry,
                                                         IncludeCondition, TimeAssociation, AncillaryDataSet, **kwargs_)
        self.parameterRef = _cast(None, parameterRef)
        self.parameterRef_nsprefix_ = None
        self.DimensionList = DimensionList
        self.DimensionList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArrayParameterRefEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArrayParameterRefEntryType.subclass:
            return ArrayParameterRefEntryType.subclass(*args_, **kwargs_)
        else:
            return ArrayParameterRefEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DimensionList(self):
        return self.DimensionList

    def set_DimensionList(self, DimensionList):
        self.DimensionList = DimensionList

    def get_parameterRef(self):
        return self.parameterRef

    def set_parameterRef(self, parameterRef):
        self.parameterRef = parameterRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                self.DimensionList is not None or
                super(ArrayParameterRefEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArrayParameterRefEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArrayParameterRefEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArrayParameterRefEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArrayParameterRefEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArrayParameterRefEntryType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArrayParameterRefEntryType'):
        super(ArrayParameterRefEntryType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                 name_='ArrayParameterRefEntryType')
        if self.parameterRef is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            outfile.write(' parameterRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.parameterRef), input_name='parameterRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArrayParameterRefEntryType',
                       fromsubclass_=False, pretty_print=True):
        super(ArrayParameterRefEntryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                               True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DimensionList is not None:
            namespaceprefix_ = self.DimensionList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DimensionList_nsprefix_) else ''
            self.DimensionList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DimensionList',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameterRef', node)
        if value is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            self.parameterRef = value
            self.validate_NameReferenceType(self.parameterRef)  # validate type NameReferenceType
        super(ArrayParameterRefEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DimensionList':
            obj_ = DimensionListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionList = obj_
            obj_.original_tagname_ = 'DimensionList'
        super(ArrayParameterRefEntryType, self).buildChildren(child_, node, nodeName_, True)


# end class ArrayParameterRefEntryType


class ArgumentStreamSegmentEntryType(ArgumentSequenceEntryType):
    """Identical to StreamRefEntryType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentSequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 AncillaryDataSet=None, streamRef=None, order=None, sizeInBits=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentStreamSegmentEntryType, self).__init__(shortDescription, LocationInContainerInBits, RepeatEntry,
                                                             IncludeCondition, AncillaryDataSet, **kwargs_)
        self.streamRef = _cast(None, streamRef)
        self.streamRef_nsprefix_ = None
        self.order = _cast(int, order)
        self.order_nsprefix_ = None
        self.sizeInBits = _cast(int, sizeInBits)
        self.sizeInBits_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentStreamSegmentEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentStreamSegmentEntryType.subclass:
            return ArgumentStreamSegmentEntryType.subclass(*args_, **kwargs_)
        else:
            return ArgumentStreamSegmentEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_streamRef(self):
        return self.streamRef

    def set_streamRef(self, streamRef):
        self.streamRef = streamRef

    def get_order(self):
        return self.order

    def set_order(self, order):
        self.order = order

    def get_sizeInBits(self):
        return self.sizeInBits

    def set_sizeInBits(self, sizeInBits):
        self.sizeInBits = sizeInBits

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(ArgumentStreamSegmentEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentStreamSegmentEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentStreamSegmentEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentStreamSegmentEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='ArgumentStreamSegmentEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentStreamSegmentEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentStreamSegmentEntryType'):
        super(ArgumentStreamSegmentEntryType, self).exportAttributes(outfile, level, already_processed,
                                                                     namespaceprefix_,
                                                                     name_='ArgumentStreamSegmentEntryType')
        if self.streamRef is not None and 'streamRef' not in already_processed:
            already_processed.add('streamRef')
            outfile.write(' streamRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.streamRef), input_name='streamRef')),))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order="%s"' % self.gds_format_integer(self.order, input_name='order'))
        if self.sizeInBits is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            outfile.write(' sizeInBits="%s"' % self.gds_format_integer(self.sizeInBits, input_name='sizeInBits'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ArgumentStreamSegmentEntryType', fromsubclass_=False, pretty_print=True):
        super(ArgumentStreamSegmentEntryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_,
                                                                   name_, True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('streamRef', node)
        if value is not None and 'streamRef' not in already_processed:
            already_processed.add('streamRef')
            self.streamRef = value
            self.validate_NameReferenceType(self.streamRef)  # validate type NameReferenceType
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            self.order = self.gds_parse_integer(value, node, 'order')
            self.validate_PositiveLongType(self.order)  # validate type PositiveLongType
        value = find_attr_value_('sizeInBits', node)
        if value is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            self.sizeInBits = self.gds_parse_integer(value, node, 'sizeInBits')
            self.validate_PositiveLongType(self.sizeInBits)  # validate type PositiveLongType
        super(ArgumentStreamSegmentEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ArgumentStreamSegmentEntryType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ArgumentStreamSegmentEntryType


class ArgumentParameterSegmentRefEntryType(ArgumentSequenceEntryType):
    """Identical to ParameterSegmentRefEntryType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentSequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 AncillaryDataSet=None, parameterRef=None, order=None, sizeInBits=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentParameterSegmentRefEntryType, self).__init__(shortDescription, LocationInContainerInBits,
                                                                   RepeatEntry, IncludeCondition, AncillaryDataSet,
                                                                   **kwargs_)
        self.parameterRef = _cast(None, parameterRef)
        self.parameterRef_nsprefix_ = None
        self.order = _cast(int, order)
        self.order_nsprefix_ = None
        self.sizeInBits = _cast(int, sizeInBits)
        self.sizeInBits_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentParameterSegmentRefEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentParameterSegmentRefEntryType.subclass:
            return ArgumentParameterSegmentRefEntryType.subclass(*args_, **kwargs_)
        else:
            return ArgumentParameterSegmentRefEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_parameterRef(self):
        return self.parameterRef

    def set_parameterRef(self, parameterRef):
        self.parameterRef = parameterRef

    def get_order(self):
        return self.order

    def set_order(self, order):
        self.order = order

    def get_sizeInBits(self):
        return self.sizeInBits

    def set_sizeInBits(self, sizeInBits):
        self.sizeInBits = sizeInBits

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(ArgumentParameterSegmentRefEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='',
               name_='ArgumentParameterSegmentRefEntryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentParameterSegmentRefEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentParameterSegmentRefEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='ArgumentParameterSegmentRefEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentParameterSegmentRefEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentParameterSegmentRefEntryType'):
        super(ArgumentParameterSegmentRefEntryType, self).exportAttributes(outfile, level, already_processed,
                                                                           namespaceprefix_,
                                                                           name_='ArgumentParameterSegmentRefEntryType')
        if self.parameterRef is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            outfile.write(' parameterRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.parameterRef), input_name='parameterRef')),))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order="%s"' % self.gds_format_integer(self.order, input_name='order'))
        if self.sizeInBits is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            outfile.write(' sizeInBits="%s"' % self.gds_format_integer(self.sizeInBits, input_name='sizeInBits'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ArgumentParameterSegmentRefEntryType', fromsubclass_=False, pretty_print=True):
        super(ArgumentParameterSegmentRefEntryType, self).exportChildren(outfile, level, namespaceprefix_,
                                                                         namespacedef_, name_, True,
                                                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameterRef', node)
        if value is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            self.parameterRef = value
            self.validate_NameReferenceType(self.parameterRef)  # validate type NameReferenceType
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            self.order = self.gds_parse_integer(value, node, 'order')
            self.validate_PositiveLongType(self.order)  # validate type PositiveLongType
        value = find_attr_value_('sizeInBits', node)
        if value is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            self.sizeInBits = self.gds_parse_integer(value, node, 'sizeInBits')
            self.validate_PositiveLongType(self.sizeInBits)  # validate type PositiveLongType
        super(ArgumentParameterSegmentRefEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ArgumentParameterSegmentRefEntryType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ArgumentParameterSegmentRefEntryType


class ArgumentParameterRefEntryType(ArgumentSequenceEntryType):
    """Identical to ParameterRefEntryType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentSequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 AncillaryDataSet=None, parameterRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentParameterRefEntryType, self).__init__(shortDescription, LocationInContainerInBits, RepeatEntry,
                                                            IncludeCondition, AncillaryDataSet, **kwargs_)
        self.parameterRef = _cast(None, parameterRef)
        self.parameterRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentParameterRefEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentParameterRefEntryType.subclass:
            return ArgumentParameterRefEntryType.subclass(*args_, **kwargs_)
        else:
            return ArgumentParameterRefEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_parameterRef(self):
        return self.parameterRef

    def set_parameterRef(self, parameterRef):
        self.parameterRef = parameterRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                super(ArgumentParameterRefEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentParameterRefEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentParameterRefEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentParameterRefEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='ArgumentParameterRefEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentParameterRefEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentParameterRefEntryType'):
        super(ArgumentParameterRefEntryType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                    name_='ArgumentParameterRefEntryType')
        if self.parameterRef is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            outfile.write(' parameterRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.parameterRef), input_name='parameterRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ArgumentParameterRefEntryType', fromsubclass_=False, pretty_print=True):
        super(ArgumentParameterRefEntryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_,
                                                                  name_, True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameterRef', node)
        if value is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            self.parameterRef = value
            self.validate_NameReferenceType(self.parameterRef)  # validate type NameReferenceType
        super(ArgumentParameterRefEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ArgumentParameterRefEntryType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ArgumentParameterRefEntryType


class ArgumentIndirectParameterRefEntryType(ArgumentSequenceEntryType):
    """Identical to IndirectParameterRefEntryType but supports argument
    instance references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentSequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 AncillaryDataSet=None, aliasNameSpace=None, ParameterInstance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentIndirectParameterRefEntryType, self).__init__(shortDescription, LocationInContainerInBits,
                                                                    RepeatEntry, IncludeCondition, AncillaryDataSet,
                                                                    **kwargs_)
        self.aliasNameSpace = _cast(None, aliasNameSpace)
        self.aliasNameSpace_nsprefix_ = None
        self.ParameterInstance = ParameterInstance
        self.ParameterInstance_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentIndirectParameterRefEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentIndirectParameterRefEntryType.subclass:
            return ArgumentIndirectParameterRefEntryType.subclass(*args_, **kwargs_)
        else:
            return ArgumentIndirectParameterRefEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ParameterInstance(self):
        return self.ParameterInstance

    def set_ParameterInstance(self, ParameterInstance):
        self.ParameterInstance = ParameterInstance

    def get_aliasNameSpace(self):
        return self.aliasNameSpace

    def set_aliasNameSpace(self, aliasNameSpace):
        self.aliasNameSpace = aliasNameSpace

    def hasContent_(self):
        if (
                self.ParameterInstance is not None or
                super(ArgumentIndirectParameterRefEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='',
               name_='ArgumentIndirectParameterRefEntryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentIndirectParameterRefEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentIndirectParameterRefEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='ArgumentIndirectParameterRefEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentIndirectParameterRefEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentIndirectParameterRefEntryType'):
        super(ArgumentIndirectParameterRefEntryType, self).exportAttributes(outfile, level, already_processed,
                                                                            namespaceprefix_,
                                                                            name_='ArgumentIndirectParameterRefEntryType')
        if self.aliasNameSpace is not None and 'aliasNameSpace' not in already_processed:
            already_processed.add('aliasNameSpace')
            outfile.write(' aliasNameSpace=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.aliasNameSpace), input_name='aliasNameSpace')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ArgumentIndirectParameterRefEntryType', fromsubclass_=False, pretty_print=True):
        super(ArgumentIndirectParameterRefEntryType, self).exportChildren(outfile, level, namespaceprefix_,
                                                                          namespacedef_, name_, True,
                                                                          pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ParameterInstance is not None:
            namespaceprefix_ = self.ParameterInstance_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ParameterInstance_nsprefix_) else ''
            self.ParameterInstance.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ParameterInstance',
                                          pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aliasNameSpace', node)
        if value is not None and 'aliasNameSpace' not in already_processed:
            already_processed.add('aliasNameSpace')
            self.aliasNameSpace = value
        super(ArgumentIndirectParameterRefEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ParameterInstance':
            class_obj_ = self.get_class_obj_(child_, ParameterInstanceRefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterInstance = obj_
            obj_.original_tagname_ = 'ParameterInstance'
        super(ArgumentIndirectParameterRefEntryType, self).buildChildren(child_, node, nodeName_, True)


# end class ArgumentIndirectParameterRefEntryType


class ArgumentFixedValueEntryType(ArgumentSequenceEntryType):
    """Identical to FixedValueEntryType but supports argument instance
    references.An optional name for the fixed/constant field in the
    sequence.The fixed/constant value that should be encoded into the
    sequence. This value provided should have sufficient bit length to
    accomodate the size in bits. If the value is larger, the most
    significant unnecessary bits are dropped. The value provided should be
    in network byte order for encoding.The number of bits that this
    fixed/constant value should occupy in the sequence."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentSequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 AncillaryDataSet=None, name=None, binaryValue=None, sizeInBits=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentFixedValueEntryType, self).__init__(shortDescription, LocationInContainerInBits, RepeatEntry,
                                                          IncludeCondition, AncillaryDataSet, **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.binaryValue = _cast(None, binaryValue)
        self.binaryValue_nsprefix_ = None
        self.sizeInBits = _cast(int, sizeInBits)
        self.sizeInBits_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentFixedValueEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentFixedValueEntryType.subclass:
            return ArgumentFixedValueEntryType.subclass(*args_, **kwargs_)
        else:
            return ArgumentFixedValueEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_name(self):
        return self.name

    def set_name(self, name):
        self.name = name

    def get_binaryValue(self):
        return self.binaryValue

    def set_binaryValue(self, binaryValue):
        self.binaryValue = binaryValue

    def get_sizeInBits(self):
        return self.sizeInBits

    def set_sizeInBits(self, sizeInBits):
        self.sizeInBits = sizeInBits

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(ArgumentFixedValueEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentFixedValueEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentFixedValueEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentFixedValueEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentFixedValueEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentFixedValueEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentFixedValueEntryType'):
        super(ArgumentFixedValueEntryType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                  name_='ArgumentFixedValueEntryType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(
                ' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')),))
        if self.binaryValue is not None and 'binaryValue' not in already_processed:
            already_processed.add('binaryValue')
            outfile.write(' binaryValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.binaryValue), input_name='binaryValue')),))
        if self.sizeInBits is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            outfile.write(' sizeInBits="%s"' % self.gds_format_integer(self.sizeInBits, input_name='sizeInBits'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentFixedValueEntryType',
                       fromsubclass_=False, pretty_print=True):
        super(ArgumentFixedValueEntryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                                True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('binaryValue', node)
        if value is not None and 'binaryValue' not in already_processed:
            already_processed.add('binaryValue')
            self.binaryValue = value
        value = find_attr_value_('sizeInBits', node)
        if value is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            self.sizeInBits = self.gds_parse_integer(value, node, 'sizeInBits')
            self.validate_PositiveLongType(self.sizeInBits)  # validate type PositiveLongType
        super(ArgumentFixedValueEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ArgumentFixedValueEntryType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ArgumentFixedValueEntryType


class ArgumentContainerSegmentRefEntryType(ArgumentSequenceEntryType):
    """Identical to ContainerSegmentRefEntryType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentSequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 AncillaryDataSet=None, containerRef=None, order=None, sizeInBits=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentContainerSegmentRefEntryType, self).__init__(shortDescription, LocationInContainerInBits,
                                                                   RepeatEntry, IncludeCondition, AncillaryDataSet,
                                                                   **kwargs_)
        self.containerRef = _cast(None, containerRef)
        self.containerRef_nsprefix_ = None
        self.order = _cast(int, order)
        self.order_nsprefix_ = None
        self.sizeInBits = _cast(int, sizeInBits)
        self.sizeInBits_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentContainerSegmentRefEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentContainerSegmentRefEntryType.subclass:
            return ArgumentContainerSegmentRefEntryType.subclass(*args_, **kwargs_)
        else:
            return ArgumentContainerSegmentRefEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_containerRef(self):
        return self.containerRef

    def set_containerRef(self, containerRef):
        self.containerRef = containerRef

    def get_order(self):
        return self.order

    def set_order(self, order):
        self.order = order

    def get_sizeInBits(self):
        return self.sizeInBits

    def set_sizeInBits(self, sizeInBits):
        self.sizeInBits = sizeInBits

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(ArgumentContainerSegmentRefEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='',
               name_='ArgumentContainerSegmentRefEntryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentContainerSegmentRefEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentContainerSegmentRefEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='ArgumentContainerSegmentRefEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentContainerSegmentRefEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentContainerSegmentRefEntryType'):
        super(ArgumentContainerSegmentRefEntryType, self).exportAttributes(outfile, level, already_processed,
                                                                           namespaceprefix_,
                                                                           name_='ArgumentContainerSegmentRefEntryType')
        if self.containerRef is not None and 'containerRef' not in already_processed:
            already_processed.add('containerRef')
            outfile.write(' containerRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.containerRef), input_name='containerRef')),))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order="%s"' % self.gds_format_integer(self.order, input_name='order'))
        if self.sizeInBits is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            outfile.write(' sizeInBits="%s"' % self.gds_format_integer(self.sizeInBits, input_name='sizeInBits'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ArgumentContainerSegmentRefEntryType', fromsubclass_=False, pretty_print=True):
        super(ArgumentContainerSegmentRefEntryType, self).exportChildren(outfile, level, namespaceprefix_,
                                                                         namespacedef_, name_, True,
                                                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('containerRef', node)
        if value is not None and 'containerRef' not in already_processed:
            already_processed.add('containerRef')
            self.containerRef = value
            self.validate_NameReferenceType(self.containerRef)  # validate type NameReferenceType
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            self.order = self.gds_parse_integer(value, node, 'order')
            self.validate_PositiveLongType(self.order)  # validate type PositiveLongType
        value = find_attr_value_('sizeInBits', node)
        if value is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            self.sizeInBits = self.gds_parse_integer(value, node, 'sizeInBits')
            self.validate_PositiveLongType(self.sizeInBits)  # validate type PositiveLongType
        super(ArgumentContainerSegmentRefEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ArgumentContainerSegmentRefEntryType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ArgumentContainerSegmentRefEntryType


class ArgumentContainerRefEntryType(ArgumentSequenceEntryType):
    """Identical to ContainerRefEntryType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentSequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 AncillaryDataSet=None, containerRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentContainerRefEntryType, self).__init__(shortDescription, LocationInContainerInBits, RepeatEntry,
                                                            IncludeCondition, AncillaryDataSet, **kwargs_)
        self.containerRef = _cast(None, containerRef)
        self.containerRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentContainerRefEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentContainerRefEntryType.subclass:
            return ArgumentContainerRefEntryType.subclass(*args_, **kwargs_)
        else:
            return ArgumentContainerRefEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_containerRef(self):
        return self.containerRef

    def set_containerRef(self, containerRef):
        self.containerRef = containerRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                super(ArgumentContainerRefEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentContainerRefEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentContainerRefEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentContainerRefEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='ArgumentContainerRefEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentContainerRefEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentContainerRefEntryType'):
        super(ArgumentContainerRefEntryType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                    name_='ArgumentContainerRefEntryType')
        if self.containerRef is not None and 'containerRef' not in already_processed:
            already_processed.add('containerRef')
            outfile.write(' containerRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.containerRef), input_name='containerRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ArgumentContainerRefEntryType', fromsubclass_=False, pretty_print=True):
        super(ArgumentContainerRefEntryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_,
                                                                  name_, True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('containerRef', node)
        if value is not None and 'containerRef' not in already_processed:
            already_processed.add('containerRef')
            self.containerRef = value
            self.validate_NameReferenceType(self.containerRef)  # validate type NameReferenceType
        super(ArgumentContainerRefEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ArgumentContainerRefEntryType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ArgumentContainerRefEntryType


class ArgumentArrayParameterRefEntryType(ArgumentSequenceEntryType):
    """Identical to ArrayParameterRefEntryType but supports argument instance
    references.Only used for subsetting an array. The array's true
    dimension sizes are set in the Type."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentSequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 AncillaryDataSet=None, parameterRef=None, lastEntryForThisArrayInstance=False, DimensionList=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentArrayParameterRefEntryType, self).__init__(shortDescription, LocationInContainerInBits,
                                                                 RepeatEntry, IncludeCondition, AncillaryDataSet,
                                                                 **kwargs_)
        self.parameterRef = _cast(None, parameterRef)
        self.parameterRef_nsprefix_ = None
        self.lastEntryForThisArrayInstance = _cast(bool, lastEntryForThisArrayInstance)
        self.lastEntryForThisArrayInstance_nsprefix_ = None
        self.DimensionList = DimensionList
        self.DimensionList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentArrayParameterRefEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentArrayParameterRefEntryType.subclass:
            return ArgumentArrayParameterRefEntryType.subclass(*args_, **kwargs_)
        else:
            return ArgumentArrayParameterRefEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DimensionList(self):
        return self.DimensionList

    def set_DimensionList(self, DimensionList):
        self.DimensionList = DimensionList

    def get_parameterRef(self):
        return self.parameterRef

    def set_parameterRef(self, parameterRef):
        self.parameterRef = parameterRef

    def get_lastEntryForThisArrayInstance(self):
        return self.lastEntryForThisArrayInstance

    def set_lastEntryForThisArrayInstance(self, lastEntryForThisArrayInstance):
        self.lastEntryForThisArrayInstance = lastEntryForThisArrayInstance

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                self.DimensionList is not None or
                super(ArgumentArrayParameterRefEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentArrayParameterRefEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentArrayParameterRefEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentArrayParameterRefEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='ArgumentArrayParameterRefEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentArrayParameterRefEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentArrayParameterRefEntryType'):
        super(ArgumentArrayParameterRefEntryType, self).exportAttributes(outfile, level, already_processed,
                                                                         namespaceprefix_,
                                                                         name_='ArgumentArrayParameterRefEntryType')
        if self.parameterRef is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            outfile.write(' parameterRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.parameterRef), input_name='parameterRef')),))
        if self.lastEntryForThisArrayInstance and 'lastEntryForThisArrayInstance' not in already_processed:
            already_processed.add('lastEntryForThisArrayInstance')
            outfile.write(
                ' lastEntryForThisArrayInstance="%s"' % self.gds_format_boolean(self.lastEntryForThisArrayInstance,
                                                                                input_name='lastEntryForThisArrayInstance'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ArgumentArrayParameterRefEntryType', fromsubclass_=False, pretty_print=True):
        super(ArgumentArrayParameterRefEntryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_,
                                                                       name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DimensionList is not None:
            namespaceprefix_ = self.DimensionList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DimensionList_nsprefix_) else ''
            self.DimensionList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DimensionList',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameterRef', node)
        if value is not None and 'parameterRef' not in already_processed:
            already_processed.add('parameterRef')
            self.parameterRef = value
            self.validate_NameReferenceType(self.parameterRef)  # validate type NameReferenceType
        value = find_attr_value_('lastEntryForThisArrayInstance', node)
        if value is not None and 'lastEntryForThisArrayInstance' not in already_processed:
            already_processed.add('lastEntryForThisArrayInstance')
            if value in ('true', '1'):
                self.lastEntryForThisArrayInstance = True
            elif value in ('false', '0'):
                self.lastEntryForThisArrayInstance = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(ArgumentArrayParameterRefEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DimensionList':
            obj_ = DimensionListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionList = obj_
            obj_.original_tagname_ = 'DimensionList'
        super(ArgumentArrayParameterRefEntryType, self).buildChildren(child_, node, nodeName_, True)


# end class ArgumentArrayParameterRefEntryType


class ArgumentArrayArgumentRefEntryType(ArgumentSequenceEntryType):
    """Identical to ArrayParameterRefEntryType but supports argument instance
    references.Only used for subsetting an array. The array's true
    dimension sizes are set in the Type."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentSequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 AncillaryDataSet=None, argumentRef=None, lastEntryForThisArrayInstance=False, DimensionList=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentArrayArgumentRefEntryType, self).__init__(shortDescription, LocationInContainerInBits,
                                                                RepeatEntry, IncludeCondition, AncillaryDataSet,
                                                                **kwargs_)
        self.argumentRef = _cast(None, argumentRef)
        self.argumentRef_nsprefix_ = None
        self.lastEntryForThisArrayInstance = _cast(bool, lastEntryForThisArrayInstance)
        self.lastEntryForThisArrayInstance_nsprefix_ = None
        self.DimensionList = DimensionList
        self.DimensionList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentArrayArgumentRefEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentArrayArgumentRefEntryType.subclass:
            return ArgumentArrayArgumentRefEntryType.subclass(*args_, **kwargs_)
        else:
            return ArgumentArrayArgumentRefEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DimensionList(self):
        return self.DimensionList

    def set_DimensionList(self, DimensionList):
        self.DimensionList = DimensionList

    def get_argumentRef(self):
        return self.argumentRef

    def set_argumentRef(self, argumentRef):
        self.argumentRef = argumentRef

    def get_lastEntryForThisArrayInstance(self):
        return self.lastEntryForThisArrayInstance

    def set_lastEntryForThisArrayInstance(self, lastEntryForThisArrayInstance):
        self.lastEntryForThisArrayInstance = lastEntryForThisArrayInstance

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                self.DimensionList is not None or
                super(ArgumentArrayArgumentRefEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentArrayArgumentRefEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentArrayArgumentRefEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentArrayArgumentRefEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='ArgumentArrayArgumentRefEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentArrayArgumentRefEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentArrayArgumentRefEntryType'):
        super(ArgumentArrayArgumentRefEntryType, self).exportAttributes(outfile, level, already_processed,
                                                                        namespaceprefix_,
                                                                        name_='ArgumentArrayArgumentRefEntryType')
        if self.argumentRef is not None and 'argumentRef' not in already_processed:
            already_processed.add('argumentRef')
            outfile.write(' argumentRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.argumentRef), input_name='argumentRef')),))
        if self.lastEntryForThisArrayInstance and 'lastEntryForThisArrayInstance' not in already_processed:
            already_processed.add('lastEntryForThisArrayInstance')
            outfile.write(
                ' lastEntryForThisArrayInstance="%s"' % self.gds_format_boolean(self.lastEntryForThisArrayInstance,
                                                                                input_name='lastEntryForThisArrayInstance'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ArgumentArrayArgumentRefEntryType', fromsubclass_=False, pretty_print=True):
        super(ArgumentArrayArgumentRefEntryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_,
                                                                      name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DimensionList is not None:
            namespaceprefix_ = self.DimensionList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DimensionList_nsprefix_) else ''
            self.DimensionList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DimensionList',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('argumentRef', node)
        if value is not None and 'argumentRef' not in already_processed:
            already_processed.add('argumentRef')
            self.argumentRef = value
            self.validate_NameReferenceType(self.argumentRef)  # validate type NameReferenceType
        value = find_attr_value_('lastEntryForThisArrayInstance', node)
        if value is not None and 'lastEntryForThisArrayInstance' not in already_processed:
            already_processed.add('lastEntryForThisArrayInstance')
            if value in ('true', '1'):
                self.lastEntryForThisArrayInstance = True
            elif value in ('false', '0'):
                self.lastEntryForThisArrayInstance = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(ArgumentArrayArgumentRefEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DimensionList':
            obj_ = ArgumentDimensionListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DimensionList = obj_
            obj_.original_tagname_ = 'DimensionList'
        super(ArgumentArrayArgumentRefEntryType, self).buildChildren(child_, node, nodeName_, True)


# end class ArgumentArrayArgumentRefEntryType


class ArgumentArgumentRefEntryType(ArgumentSequenceEntryType):
    """Identical to ArgumentRefEntryType but supports argument instance
    references."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentSequenceEntryType

    def __init__(self, shortDescription=None, LocationInContainerInBits=None, RepeatEntry=None, IncludeCondition=None,
                 AncillaryDataSet=None, argumentRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentArgumentRefEntryType, self).__init__(shortDescription, LocationInContainerInBits, RepeatEntry,
                                                           IncludeCondition, AncillaryDataSet, **kwargs_)
        self.argumentRef = _cast(None, argumentRef)
        self.argumentRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentArgumentRefEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentArgumentRefEntryType.subclass:
            return ArgumentArgumentRefEntryType.subclass(*args_, **kwargs_)
        else:
            return ArgumentArgumentRefEntryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_argumentRef(self):
        return self.argumentRef

    def set_argumentRef(self, argumentRef):
        self.argumentRef = argumentRef

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                super(ArgumentArgumentRefEntryType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentArgumentRefEntryType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentArgumentRefEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentArgumentRefEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentArgumentRefEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentArgumentRefEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentArgumentRefEntryType'):
        super(ArgumentArgumentRefEntryType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                   name_='ArgumentArgumentRefEntryType')
        if self.argumentRef is not None and 'argumentRef' not in already_processed:
            already_processed.add('argumentRef')
            outfile.write(' argumentRef=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.argumentRef), input_name='argumentRef')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ArgumentArgumentRefEntryType', fromsubclass_=False, pretty_print=True):
        super(ArgumentArgumentRefEntryType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                                 True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('argumentRef', node)
        if value is not None and 'argumentRef' not in already_processed:
            already_processed.add('argumentRef')
            self.argumentRef = value
            self.validate_NameReferenceType(self.argumentRef)  # validate type NameReferenceType
        super(ArgumentArgumentRefEntryType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ArgumentArgumentRefEntryType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ArgumentArgumentRefEntryType


class SpaceSystemType(NameDescriptionType):
    """SpaceSystem is a collection of SpaceSystem(s) including space assets,
    ground assets, multi-satellite systems and sub-systems. A SpaceSystem
    is the root element for the set of data necessary to monitor and
    command an arbitrary space device - this includes the binary
    decomposition the data streams going into and out of a device.Optional
    descriptive attribute for document owner convenience."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameDescriptionType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 operationalStatus=None, base=None, Header=None, TelemetryMetaData=None, CommandMetaData=None,
                 ServiceSet=None, SpaceSystem=None, gds_collector_=None, **kwargs_):
        self.parent = None
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SpaceSystemType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                              **kwargs_)
        self.operationalStatus = _cast(None, operationalStatus)
        self.operationalStatus_nsprefix_ = None
        self.base = _cast(None, base)
        self.base_nsprefix_ = None
        self.Header = Header
        self.Header_nsprefix_ = None
        self.TelemetryMetaData = TelemetryMetaData
        self.TelemetryMetaData_nsprefix_ = None
        self.CommandMetaData = CommandMetaData
        self.CommandMetaData_nsprefix_ = None
        self.ServiceSet = ServiceSet
        self.ServiceSet_nsprefix_ = None
        if SpaceSystem is None:
            self.SpaceSystem = []
        else:
            self.SpaceSystem = SpaceSystem
        self.SpaceSystem_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpaceSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpaceSystemType.subclass:
            return SpaceSystemType.subclass(*args_, **kwargs_)
        else:
            return SpaceSystemType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Header(self):
        return self.Header

    def set_Header(self, Header):
        self.Header = Header

    def get_TelemetryMetaData(self)-> 'TelemetryMetaDataType':
        return self.TelemetryMetaData

    def set_TelemetryMetaData(self, TelemetryMetaData):
        self.TelemetryMetaData = TelemetryMetaData

    def get_CommandMetaData(self) -> 'CommandMetaDataType':
        return self.CommandMetaData

    def set_CommandMetaData(self, CommandMetaData):
        self.CommandMetaData = CommandMetaData

    def get_ServiceSet(self):
        return self.ServiceSet

    def set_ServiceSet(self, ServiceSet):
        self.ServiceSet = ServiceSet

    def get_SpaceSystem(self):
        return self.SpaceSystem

    def set_SpaceSystem(self, SpaceSystem):
        self.SpaceSystem = SpaceSystem

    def add_SpaceSystem(self, value):
        self.SpaceSystem.append(value)
        value.set_parent(self)

    def insert_SpaceSystem_at(self, index, value):
        self.SpaceSystem.insert(index, value)

    def replace_SpaceSystem_at(self, index, value):
        self.SpaceSystem[index] = value

    def get_operationalStatus(self):
        return self.operationalStatus

    def set_operationalStatus(self, operationalStatus):
        self.operationalStatus = operationalStatus

    def get_base(self):
        return self.base

    def set_base(self, base):
        self.base = base

    def hasContent_(self):
        if (
                self.Header is not None or
                self.TelemetryMetaData is not None or
                self.CommandMetaData is not None or
                self.ServiceSet is not None or
                self.SpaceSystem or
                super(SpaceSystemType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpaceSystem', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpaceSystemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SpaceSystemType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpaceSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpaceSystemType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpaceSystemType'):
        super(SpaceSystemType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                      name_='SpaceSystemType')
        if self.operationalStatus is not None and 'operationalStatus' not in already_processed:
            already_processed.add('operationalStatus')
            outfile.write(' operationalStatus=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.operationalStatus), input_name='operationalStatus')),))
        if self.base is not None and 'base' not in already_processed:
            already_processed.add('base')
            outfile.write(' xml:base=%s' % (quote_attrib(self.base),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpaceSystemType',
                       fromsubclass_=False, pretty_print=True):
        super(SpaceSystemType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                    pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Header is not None:
            namespaceprefix_ = self.Header_nsprefix_ + ':' if (UseCapturedNS_ and self.Header_nsprefix_) else ''
            self.Header.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Header',
                               pretty_print=pretty_print)
        if self.TelemetryMetaData is not None:
            namespaceprefix_ = self.TelemetryMetaData_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TelemetryMetaData_nsprefix_) else ''
            self.TelemetryMetaData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TelemetryMetaData',
                                          pretty_print=pretty_print)
        if self.CommandMetaData is not None:
            namespaceprefix_ = self.CommandMetaData_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CommandMetaData_nsprefix_) else ''
            self.CommandMetaData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CommandMetaData',
                                        pretty_print=pretty_print)
        if self.ServiceSet is not None:
            namespaceprefix_ = self.ServiceSet_nsprefix_ + ':' if (UseCapturedNS_ and self.ServiceSet_nsprefix_) else ''
            self.ServiceSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ServiceSet',
                                   pretty_print=pretty_print)
        for SpaceSystem_ in self.SpaceSystem:
            namespaceprefix_ = self.SpaceSystem_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SpaceSystem_nsprefix_) else ''
            SpaceSystem_.export(outfile, level, namespaceprefix_='xtce:', namespacedef_='', name_='SpaceSystem',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operationalStatus', node)
        if value is not None and 'operationalStatus' not in already_processed:
            already_processed.add('operationalStatus')
            self.operationalStatus = value
            self.operationalStatus = ' '.join(self.operationalStatus.split())
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.add('base')
            self.base = value
        super(SpaceSystemType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Header':
            obj_ = HeaderType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Header = obj_
            obj_.original_tagname_ = 'Header'
        elif nodeName_ == 'TelemetryMetaData':
            obj_ = TelemetryMetaDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TelemetryMetaData = obj_
            obj_.original_tagname_ = 'TelemetryMetaData'
        elif nodeName_ == 'CommandMetaData':
            obj_ = CommandMetaDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CommandMetaData = obj_
            obj_.original_tagname_ = 'CommandMetaData'
        elif nodeName_ == 'ServiceSet':
            obj_ = ServiceSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ServiceSet = obj_
            obj_.original_tagname_ = 'ServiceSet'
        elif nodeName_ == 'SpaceSystem':
            obj_ = SpaceSystemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SpaceSystem.append(obj_)
            obj_.original_tagname_ = 'SpaceSystem'
        super(SpaceSystemType, self).buildChildren(child_, node, nodeName_, True)

    def set_parent(self, p: 'SpaceSystemType'):
        self.parent = p
    
    def get_parent(self):
        return self.parent


# end class SpaceSystemType


class ComparisonType(ParameterInstanceRefType):
    """A simple ParameterInstanceRef to value comparison. The string supplied
    in the value attribute needs to be converted to a type matching the
    Parameter being compared to. Numerical values are assumed to be base 10
    unless proceeded by 0x (hexadecimal), 0o (octal), or 0b (binary). The
    value is truncated to use the least significant bits that match the bit
    size of the Parameter being compared to.Operator to use for the
    comparison with the common equality operator as the default.Specify
    value as a string compliant with the XML schema (xs) type specified for
    each XTCE type: integer=xs:integer; float=xs:double; string=xs:string;
    boolean=xs:boolean; binary=xs:hexBinary; enum=xs:string from
    EnumerationList; relative time= xs:duration; absolute time=xs:dateTime.
    Supplied value must be within the ValidRange specified for the type."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ParameterInstanceRefType

    def __init__(self, parameterRef=None, instance=0, useCalibratedValue=True, comparisonOperator='==', value=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ComparisonType, self).__init__(parameterRef, instance, useCalibratedValue, **kwargs_)
        self.comparisonOperator = _cast(None, comparisonOperator)
        self.comparisonOperator_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComparisonType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComparisonType.subclass:
            return ComparisonType.subclass(*args_, **kwargs_)
        else:
            return ComparisonType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_comparisonOperator(self):
        return self.comparisonOperator

    def set_comparisonOperator(self, comparisonOperator):
        self.comparisonOperator = comparisonOperator

    def get_value(self):
        return self.value

    def set_value(self, value):
        self.value = value

    def validate_ComparisonOperatorsType(self, value):
        # Validate type xtce:ComparisonOperatorsType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['==', '!=', '<', '<=', '>', '>=']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ComparisonOperatorsType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(ComparisonType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ComparisonType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ComparisonType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ComparisonType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ComparisonType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ComparisonType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ComparisonType'):
        super(ComparisonType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                     name_='ComparisonType')
        if self.comparisonOperator != "==" and 'comparisonOperator' not in already_processed:
            already_processed.add('comparisonOperator')
            outfile.write(' comparisonOperator=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.comparisonOperator), input_name='comparisonOperator')),))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(
                ' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ComparisonType',
                       fromsubclass_=False, pretty_print=True):
        super(ComparisonType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                   pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('comparisonOperator', node)
        if value is not None and 'comparisonOperator' not in already_processed:
            already_processed.add('comparisonOperator')
            self.comparisonOperator = value
            self.validate_ComparisonOperatorsType(self.comparisonOperator)  # validate type ComparisonOperatorsType
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        super(ComparisonType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ComparisonType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ComparisonType


class StringDataType(BaseDataType):
    """Defines a base schema type for StringParameterType and
    StringArgumentType, adding initial value, restriction pattern,
    character width, and size range in characters. The initial value if set
    is the initial value of all instances of the child types. The
    restriction pattern is a regular expression enforcing the string value
    to this pattern. The character width is on the local data type side.
    And the size range in character restricts the character set. For
    telemetered values, if the restriction pattern of size range in
    character is not met, the item is invalid. See BaseDataType,
    StringParameterType, StringArgumentType, CharacterWidthType and
    IntegerRangeType.Initial values for string types, may include C
    language style (\n, \t, \", \\, etc.) escape sequences.restriction
    pattern is a regular expression"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, restrictionPattern=None, characterWidth=None,
                 SizeRangeInCharacters=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(StringDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                             baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                             IntegerDataEncoding, StringDataEncoding, extensiontype_, **kwargs_)
        self.initialValue = _cast(None, initialValue)
        self.initialValue_nsprefix_ = None
        self.restrictionPattern = _cast(None, restrictionPattern)
        self.restrictionPattern_nsprefix_ = None
        self.characterWidth = _cast(int, characterWidth)
        self.characterWidth_nsprefix_ = None
        self.SizeRangeInCharacters = SizeRangeInCharacters
        self.SizeRangeInCharacters_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringDataType.subclass:
            return StringDataType.subclass(*args_, **kwargs_)
        else:
            return StringDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SizeRangeInCharacters(self):
        return self.SizeRangeInCharacters

    def set_SizeRangeInCharacters(self, SizeRangeInCharacters):
        self.SizeRangeInCharacters = SizeRangeInCharacters

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_restrictionPattern(self):
        return self.restrictionPattern

    def set_restrictionPattern(self, restrictionPattern):
        self.restrictionPattern = restrictionPattern

    def get_characterWidth(self):
        return self.characterWidth

    def set_characterWidth(self, characterWidth):
        self.characterWidth = characterWidth

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_CharacterWidthType(self, value):
        # Validate type xtce:CharacterWidthType, a restriction on integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = [8, 16]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CharacterWidthType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.SizeRangeInCharacters is not None or
                super(StringDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StringDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StringDataType'):
        super(StringDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                     name_='StringDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.initialValue), input_name='initialValue')),))
        if self.restrictionPattern is not None and 'restrictionPattern' not in already_processed:
            already_processed.add('restrictionPattern')
            outfile.write(' restrictionPattern=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.restrictionPattern), input_name='restrictionPattern')),))
        if self.characterWidth is not None and 'characterWidth' not in already_processed:
            already_processed.add('characterWidth')
            outfile.write(
                ' characterWidth="%s"' % self.gds_format_integer(self.characterWidth, input_name='characterWidth'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringDataType',
                       fromsubclass_=False, pretty_print=True):
        super(StringDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                   pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SizeRangeInCharacters is not None:
            namespaceprefix_ = self.SizeRangeInCharacters_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SizeRangeInCharacters_nsprefix_) else ''
            self.SizeRangeInCharacters.export(outfile, level, namespaceprefix_, namespacedef_='',
                                              name_='SizeRangeInCharacters', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            self.initialValue = value
        value = find_attr_value_('restrictionPattern', node)
        if value is not None and 'restrictionPattern' not in already_processed:
            already_processed.add('restrictionPattern')
            self.restrictionPattern = value
        value = find_attr_value_('characterWidth', node)
        if value is not None and 'characterWidth' not in already_processed:
            already_processed.add('characterWidth')
            self.characterWidth = self.gds_parse_integer(value, node, 'characterWidth')
            self.validate_CharacterWidthType(self.characterWidth)  # validate type CharacterWidthType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(StringDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SizeRangeInCharacters':
            class_obj_ = self.get_class_obj_(child_, IntegerRangeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SizeRangeInCharacters = obj_
            obj_.original_tagname_ = 'SizeRangeInCharacters'
        super(StringDataType, self).buildChildren(child_, node, nodeName_, True)


# end class StringDataType


class ArgumentStringDataType(ArgumentBaseDataType):
    """Identical to StringDataType but supports argument instance
    references.Initial values for string types, may include C language
    style (\n, \t, \", \\, etc.) escape sequences.restriction pattern is a
    regular expression"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentBaseDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, restrictionPattern=None, characterWidth=None,
                 SizeRangeInCharacters=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentStringDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                     name, baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                     IntegerDataEncoding, StringDataEncoding, extensiontype_, **kwargs_)
        self.initialValue = _cast(None, initialValue)
        self.initialValue_nsprefix_ = None
        self.restrictionPattern = _cast(None, restrictionPattern)
        self.restrictionPattern_nsprefix_ = None
        self.characterWidth = _cast(int, characterWidth)
        self.characterWidth_nsprefix_ = None
        self.SizeRangeInCharacters = SizeRangeInCharacters
        self.SizeRangeInCharacters_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentStringDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentStringDataType.subclass:
            return ArgumentStringDataType.subclass(*args_, **kwargs_)
        else:
            return ArgumentStringDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SizeRangeInCharacters(self):
        return self.SizeRangeInCharacters

    def set_SizeRangeInCharacters(self, SizeRangeInCharacters):
        self.SizeRangeInCharacters = SizeRangeInCharacters

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_restrictionPattern(self):
        return self.restrictionPattern

    def set_restrictionPattern(self, restrictionPattern):
        self.restrictionPattern = restrictionPattern

    def get_characterWidth(self):
        return self.characterWidth

    def set_characterWidth(self, characterWidth):
        self.characterWidth = characterWidth

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_CharacterWidthType(self, value):
        # Validate type xtce:CharacterWidthType, a restriction on integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = [8, 16]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CharacterWidthType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.SizeRangeInCharacters is not None or
                super(ArgumentStringDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentStringDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentStringDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentStringDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentStringDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentStringDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArgumentStringDataType'):
        super(ArgumentStringDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                             name_='ArgumentStringDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.initialValue), input_name='initialValue')),))
        if self.restrictionPattern is not None and 'restrictionPattern' not in already_processed:
            already_processed.add('restrictionPattern')
            outfile.write(' restrictionPattern=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.restrictionPattern), input_name='restrictionPattern')),))
        if self.characterWidth is not None and 'characterWidth' not in already_processed:
            already_processed.add('characterWidth')
            outfile.write(
                ' characterWidth="%s"' % self.gds_format_integer(self.characterWidth, input_name='characterWidth'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentStringDataType',
                       fromsubclass_=False, pretty_print=True):
        super(ArgumentStringDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                           pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SizeRangeInCharacters is not None:
            namespaceprefix_ = self.SizeRangeInCharacters_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SizeRangeInCharacters_nsprefix_) else ''
            self.SizeRangeInCharacters.export(outfile, level, namespaceprefix_, namespacedef_='',
                                              name_='SizeRangeInCharacters', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            self.initialValue = value
        value = find_attr_value_('restrictionPattern', node)
        if value is not None and 'restrictionPattern' not in already_processed:
            already_processed.add('restrictionPattern')
            self.restrictionPattern = value
        value = find_attr_value_('characterWidth', node)
        if value is not None and 'characterWidth' not in already_processed:
            already_processed.add('characterWidth')
            self.characterWidth = self.gds_parse_integer(value, node, 'characterWidth')
            self.validate_CharacterWidthType(self.characterWidth)  # validate type CharacterWidthType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ArgumentStringDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SizeRangeInCharacters':
            class_obj_ = self.get_class_obj_(child_, IntegerRangeType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SizeRangeInCharacters = obj_
            obj_.original_tagname_ = 'SizeRangeInCharacters'
        super(ArgumentStringDataType, self).buildChildren(child_, node, nodeName_, True)


# end class ArgumentStringDataType


class RelativeTimeDataType(BaseTimeDataType):
    """Used to contain a relative time value. Used to describe a relative time.
    Normally used for time offsets. A Relative time is expressed as PnYn
    MnDTnH nMnS, where nY represents the number of years, nM the number of
    months, nD the number of days, 'T' is the date/time separator, nH the
    number of hours, nM the number of minutes and nS the number of seconds.
    The number of seconds can include decimal digits to arbitrary
    precision. For example, to indicate a duration of 1 year, 2 months, 3
    days, 10 hours, and 30 minutes, one would write: P1Y2M3DT10H30M. One
    could also indicate a duration of minus 120 days as: -P120D. An
    extension of Schema duration type."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseTimeDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, Encoding=None, ReferenceTime=None, initialValue=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RelativeTimeDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                   baseType, Encoding, ReferenceTime, extensiontype_, **kwargs_)
        self.initialValue = _cast(None, initialValue)
        self.initialValue_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelativeTimeDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelativeTimeDataType.subclass:
            return RelativeTimeDataType.subclass(*args_, **kwargs_)
        else:
            return RelativeTimeDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                super(RelativeTimeDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RelativeTimeDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RelativeTimeDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RelativeTimeDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RelativeTimeDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RelativeTimeDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RelativeTimeDataType'):
        super(RelativeTimeDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='RelativeTimeDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.initialValue), input_name='initialValue')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RelativeTimeDataType',
                       fromsubclass_=False, pretty_print=True):
        super(RelativeTimeDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            self.initialValue = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(RelativeTimeDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(RelativeTimeDataType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class RelativeTimeDataType


class ArgumentRelativeTimeDataType(ArgumentBaseTimeDataType):
    """Used to contain a relative time value. Used to describe a relative time.
    Normally used for time offsets. A Relative time is expressed as PnYn
    MnDTnH nMnS, where nY represents the number of years, nM the number of
    months, nD the number of days, 'T' is the date/time separator, nH the
    number of hours, nM the number of minutes and nS the number of seconds.
    The number of seconds can include decimal digits to arbitrary
    precision. For example, to indicate a duration of 1 year, 2 months, 3
    days, 10 hours, and 30 minutes, one would write: P1Y2M3DT10H30M. One
    could also indicate a duration of minus 120 days as: -P120D. An
    extension of Schema duration type."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentBaseTimeDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, Encoding=None, ReferenceTime=None, initialValue=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentRelativeTimeDataType, self).__init__(shortDescription, LongDescription, AliasSet,
                                                           AncillaryDataSet, name, baseType, Encoding, ReferenceTime,
                                                           extensiontype_, **kwargs_)
        self.initialValue = _cast(None, initialValue)
        self.initialValue_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentRelativeTimeDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentRelativeTimeDataType.subclass:
            return ArgumentRelativeTimeDataType.subclass(*args_, **kwargs_)
        else:
            return ArgumentRelativeTimeDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                super(ArgumentRelativeTimeDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentRelativeTimeDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentRelativeTimeDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentRelativeTimeDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentRelativeTimeDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ArgumentRelativeTimeDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentRelativeTimeDataType'):
        super(ArgumentRelativeTimeDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                   name_='ArgumentRelativeTimeDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.initialValue), input_name='initialValue')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ArgumentRelativeTimeDataType', fromsubclass_=False, pretty_print=True):
        super(ArgumentRelativeTimeDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                                 True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            self.initialValue = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ArgumentRelativeTimeDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ArgumentRelativeTimeDataType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ArgumentRelativeTimeDataType


class IntegerDataType(BaseDataType):
    """Describe an integer engineering/calibrated data type. Several encodings
    are supported. See BaseDataType, IntegerParameterType and
    IntegerArgumentType.Default/Initial value is always given in calibrated
    form. Default is base 10 form; binary, octal, or hexadecimal values may
    be given by preceding value with 0[b|B], 0[o|O|, 0[x|X]
    respectively.Optional hint to the implementation about the size of the
    engineering/calibrated data type to use internally. Generally this can
    be determined by examination of the space required to capture the full
    range of the encoding, but it is not always clear when calibrators are
    in use. A tolerant implementation will endeavor to always make
    sufficient size engineering data types to capture the entire range of
    possible values.Flag indicating if the engineering/calibrated data type
    used should support signed representation. This should not be confused
    with the encoding type for the raw value. The default is true."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, sizeInBits='32', signed=True, ToString=None,
                 ValidRange=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IntegerDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                              baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                              IntegerDataEncoding, StringDataEncoding, extensiontype_, **kwargs_)
        self.initialValue = _cast(int, initialValue)
        self.initialValue_nsprefix_ = None
        self.sizeInBits = _cast(int, sizeInBits)
        self.sizeInBits_nsprefix_ = None
        self.signed = _cast(bool, signed)
        self.signed_nsprefix_ = None
        self.ToString = ToString
        self.ToString_nsprefix_ = None
        self.ValidRange = ValidRange
        self.ValidRange_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntegerDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntegerDataType.subclass:
            return IntegerDataType.subclass(*args_, **kwargs_)
        else:
            return IntegerDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ToString(self):
        return self.ToString

    def set_ToString(self, ToString):
        self.ToString = ToString

    def get_ValidRange(self):
        return self.ValidRange

    def set_ValidRange(self, ValidRange):
        self.ValidRange = ValidRange

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_sizeInBits(self):
        return self.sizeInBits

    def set_sizeInBits(self, sizeInBits):
        self.sizeInBits = sizeInBits

    def get_signed(self):
        return self.signed

    def set_signed(self, signed):
        self.signed = signed

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.ToString is not None or
                self.ValidRange is not None or
                super(IntegerDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IntegerDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IntegerDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IntegerDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IntegerDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IntegerDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IntegerDataType'):
        super(IntegerDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                      name_='IntegerDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue="%s"' % self.gds_format_integer(self.initialValue, input_name='initialValue'))
        if self.sizeInBits != 32 and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            outfile.write(' sizeInBits="%s"' % self.gds_format_integer(self.sizeInBits, input_name='sizeInBits'))
        if not self.signed and 'signed' not in already_processed:
            already_processed.add('signed')
            outfile.write(' signed="%s"' % self.gds_format_boolean(self.signed, input_name='signed'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IntegerDataType',
                       fromsubclass_=False, pretty_print=True):
        super(IntegerDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                    pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ToString is not None:
            namespaceprefix_ = self.ToString_nsprefix_ + ':' if (UseCapturedNS_ and self.ToString_nsprefix_) else ''
            self.ToString.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ToString',
                                 pretty_print=pretty_print)
        if self.ValidRange is not None:
            namespaceprefix_ = self.ValidRange_nsprefix_ + ':' if (UseCapturedNS_ and self.ValidRange_nsprefix_) else ''
            self.ValidRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ValidRange',
                                   pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            self.initialValue = self.gds_parse_integer(value, node, 'initialValue')
        value = find_attr_value_('sizeInBits', node)
        if value is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            self.sizeInBits = self.gds_parse_integer(value, node, 'sizeInBits')
            self.validate_PositiveLongType(self.sizeInBits)  # validate type PositiveLongType
        value = find_attr_value_('signed', node)
        if value is not None and 'signed' not in already_processed:
            already_processed.add('signed')
            if value in ('true', '1'):
                self.signed = True
            elif value in ('false', '0'):
                self.signed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IntegerDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ToString':
            obj_ = ToStringType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ToString = obj_
            obj_.original_tagname_ = 'ToString'
        elif nodeName_ == 'ValidRange':
            obj_ = ValidRangeType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValidRange = obj_
            obj_.original_tagname_ = 'ValidRange'
        super(IntegerDataType, self).buildChildren(child_, node, nodeName_, True)


# end class IntegerDataType


class ArgumentIntegerDataType(ArgumentBaseDataType):
    """Identical to IntegerDataType but supports argument instance
    references.Default/Initial value is always given in calibrated form.
    Default is base 10 form; binary, octal, or hexadecimal values may be
    given by preceding value with 0[b|B], 0[o|O|, 0[x|X]
    respectively.Optional hint to the implementation about the size of the
    engineering/calibrated data type to use internally. Generally this can
    be determined by examination of the space required to capture the full
    range of the encoding, but it is not always clear when calibrators are
    in use. A tolerant implementation will endeavor to always make
    sufficient size engineering data types to capture the entire range of
    possible values.Flag indicating if the engineering/calibrated data type
    used should support signed representation. This should not be confused
    with the encoding type for the raw value. The default is true."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentBaseDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, sizeInBits='32', signed=True, ToString=None,
                 extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentIntegerDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                      name, baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                      IntegerDataEncoding, StringDataEncoding, extensiontype_,
                                                      **kwargs_)
        self.initialValue = _cast(None, initialValue)
        self.initialValue_nsprefix_ = None
        self.sizeInBits = _cast(int, sizeInBits)
        self.sizeInBits_nsprefix_ = None
        self.signed = _cast(bool, signed)
        self.signed_nsprefix_ = None
        self.ToString = ToString
        self.ToString_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentIntegerDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentIntegerDataType.subclass:
            return ArgumentIntegerDataType.subclass(*args_, **kwargs_)
        else:
            return ArgumentIntegerDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ToString(self):
        return self.ToString

    def set_ToString(self, ToString):
        self.ToString = ToString

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_sizeInBits(self):
        return self.sizeInBits

    def set_sizeInBits(self, sizeInBits):
        self.sizeInBits = sizeInBits

    def get_signed(self):
        return self.signed

    def set_signed(self, signed):
        self.signed = signed

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_FixedIntegerValueType(self, value):
        # Validate type xtce:FixedIntegerValueType, a restriction on None.
        pass

    def validate_PositiveLongType(self, value):
        # Validate type xtce:PositiveLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on PositiveLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.ToString is not None or
                super(ArgumentIntegerDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentIntegerDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentIntegerDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentIntegerDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentIntegerDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentIntegerDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArgumentIntegerDataType'):
        super(ArgumentIntegerDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                              name_='ArgumentIntegerDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue=%s' % (quote_attrib(self.initialValue),))
        if self.sizeInBits != 32 and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            outfile.write(' sizeInBits="%s"' % self.gds_format_integer(self.sizeInBits, input_name='sizeInBits'))
        if not self.signed and 'signed' not in already_processed:
            already_processed.add('signed')
            outfile.write(' signed="%s"' % self.gds_format_boolean(self.signed, input_name='signed'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentIntegerDataType',
                       fromsubclass_=False, pretty_print=True):
        super(ArgumentIntegerDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                            True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ToString is not None:
            namespaceprefix_ = self.ToString_nsprefix_ + ':' if (UseCapturedNS_ and self.ToString_nsprefix_) else ''
            self.ToString.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ToString',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            self.initialValue = value
            self.validate_FixedIntegerValueType(self.initialValue)  # validate type FixedIntegerValueType
        value = find_attr_value_('sizeInBits', node)
        if value is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            self.sizeInBits = self.gds_parse_integer(value, node, 'sizeInBits')
            self.validate_PositiveLongType(self.sizeInBits)  # validate type PositiveLongType
        value = find_attr_value_('signed', node)
        if value is not None and 'signed' not in already_processed:
            already_processed.add('signed')
            if value in ('true', '1'):
                self.signed = True
            elif value in ('false', '0'):
                self.signed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ArgumentIntegerDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ToString':
            obj_ = ToStringType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ToString = obj_
            obj_.original_tagname_ = 'ToString'
        super(ArgumentIntegerDataType, self).buildChildren(child_, node, nodeName_, True)


# end class ArgumentIntegerDataType


class FloatDataType(BaseDataType):
    """A base schema type for describing a floating point
    engineering/calibrated data type. Several encodings are supported.
    Calibrated integer to float relationships should be described with this
    data type. Use the data encoding to define calibrators. Joins integer
    as one of the numerics. See BaseDataType, FloatParameterType and
    FloatArgumentType.Initial value is always given in calibrated
    formOptional hint to the implementation about the size of the
    engineering/calibrated data type to use internally. Generally this can
    be determined by examination of the space required to capture the full
    range of the encoding, but it is not always clear when calibrators are
    in use. A tolerant implementation will endeavor to always make
    sufficient size engineering data types to capture the entire range of
    possible values."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, sizeInBits='32', ToString=None, ValidRange=None,
                 extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FloatDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                            baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                            IntegerDataEncoding, StringDataEncoding, extensiontype_, **kwargs_)
        self.initialValue = _cast(float, initialValue)
        self.initialValue_nsprefix_ = None
        self.sizeInBits = _cast(int, sizeInBits)
        self.sizeInBits_nsprefix_ = None
        self.ToString = ToString
        self.ToString_nsprefix_ = None
        self.ValidRange = ValidRange
        self.ValidRange_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatDataType.subclass:
            return FloatDataType.subclass(*args_, **kwargs_)
        else:
            return FloatDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ToString(self):
        return self.ToString

    def set_ToString(self, ToString):
        self.ToString = ToString

    def get_ValidRange(self):
        return self.ValidRange

    def set_ValidRange(self, ValidRange):
        self.ValidRange = ValidRange

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_sizeInBits(self):
        return self.sizeInBits

    def set_sizeInBits(self, sizeInBits):
        self.sizeInBits = sizeInBits

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_FloatSizeInBitsType(self, value):
        # Validate type xtce:FloatSizeInBitsType, a restriction on xtce:PositiveLongType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = [32, 64, 128]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FloatSizeInBitsType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on FloatSizeInBitsType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.ToString is not None or
                self.ValidRange is not None or
                super(FloatDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FloatDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FloatDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FloatDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FloatDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FloatDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FloatDataType'):
        super(FloatDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                    name_='FloatDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue="%s"' % self.gds_format_double(self.initialValue, input_name='initialValue'))
        if self.sizeInBits != "32" and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            outfile.write(' sizeInBits=%s' % (quote_attrib(self.sizeInBits),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FloatDataType',
                       fromsubclass_=False, pretty_print=True):
        super(FloatDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                  pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ToString is not None:
            namespaceprefix_ = self.ToString_nsprefix_ + ':' if (UseCapturedNS_ and self.ToString_nsprefix_) else ''
            self.ToString.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ToString',
                                 pretty_print=pretty_print)
        if self.ValidRange is not None:
            namespaceprefix_ = self.ValidRange_nsprefix_ + ':' if (UseCapturedNS_ and self.ValidRange_nsprefix_) else ''
            self.ValidRange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ValidRange',
                                   pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            value = self.gds_parse_double(value, node, 'initialValue')
            self.initialValue = value
        value = find_attr_value_('sizeInBits', node)
        if value is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            self.sizeInBits = self.gds_parse_integer(value, node, 'sizeInBits')
            self.validate_FloatSizeInBitsType(self.sizeInBits)  # validate type FloatSizeInBitsType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(FloatDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ToString':
            obj_ = ToStringType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ToString = obj_
            obj_.original_tagname_ = 'ToString'
        elif nodeName_ == 'ValidRange':
            obj_ = ValidRangeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValidRange = obj_
            obj_.original_tagname_ = 'ValidRange'
        super(FloatDataType, self).buildChildren(child_, node, nodeName_, True)


# end class FloatDataType


class ArgumentFloatDataType(ArgumentBaseDataType):
    """Identical to FloatDataType but supports argument instance
    references.Default/Initial value is always given in calibrated
    form.Optional hint to the implementation about the size of the
    engineering/calibrated data type to use internally. Generally this can
    be determined by examination of the space required to capture the full
    range of the encoding, but it is not always clear when calibrators are
    in use. A tolerant implementation will endeavor to always make
    sufficient size engineering data types to capture the entire range of
    possible values."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentBaseDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, sizeInBits='32', ToString=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentFloatDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                    baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                    IntegerDataEncoding, StringDataEncoding, extensiontype_, **kwargs_)
        self.initialValue = _cast(float, initialValue)
        self.initialValue_nsprefix_ = None
        self.sizeInBits = _cast(int, sizeInBits)
        self.sizeInBits_nsprefix_ = None
        self.ToString = ToString
        self.ToString_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentFloatDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentFloatDataType.subclass:
            return ArgumentFloatDataType.subclass(*args_, **kwargs_)
        else:
            return ArgumentFloatDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ToString(self):
        return self.ToString

    def set_ToString(self, ToString):
        self.ToString = ToString

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_sizeInBits(self):
        return self.sizeInBits

    def set_sizeInBits(self, sizeInBits):
        self.sizeInBits = sizeInBits

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_FloatSizeInBitsType(self, value):
        # Validate type xtce:FloatSizeInBitsType, a restriction on xtce:PositiveLongType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = [32, 64, 128]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FloatSizeInBitsType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on FloatSizeInBitsType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.ToString is not None or
                super(ArgumentFloatDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentFloatDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentFloatDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentFloatDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentFloatDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentFloatDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArgumentFloatDataType'):
        super(ArgumentFloatDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                            name_='ArgumentFloatDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue="%s"' % self.gds_format_double(self.initialValue, input_name='initialValue'))
        if self.sizeInBits != "32" and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            outfile.write(' sizeInBits=%s' % (quote_attrib(self.sizeInBits),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentFloatDataType',
                       fromsubclass_=False, pretty_print=True):
        super(ArgumentFloatDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                          pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ToString is not None:
            namespaceprefix_ = self.ToString_nsprefix_ + ':' if (UseCapturedNS_ and self.ToString_nsprefix_) else ''
            self.ToString.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ToString',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            value = self.gds_parse_double(value, node, 'initialValue')
            self.initialValue = value
        value = find_attr_value_('sizeInBits', node)
        if value is not None and 'sizeInBits' not in already_processed:
            already_processed.add('sizeInBits')
            self.sizeInBits = self.gds_parse_integer(value, node, 'sizeInBits')
            self.validate_FloatSizeInBitsType(self.sizeInBits)  # validate type FloatSizeInBitsType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ArgumentFloatDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ToString':
            obj_ = ToStringType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ToString = obj_
            obj_.original_tagname_ = 'ToString'
        super(ArgumentFloatDataType, self).buildChildren(child_, node, nodeName_, True)


# end class ArgumentFloatDataType


class EnumeratedDataType(BaseDataType):
    """Describes an enumerated parameter type. The enumeration list consists of
    label/value pairs. See EnumerationListType, EnumeratedParameterType and
    EnumeratedArgumentType.Default/Initial value is always given in
    calibrated form. Use the label, it must be in the enumeration list to
    be valid."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, EnumerationList=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EnumeratedDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                 baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                 IntegerDataEncoding, StringDataEncoding, extensiontype_, **kwargs_)
        self.initialValue = _cast(None, initialValue)
        self.initialValue_nsprefix_ = None
        self.EnumerationList = EnumerationList
        self.EnumerationList_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnumeratedDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnumeratedDataType.subclass:
            return EnumeratedDataType.subclass(*args_, **kwargs_)
        else:
            return EnumeratedDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_EnumerationList(self):
        return self.EnumerationList

    def set_EnumerationList(self, EnumerationList):
        self.EnumerationList = EnumerationList

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.EnumerationList is not None or
                super(EnumeratedDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnumeratedDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnumeratedDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EnumeratedDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnumeratedDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EnumeratedDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EnumeratedDataType'):
        super(EnumeratedDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                         name_='EnumeratedDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.initialValue), input_name='initialValue')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnumeratedDataType',
                       fromsubclass_=False, pretty_print=True):
        super(EnumeratedDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                       pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EnumerationList is not None:
            namespaceprefix_ = self.EnumerationList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.EnumerationList_nsprefix_) else ''
            self.EnumerationList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EnumerationList',
                                        pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            self.initialValue = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EnumeratedDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EnumerationList':
            obj_ = EnumerationListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnumerationList = obj_
            obj_.original_tagname_ = 'EnumerationList'
        super(EnumeratedDataType, self).buildChildren(child_, node, nodeName_, True)


# end class EnumeratedDataType


class ArgumentEnumeratedDataType(ArgumentBaseDataType):
    """Identical to EnumeratedDataType but supports argument instance
    references.Default/Initial value is always given in calibrated form.
    Use the label, it must be in the enumeration list to be valid."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentBaseDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, EnumerationList=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentEnumeratedDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                         name, baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                         IntegerDataEncoding, StringDataEncoding, extensiontype_,
                                                         **kwargs_)
        self.initialValue = _cast(None, initialValue)
        self.initialValue_nsprefix_ = None
        self.EnumerationList = EnumerationList
        self.EnumerationList_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentEnumeratedDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentEnumeratedDataType.subclass:
            return ArgumentEnumeratedDataType.subclass(*args_, **kwargs_)
        else:
            return ArgumentEnumeratedDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_EnumerationList(self):
        return self.EnumerationList

    def set_EnumerationList(self, EnumerationList):
        self.EnumerationList = EnumerationList

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.EnumerationList is not None or
                super(ArgumentEnumeratedDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentEnumeratedDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentEnumeratedDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentEnumeratedDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentEnumeratedDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentEnumeratedDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ArgumentEnumeratedDataType'):
        super(ArgumentEnumeratedDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                 name_='ArgumentEnumeratedDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.initialValue), input_name='initialValue')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentEnumeratedDataType',
                       fromsubclass_=False, pretty_print=True):
        super(ArgumentEnumeratedDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                               True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EnumerationList is not None:
            namespaceprefix_ = self.EnumerationList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.EnumerationList_nsprefix_) else ''
            self.EnumerationList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EnumerationList',
                                        pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            self.initialValue = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ArgumentEnumeratedDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EnumerationList':
            obj_ = EnumerationListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnumerationList = obj_
            obj_.original_tagname_ = 'EnumerationList'
        super(ArgumentEnumeratedDataType, self).buildChildren(child_, node, nodeName_, True)


# end class ArgumentEnumeratedDataType


class BooleanDataType(BaseDataType):
    """A base schema type for describing a boolean data type which has two
    values only: ‘True’ (1) or ‘False’ (0). The values one and zero may be
    mapped to a specific string using the attributes oneStringValue and
    zeroStringValue. This type is a simplified form of the
    EnumeratedDataType. See BaseDataType, BooleanParameterType and
    BooleanArgumentType.Default/Initial value is always given in calibrated
    form.Enumeration string representing the 1 value, with the default
    being 'True'.Enumeration string representing the 0 value, with the
    default being 'False'."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, oneStringValue='True', zeroStringValue='False',
                 extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BooleanDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                              baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                              IntegerDataEncoding, StringDataEncoding, extensiontype_, **kwargs_)
        self.initialValue = _cast(None, initialValue)
        self.initialValue_nsprefix_ = None
        self.oneStringValue = _cast(None, oneStringValue)
        self.oneStringValue_nsprefix_ = None
        self.zeroStringValue = _cast(None, zeroStringValue)
        self.zeroStringValue_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BooleanDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BooleanDataType.subclass:
            return BooleanDataType.subclass(*args_, **kwargs_)
        else:
            return BooleanDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_oneStringValue(self):
        return self.oneStringValue

    def set_oneStringValue(self, oneStringValue):
        self.oneStringValue = oneStringValue

    def get_zeroStringValue(self):
        return self.zeroStringValue

    def set_zeroStringValue(self, zeroStringValue):
        self.zeroStringValue = zeroStringValue

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                super(BooleanDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BooleanDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BooleanDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BooleanDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BooleanDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BooleanDataType'):
        super(BooleanDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                      name_='BooleanDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.initialValue), input_name='initialValue')),))
        if self.oneStringValue != "True" and 'oneStringValue' not in already_processed:
            already_processed.add('oneStringValue')
            outfile.write(' oneStringValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.oneStringValue), input_name='oneStringValue')),))
        if self.zeroStringValue != "False" and 'zeroStringValue' not in already_processed:
            already_processed.add('zeroStringValue')
            outfile.write(' zeroStringValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.zeroStringValue), input_name='zeroStringValue')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BooleanDataType',
                       fromsubclass_=False, pretty_print=True):
        super(BooleanDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                    pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            self.initialValue = value
        value = find_attr_value_('oneStringValue', node)
        if value is not None and 'oneStringValue' not in already_processed:
            already_processed.add('oneStringValue')
            self.oneStringValue = value
        value = find_attr_value_('zeroStringValue', node)
        if value is not None and 'zeroStringValue' not in already_processed:
            already_processed.add('zeroStringValue')
            self.zeroStringValue = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BooleanDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BooleanDataType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class BooleanDataType


class ArgumentBooleanDataType(ArgumentBaseDataType):
    """Identical to BooleanDataType but supports argument instance
    references.Default/Initial value is always given in calibrated
    form.Enumeration string representing the 1 value, with the default
    being 'True'.Enumeration string representing the 0 value, with the
    default being 'False'."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentBaseDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, oneStringValue='True', zeroStringValue='False',
                 extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentBooleanDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                      name, baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                      IntegerDataEncoding, StringDataEncoding, extensiontype_,
                                                      **kwargs_)
        self.initialValue = _cast(None, initialValue)
        self.initialValue_nsprefix_ = None
        self.oneStringValue = _cast(None, oneStringValue)
        self.oneStringValue_nsprefix_ = None
        self.zeroStringValue = _cast(None, zeroStringValue)
        self.zeroStringValue_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentBooleanDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentBooleanDataType.subclass:
            return ArgumentBooleanDataType.subclass(*args_, **kwargs_)
        else:
            return ArgumentBooleanDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_oneStringValue(self):
        return self.oneStringValue

    def set_oneStringValue(self, oneStringValue):
        self.oneStringValue = oneStringValue

    def get_zeroStringValue(self):
        return self.zeroStringValue

    def set_zeroStringValue(self, zeroStringValue):
        self.zeroStringValue = zeroStringValue

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                super(ArgumentBooleanDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentBooleanDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentBooleanDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentBooleanDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentBooleanDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentBooleanDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArgumentBooleanDataType'):
        super(ArgumentBooleanDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                              name_='ArgumentBooleanDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.initialValue), input_name='initialValue')),))
        if self.oneStringValue != "True" and 'oneStringValue' not in already_processed:
            already_processed.add('oneStringValue')
            outfile.write(' oneStringValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.oneStringValue), input_name='oneStringValue')),))
        if self.zeroStringValue != "False" and 'zeroStringValue' not in already_processed:
            already_processed.add('zeroStringValue')
            outfile.write(' zeroStringValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.zeroStringValue), input_name='zeroStringValue')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentBooleanDataType',
                       fromsubclass_=False, pretty_print=True):
        super(ArgumentBooleanDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                            True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            self.initialValue = value
        value = find_attr_value_('oneStringValue', node)
        if value is not None and 'oneStringValue' not in already_processed:
            already_processed.add('oneStringValue')
            self.oneStringValue = value
        value = find_attr_value_('zeroStringValue', node)
        if value is not None and 'zeroStringValue' not in already_processed:
            already_processed.add('zeroStringValue')
            self.zeroStringValue = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ArgumentBooleanDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ArgumentBooleanDataType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ArgumentBooleanDataType


class BinaryDataType(BaseDataType):
    """A base schema type for describing a binary data engineering/calibrated
    type (often called “blob type”). The binary data may be of fixed or
    variable length, and has an optional encoding and decoding algorithm
    that may be defined to transform the data between space and ground. See
    BaseDataType, BinaryParameterType and
    BinaryArgumentType.Default/Initial value is always given in calibrated
    form. Extra bits are truncated from the MSB (leftmost)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BinaryDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                             baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                             IntegerDataEncoding, StringDataEncoding, extensiontype_, **kwargs_)
        self.initialValue = _cast(None, initialValue)
        self.initialValue_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BinaryDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BinaryDataType.subclass:
            return BinaryDataType.subclass(*args_, **kwargs_)
        else:
            return BinaryDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                super(BinaryDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BinaryDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BinaryDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BinaryDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BinaryDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BinaryDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BinaryDataType'):
        super(BinaryDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                     name_='BinaryDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.initialValue), input_name='initialValue')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BinaryDataType',
                       fromsubclass_=False, pretty_print=True):
        super(BinaryDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                   pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            self.initialValue = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BinaryDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BinaryDataType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class BinaryDataType


class ArgumentBinaryDataType(ArgumentBaseDataType):
    """Identical to BinaryDataType but supports argument instance
    references.Default/Initial value is always given in calibrated form.
    Extra bits are truncated from the MSB (leftmost)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentBaseDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArgumentBinaryDataType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                     name, baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                     IntegerDataEncoding, StringDataEncoding, extensiontype_, **kwargs_)
        self.initialValue = _cast(None, initialValue)
        self.initialValue_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArgumentBinaryDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArgumentBinaryDataType.subclass:
            return ArgumentBinaryDataType.subclass(*args_, **kwargs_)
        else:
            return ArgumentBinaryDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_initialValue(self):
        return self.initialValue

    def set_initialValue(self, initialValue):
        self.initialValue = initialValue

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                super(ArgumentBinaryDataType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentBinaryDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArgumentBinaryDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArgumentBinaryDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArgumentBinaryDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArgumentBinaryDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArgumentBinaryDataType'):
        super(ArgumentBinaryDataType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                             name_='ArgumentBinaryDataType')
        if self.initialValue is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            outfile.write(' initialValue=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.initialValue), input_name='initialValue')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArgumentBinaryDataType',
                       fromsubclass_=False, pretty_print=True):
        super(ArgumentBinaryDataType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                           pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialValue', node)
        if value is not None and 'initialValue' not in already_processed:
            already_processed.add('initialValue')
            self.initialValue = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ArgumentBinaryDataType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ArgumentBinaryDataType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ArgumentBinaryDataType


class VariableFrameStreamType(FrameStreamType):
    """For streams that contain a series of frames with a variable frame length
    where the frames are found by looking for a series of one's or zero's
    (usually one's). The series is called the flag. in the PCM stream that
    are usually made to be illegal in the PCM stream by zero or one bit
    insertion."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FrameStreamType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 bitRateInBPS=None, pcmType='NRZL', inverted=False, ContainerRef=None, ServiceRef=None, StreamRef=None,
                 SyncStrategy=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(VariableFrameStreamType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                      name, bitRateInBPS, pcmType, inverted, ContainerRef, ServiceRef,
                                                      StreamRef, **kwargs_)
        self.SyncStrategy = SyncStrategy
        self.SyncStrategy_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableFrameStreamType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableFrameStreamType.subclass:
            return VariableFrameStreamType.subclass(*args_, **kwargs_)
        else:
            return VariableFrameStreamType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SyncStrategy(self):
        return self.SyncStrategy

    def set_SyncStrategy(self, SyncStrategy):
        self.SyncStrategy = SyncStrategy

    def hasContent_(self):
        if (
                self.SyncStrategy is not None or
                super(VariableFrameStreamType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VariableFrameStreamType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VariableFrameStreamType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VariableFrameStreamType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VariableFrameStreamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VariableFrameStreamType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VariableFrameStreamType'):
        super(VariableFrameStreamType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                              name_='VariableFrameStreamType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VariableFrameStreamType',
                       fromsubclass_=False, pretty_print=True):
        super(VariableFrameStreamType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                            True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SyncStrategy is not None:
            namespaceprefix_ = self.SyncStrategy_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SyncStrategy_nsprefix_) else ''
            self.SyncStrategy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SyncStrategy',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(VariableFrameStreamType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SyncStrategy':
            obj_ = VariableFrameSyncStrategyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SyncStrategy = obj_
            obj_.original_tagname_ = 'SyncStrategy'
        super(VariableFrameStreamType, self).buildChildren(child_, node, nodeName_, True)


# end class VariableFrameStreamType


class FixedFrameStreamType(FrameStreamType):
    """For streams that contain a series of frames with a fixed frame length
    where the frames are found by looking for a marker in the data. This
    marker is sometimes called the frame sync pattern and sometimes the
    Asynchronous Sync Marker (ASM). This marker need not be contiguous
    although it usually is.Allowed slip (in bits) in either direction for
    the sync pattern"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FrameStreamType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 bitRateInBPS=None, pcmType='NRZL', inverted=False, ContainerRef=None, ServiceRef=None, StreamRef=None,
                 syncApertureInBits='0', frameLengthInBits=None, SyncStrategy=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FixedFrameStreamType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                   bitRateInBPS, pcmType, inverted, ContainerRef, ServiceRef, StreamRef,
                                                   **kwargs_)
        self.syncApertureInBits = _cast(int, syncApertureInBits)
        self.syncApertureInBits_nsprefix_ = None
        self.frameLengthInBits = _cast(int, frameLengthInBits)
        self.frameLengthInBits_nsprefix_ = None
        self.SyncStrategy = SyncStrategy
        self.SyncStrategy_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FixedFrameStreamType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FixedFrameStreamType.subclass:
            return FixedFrameStreamType.subclass(*args_, **kwargs_)
        else:
            return FixedFrameStreamType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SyncStrategy(self):
        return self.SyncStrategy

    def set_SyncStrategy(self, SyncStrategy):
        self.SyncStrategy = SyncStrategy

    def get_syncApertureInBits(self):
        return self.syncApertureInBits

    def set_syncApertureInBits(self, syncApertureInBits):
        self.syncApertureInBits = syncApertureInBits

    def get_frameLengthInBits(self):
        return self.frameLengthInBits

    def set_frameLengthInBits(self, frameLengthInBits):
        self.frameLengthInBits = frameLengthInBits

    def validate_NonNegativeLongType(self, value):
        # Validate type xtce:NonNegativeLongType, a restriction on long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on NonNegativeLongType' % {
                        "value": value, "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.SyncStrategy is not None or
                super(FixedFrameStreamType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FixedFrameStreamType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FixedFrameStreamType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FixedFrameStreamType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FixedFrameStreamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FixedFrameStreamType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FixedFrameStreamType'):
        super(FixedFrameStreamType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='FixedFrameStreamType')
        if self.syncApertureInBits != 0 and 'syncApertureInBits' not in already_processed:
            already_processed.add('syncApertureInBits')
            outfile.write(' syncApertureInBits="%s"' % self.gds_format_integer(self.syncApertureInBits,
                                                                               input_name='syncApertureInBits'))
        if self.frameLengthInBits is not None and 'frameLengthInBits' not in already_processed:
            already_processed.add('frameLengthInBits')
            outfile.write(' frameLengthInBits="%s"' % self.gds_format_integer(self.frameLengthInBits,
                                                                              input_name='frameLengthInBits'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FixedFrameStreamType',
                       fromsubclass_=False, pretty_print=True):
        super(FixedFrameStreamType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SyncStrategy is not None:
            namespaceprefix_ = self.SyncStrategy_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SyncStrategy_nsprefix_) else ''
            self.SyncStrategy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SyncStrategy',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('syncApertureInBits', node)
        if value is not None and 'syncApertureInBits' not in already_processed:
            already_processed.add('syncApertureInBits')
            self.syncApertureInBits = self.gds_parse_integer(value, node, 'syncApertureInBits')
            self.validate_NonNegativeLongType(self.syncApertureInBits)  # validate type NonNegativeLongType
        value = find_attr_value_('frameLengthInBits', node)
        if value is not None and 'frameLengthInBits' not in already_processed:
            already_processed.add('frameLengthInBits')
            self.frameLengthInBits = self.gds_parse_integer(value, node, 'frameLengthInBits')
        super(FixedFrameStreamType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SyncStrategy':
            obj_ = FixedFrameSyncStrategyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SyncStrategy = obj_
            obj_.original_tagname_ = 'SyncStrategy'
        super(FixedFrameStreamType, self).buildChildren(child_, node, nodeName_, True)


# end class FixedFrameStreamType


class InputParameterInstanceRefType(ParameterInstanceRefType):
    """Names an input parameter to the algorithm. There are two attributes to
    InputParm, inputName and parameterName. parameterName is a parameter
    reference name for a parameter that will be used in this algorithm.
    inputName is an optional "friendly" name for the input parameter."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ParameterInstanceRefType

    def __init__(self, parameterRef=None, instance=0, useCalibratedValue=True, inputName=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(InputParameterInstanceRefType, self).__init__(parameterRef, instance, useCalibratedValue, **kwargs_)
        self.inputName = _cast(None, inputName)
        self.inputName_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InputParameterInstanceRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InputParameterInstanceRefType.subclass:
            return InputParameterInstanceRefType.subclass(*args_, **kwargs_)
        else:
            return InputParameterInstanceRefType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_inputName(self):
        return self.inputName

    def set_inputName(self, inputName):
        self.inputName = inputName

    def hasContent_(self):
        if (
                super(InputParameterInstanceRefType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InputParameterInstanceRefType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InputParameterInstanceRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InputParameterInstanceRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='InputParameterInstanceRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='InputParameterInstanceRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='InputParameterInstanceRefType'):
        super(InputParameterInstanceRefType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                    name_='InputParameterInstanceRefType')
        if self.inputName is not None and 'inputName' not in already_processed:
            already_processed.add('inputName')
            outfile.write(' inputName=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.inputName), input_name='inputName')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='InputParameterInstanceRefType', fromsubclass_=False, pretty_print=True):
        super(InputParameterInstanceRefType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_,
                                                                  name_, True, pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inputName', node)
        if value is not None and 'inputName' not in already_processed:
            already_processed.add('inputName')
            self.inputName = value
        super(InputParameterInstanceRefType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(InputParameterInstanceRefType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class InputParameterInstanceRefType


class InputOutputAlgorithmType(InputAlgorithmType):
    """A set of labeled outputs are added to the SimpleInputAlgorithmType"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = InputAlgorithmType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 AlgorithmText=None, ExternalAlgorithmSet=None, InputSet=None, thread=False, OutputSet=None,
                 extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(InputOutputAlgorithmType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                       name, AlgorithmText, ExternalAlgorithmSet, InputSet,
                                                       extensiontype_, **kwargs_)
        self.thread = _cast(bool, thread)
        self.thread_nsprefix_ = None
        self.OutputSet = OutputSet
        self.OutputSet_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InputOutputAlgorithmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InputOutputAlgorithmType.subclass:
            return InputOutputAlgorithmType.subclass(*args_, **kwargs_)
        else:
            return InputOutputAlgorithmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_OutputSet(self):
        return self.OutputSet

    def set_OutputSet(self, OutputSet):
        self.OutputSet = OutputSet

    def get_thread(self):
        return self.thread

    def set_thread(self, thread):
        self.thread = thread

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.OutputSet is not None or
                super(InputOutputAlgorithmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InputOutputAlgorithmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InputOutputAlgorithmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InputOutputAlgorithmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InputOutputAlgorithmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InputOutputAlgorithmType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='InputOutputAlgorithmType'):
        super(InputOutputAlgorithmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                               name_='InputOutputAlgorithmType')
        if self.thread and 'thread' not in already_processed:
            already_processed.add('thread')
            outfile.write(' thread="%s"' % self.gds_format_boolean(self.thread, input_name='thread'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InputOutputAlgorithmType',
                       fromsubclass_=False, pretty_print=True):
        super(InputOutputAlgorithmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                             True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OutputSet is not None:
            namespaceprefix_ = self.OutputSet_nsprefix_ + ':' if (UseCapturedNS_ and self.OutputSet_nsprefix_) else ''
            self.OutputSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OutputSet',
                                  pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('thread', node)
        if value is not None and 'thread' not in already_processed:
            already_processed.add('thread')
            if value in ('true', '1'):
                self.thread = True
            elif value in ('false', '0'):
                self.thread = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(InputOutputAlgorithmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OutputSet':
            obj_ = OutputSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OutputSet = obj_
            obj_.original_tagname_ = 'OutputSet'
        super(InputOutputAlgorithmType, self).buildChildren(child_, node, nodeName_, True)


# end class InputOutputAlgorithmType


class TransferredToRangeVerifierType(CommandVerifierType):
    """Transferred to range means the command has been received to the network
    that connects the ground system to the spacecraft. Obviously, this
    verifier must come from something other than the spacecraft."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CommandVerifierType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 ComparisonList=None, ContainerRef=None, ParameterValueChange=None, CustomAlgorithm=None,
                 BooleanExpression=None, Comparison=None, CheckWindow=None, CheckWindowAlgorithms=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TransferredToRangeVerifierType, self).__init__(shortDescription, LongDescription, AliasSet,
                                                             AncillaryDataSet, name, ComparisonList, ContainerRef,
                                                             ParameterValueChange, CustomAlgorithm, BooleanExpression,
                                                             Comparison, CheckWindow, CheckWindowAlgorithms, **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransferredToRangeVerifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransferredToRangeVerifierType.subclass:
            return TransferredToRangeVerifierType.subclass(*args_, **kwargs_)
        else:
            return TransferredToRangeVerifierType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(TransferredToRangeVerifierType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TransferredToRangeVerifierType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransferredToRangeVerifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransferredToRangeVerifierType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='TransferredToRangeVerifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='TransferredToRangeVerifierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='TransferredToRangeVerifierType'):
        super(TransferredToRangeVerifierType, self).exportAttributes(outfile, level, already_processed,
                                                                     namespaceprefix_,
                                                                     name_='TransferredToRangeVerifierType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='TransferredToRangeVerifierType', fromsubclass_=False, pretty_print=True):
        super(TransferredToRangeVerifierType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_,
                                                                   name_, True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(TransferredToRangeVerifierType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TransferredToRangeVerifierType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class TransferredToRangeVerifierType


class SentFromRangeVerifierType(CommandVerifierType):
    """Sent from range means the command has been transmitted to the spacecraft
    by the network that connects the ground system to the spacecraft.
    Obviously, this verifier must come from something other than the
    spacecraft."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CommandVerifierType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 ComparisonList=None, ContainerRef=None, ParameterValueChange=None, CustomAlgorithm=None,
                 BooleanExpression=None, Comparison=None, CheckWindow=None, CheckWindowAlgorithms=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SentFromRangeVerifierType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                        name, ComparisonList, ContainerRef, ParameterValueChange,
                                                        CustomAlgorithm, BooleanExpression, Comparison, CheckWindow,
                                                        CheckWindowAlgorithms, **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SentFromRangeVerifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SentFromRangeVerifierType.subclass:
            return SentFromRangeVerifierType.subclass(*args_, **kwargs_)
        else:
            return SentFromRangeVerifierType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(SentFromRangeVerifierType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SentFromRangeVerifierType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SentFromRangeVerifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SentFromRangeVerifierType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SentFromRangeVerifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SentFromRangeVerifierType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='SentFromRangeVerifierType'):
        super(SentFromRangeVerifierType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                name_='SentFromRangeVerifierType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SentFromRangeVerifierType',
                       fromsubclass_=False, pretty_print=True):
        super(SentFromRangeVerifierType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                              True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(SentFromRangeVerifierType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SentFromRangeVerifierType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class SentFromRangeVerifierType


class ReceivedVerifierType(CommandVerifierType):
    """A verifier that simply means the SpaceSystem has received the
    command."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CommandVerifierType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 ComparisonList=None, ContainerRef=None, ParameterValueChange=None, CustomAlgorithm=None,
                 BooleanExpression=None, Comparison=None, CheckWindow=None, CheckWindowAlgorithms=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ReceivedVerifierType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                   ComparisonList, ContainerRef, ParameterValueChange, CustomAlgorithm,
                                                   BooleanExpression, Comparison, CheckWindow, CheckWindowAlgorithms,
                                                   **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReceivedVerifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReceivedVerifierType.subclass:
            return ReceivedVerifierType.subclass(*args_, **kwargs_)
        else:
            return ReceivedVerifierType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(ReceivedVerifierType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReceivedVerifierType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReceivedVerifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReceivedVerifierType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReceivedVerifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReceivedVerifierType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReceivedVerifierType'):
        super(ReceivedVerifierType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='ReceivedVerifierType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReceivedVerifierType',
                       fromsubclass_=False, pretty_print=True):
        super(ReceivedVerifierType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(ReceivedVerifierType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ReceivedVerifierType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class ReceivedVerifierType


class QueuedVerifierType(CommandVerifierType):
    """A verifer that means the command is scheduled for execution by the
    SpaceSystem."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CommandVerifierType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 ComparisonList=None, ContainerRef=None, ParameterValueChange=None, CustomAlgorithm=None,
                 BooleanExpression=None, Comparison=None, CheckWindow=None, CheckWindowAlgorithms=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(QueuedVerifierType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                 ComparisonList, ContainerRef, ParameterValueChange, CustomAlgorithm,
                                                 BooleanExpression, Comparison, CheckWindow, CheckWindowAlgorithms,
                                                 **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueuedVerifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueuedVerifierType.subclass:
            return QueuedVerifierType.subclass(*args_, **kwargs_)
        else:
            return QueuedVerifierType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(QueuedVerifierType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='QueuedVerifierType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueuedVerifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueuedVerifierType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueuedVerifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueuedVerifierType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueuedVerifierType'):
        super(QueuedVerifierType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                         name_='QueuedVerifierType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='QueuedVerifierType',
                       fromsubclass_=False, pretty_print=True):
        super(QueuedVerifierType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                       pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(QueuedVerifierType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueuedVerifierType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class QueuedVerifierType


class FailedVerifierType(CommandVerifierType):
    """When true, indicates that the command failed. timeToWait is how long to
    wait for the FailedVerifier to test true."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CommandVerifierType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 ComparisonList=None, ContainerRef=None, ParameterValueChange=None, CustomAlgorithm=None,
                 BooleanExpression=None, Comparison=None, CheckWindow=None, CheckWindowAlgorithms=None,
                 ReturnParmRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FailedVerifierType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                 ComparisonList, ContainerRef, ParameterValueChange, CustomAlgorithm,
                                                 BooleanExpression, Comparison, CheckWindow, CheckWindowAlgorithms,
                                                 **kwargs_)
        self.ReturnParmRef = ReturnParmRef
        self.ReturnParmRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FailedVerifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FailedVerifierType.subclass:
            return FailedVerifierType.subclass(*args_, **kwargs_)
        else:
            return FailedVerifierType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ReturnParmRef(self):
        return self.ReturnParmRef

    def set_ReturnParmRef(self, ReturnParmRef):
        self.ReturnParmRef = ReturnParmRef

    def hasContent_(self):
        if (
                self.ReturnParmRef is not None or
                super(FailedVerifierType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FailedVerifierType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FailedVerifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FailedVerifierType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FailedVerifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FailedVerifierType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FailedVerifierType'):
        super(FailedVerifierType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                         name_='FailedVerifierType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FailedVerifierType',
                       fromsubclass_=False, pretty_print=True):
        super(FailedVerifierType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                       pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReturnParmRef is not None:
            namespaceprefix_ = self.ReturnParmRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ReturnParmRef_nsprefix_) else ''
            self.ReturnParmRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReturnParmRef',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(FailedVerifierType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ReturnParmRef':
            class_obj_ = self.get_class_obj_(child_, ParameterRefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReturnParmRef = obj_
            obj_.original_tagname_ = 'ReturnParmRef'
        super(FailedVerifierType, self).buildChildren(child_, node, nodeName_, True)


# end class FailedVerifierType


class ExecutionVerifierType(CommandVerifierType):
    """A verifier that indicates that the command is being executed. An
    optional Element indicates how far along the command has progressed
    either as a fixed value or an (possibly scaled) ParameterInstance
    value."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CommandVerifierType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 ComparisonList=None, ContainerRef=None, ParameterValueChange=None, CustomAlgorithm=None,
                 BooleanExpression=None, Comparison=None, CheckWindow=None, CheckWindowAlgorithms=None,
                 PercentComplete=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ExecutionVerifierType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                    ComparisonList, ContainerRef, ParameterValueChange, CustomAlgorithm,
                                                    BooleanExpression, Comparison, CheckWindow, CheckWindowAlgorithms,
                                                    **kwargs_)
        self.PercentComplete = PercentComplete
        self.PercentComplete_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExecutionVerifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExecutionVerifierType.subclass:
            return ExecutionVerifierType.subclass(*args_, **kwargs_)
        else:
            return ExecutionVerifierType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_PercentComplete(self):
        return self.PercentComplete

    def set_PercentComplete(self, PercentComplete):
        self.PercentComplete = PercentComplete

    def hasContent_(self):
        if (
                self.PercentComplete is not None or
                super(ExecutionVerifierType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExecutionVerifierType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExecutionVerifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ExecutionVerifierType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExecutionVerifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExecutionVerifierType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExecutionVerifierType'):
        super(ExecutionVerifierType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                            name_='ExecutionVerifierType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExecutionVerifierType',
                       fromsubclass_=False, pretty_print=True):
        super(ExecutionVerifierType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                          pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PercentComplete is not None:
            namespaceprefix_ = self.PercentComplete_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.PercentComplete_nsprefix_) else ''
            self.PercentComplete.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PercentComplete',
                                        pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(ExecutionVerifierType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PercentComplete':
            obj_ = PercentCompleteType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PercentComplete = obj_
            obj_.original_tagname_ = 'PercentComplete'
        super(ExecutionVerifierType, self).buildChildren(child_, node, nodeName_, True)


# end class ExecutionVerifierType


class CompleteVerifierType(CommandVerifierType):
    """A possible set of verifiers that all must be true for the command be
    considered completed."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CommandVerifierType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 ComparisonList=None, ContainerRef=None, ParameterValueChange=None, CustomAlgorithm=None,
                 BooleanExpression=None, Comparison=None, CheckWindow=None, CheckWindowAlgorithms=None,
                 ReturnParmRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CompleteVerifierType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                   ComparisonList, ContainerRef, ParameterValueChange, CustomAlgorithm,
                                                   BooleanExpression, Comparison, CheckWindow, CheckWindowAlgorithms,
                                                   **kwargs_)
        self.ReturnParmRef = ReturnParmRef
        self.ReturnParmRef_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompleteVerifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompleteVerifierType.subclass:
            return CompleteVerifierType.subclass(*args_, **kwargs_)
        else:
            return CompleteVerifierType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ReturnParmRef(self):
        return self.ReturnParmRef

    def set_ReturnParmRef(self, ReturnParmRef):
        self.ReturnParmRef = ReturnParmRef

    def hasContent_(self):
        if (
                self.ReturnParmRef is not None or
                super(CompleteVerifierType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CompleteVerifierType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompleteVerifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CompleteVerifierType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompleteVerifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CompleteVerifierType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CompleteVerifierType'):
        super(CompleteVerifierType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='CompleteVerifierType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CompleteVerifierType',
                       fromsubclass_=False, pretty_print=True):
        super(CompleteVerifierType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReturnParmRef is not None:
            namespaceprefix_ = self.ReturnParmRef_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ReturnParmRef_nsprefix_) else ''
            self.ReturnParmRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReturnParmRef',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(CompleteVerifierType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ReturnParmRef':
            class_obj_ = self.get_class_obj_(child_, ParameterRefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReturnParmRef = obj_
            obj_.original_tagname_ = 'ReturnParmRef'
        super(CompleteVerifierType, self).buildChildren(child_, node, nodeName_, True)


# end class CompleteVerifierType


class AcceptedVerifierType(CommandVerifierType):
    """A verifier that means the SpaceSystem has accepted the command"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CommandVerifierType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 ComparisonList=None, ContainerRef=None, ParameterValueChange=None, CustomAlgorithm=None,
                 BooleanExpression=None, Comparison=None, CheckWindow=None, CheckWindowAlgorithms=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AcceptedVerifierType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                   ComparisonList, ContainerRef, ParameterValueChange, CustomAlgorithm,
                                                   BooleanExpression, Comparison, CheckWindow, CheckWindowAlgorithms,
                                                   **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AcceptedVerifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AcceptedVerifierType.subclass:
            return AcceptedVerifierType.subclass(*args_, **kwargs_)
        else:
            return AcceptedVerifierType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(AcceptedVerifierType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AcceptedVerifierType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AcceptedVerifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AcceptedVerifierType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AcceptedVerifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AcceptedVerifierType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AcceptedVerifierType'):
        super(AcceptedVerifierType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='AcceptedVerifierType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AcceptedVerifierType',
                       fromsubclass_=False, pretty_print=True):
        super(AcceptedVerifierType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(AcceptedVerifierType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(AcceptedVerifierType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class AcceptedVerifierType


class StringArgumentType(ArgumentStringDataType):
    """Describes a string parameter type. Three forms are supported: fixed
    length, variable length and variable length using a prefix. See
    StringDataEncodingType and StringDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentStringDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, restrictionPattern=None, characterWidth=None,
                 SizeRangeInCharacters=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(StringArgumentType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                 baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                 IntegerDataEncoding, StringDataEncoding, initialValue,
                                                 restrictionPattern, characterWidth, SizeRangeInCharacters, **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringArgumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringArgumentType.subclass:
            return StringArgumentType.subclass(*args_, **kwargs_)
        else:
            return StringArgumentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(StringArgumentType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringArgumentType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringArgumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StringArgumentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringArgumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringArgumentType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StringArgumentType'):
        super(StringArgumentType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                         name_='StringArgumentType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringArgumentType',
                       fromsubclass_=False, pretty_print=True):
        super(StringArgumentType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                       pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(StringArgumentType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(StringArgumentType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class StringArgumentType


class RelativeTimeArgumentType(ArgumentRelativeTimeDataType):
    """Describes a relative time argument type. Relative time parameters are
    time offsets (e.g. 10 second, 1.24 milliseconds, etc.) See
    IntegerDataEncodingType, FloatDataEncoding and RelativeTimeDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentRelativeTimeDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, Encoding=None, ReferenceTime=None, initialValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RelativeTimeArgumentType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                       name, baseType, Encoding, ReferenceTime, initialValue, **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelativeTimeArgumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelativeTimeArgumentType.subclass:
            return RelativeTimeArgumentType.subclass(*args_, **kwargs_)
        else:
            return RelativeTimeArgumentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(RelativeTimeArgumentType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RelativeTimeArgumentType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RelativeTimeArgumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RelativeTimeArgumentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RelativeTimeArgumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RelativeTimeArgumentType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='RelativeTimeArgumentType'):
        super(RelativeTimeArgumentType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                               name_='RelativeTimeArgumentType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RelativeTimeArgumentType',
                       fromsubclass_=False, pretty_print=True):
        super(RelativeTimeArgumentType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                             True, pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(RelativeTimeArgumentType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(RelativeTimeArgumentType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class RelativeTimeArgumentType


class IntegerArgumentType(ArgumentIntegerDataType):
    """Describes an integer argument type. Several encodings supported.
    Calibrated integer to integer relationships should be described with
    this data type. Use the integer data encoding to define calibrators.
    Joins float as one of the numerics. See IntegerDataEncoding and
    IntegerDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentIntegerDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, sizeInBits='32', signed=True, ToString=None,
                 ValidRangeSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IntegerArgumentType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                  baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                  IntegerDataEncoding, StringDataEncoding, initialValue, sizeInBits,
                                                  signed, ToString, **kwargs_)
        self.ValidRangeSet = ValidRangeSet
        self.ValidRangeSet_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntegerArgumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntegerArgumentType.subclass:
            return IntegerArgumentType.subclass(*args_, **kwargs_)
        else:
            return IntegerArgumentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ValidRangeSet(self):
        return self.ValidRangeSet

    def set_ValidRangeSet(self, ValidRangeSet):
        self.ValidRangeSet = ValidRangeSet

    def hasContent_(self):
        if (
                self.ValidRangeSet is not None or
                super(IntegerArgumentType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IntegerArgumentType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IntegerArgumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IntegerArgumentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IntegerArgumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IntegerArgumentType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IntegerArgumentType'):
        super(IntegerArgumentType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                          name_='IntegerArgumentType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IntegerArgumentType',
                       fromsubclass_=False, pretty_print=True):
        super(IntegerArgumentType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                        pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ValidRangeSet is not None:
            namespaceprefix_ = self.ValidRangeSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ValidRangeSet_nsprefix_) else ''
            self.ValidRangeSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ValidRangeSet',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(IntegerArgumentType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ValidRangeSet':
            obj_ = ValidIntegerRangeSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValidRangeSet = obj_
            obj_.original_tagname_ = 'ValidRangeSet'
        super(IntegerArgumentType, self).buildChildren(child_, node, nodeName_, True)


# end class IntegerArgumentType


class FloatArgumentType(ArgumentFloatDataType):
    """Describe a floating point argument type. Several encodings are
    supported. Calibrated integer to float relationships should be
    described with this data type. Use the data encoding to define
    calibrators. Joins integer as one of the numerics. See
    FloatDataEncodingType, IntegerDataEncodingType and FloatDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentFloatDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, sizeInBits='32', ToString=None, ValidRangeSet=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FloatArgumentType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                IntegerDataEncoding, StringDataEncoding, initialValue, sizeInBits,
                                                ToString, **kwargs_)
        self.ValidRangeSet = ValidRangeSet
        self.ValidRangeSet_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatArgumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatArgumentType.subclass:
            return FloatArgumentType.subclass(*args_, **kwargs_)
        else:
            return FloatArgumentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ValidRangeSet(self):
        return self.ValidRangeSet

    def set_ValidRangeSet(self, ValidRangeSet):
        self.ValidRangeSet = ValidRangeSet

    def hasContent_(self):
        if (
                self.ValidRangeSet is not None or
                super(FloatArgumentType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FloatArgumentType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FloatArgumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FloatArgumentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FloatArgumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FloatArgumentType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FloatArgumentType'):
        super(FloatArgumentType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                        name_='FloatArgumentType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FloatArgumentType',
                       fromsubclass_=False, pretty_print=True):
        super(FloatArgumentType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                      pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ValidRangeSet is not None:
            namespaceprefix_ = self.ValidRangeSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ValidRangeSet_nsprefix_) else ''
            self.ValidRangeSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ValidRangeSet',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(FloatArgumentType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ValidRangeSet':
            obj_ = ValidFloatRangeSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ValidRangeSet = obj_
            obj_.original_tagname_ = 'ValidRangeSet'
        super(FloatArgumentType, self).buildChildren(child_, node, nodeName_, True)


# end class FloatArgumentType


class EnumeratedArgumentType(ArgumentEnumeratedDataType):
    """Describes an enumerated argument type. The enumeration list consists of
    label/value pairs. See EnumerationListType, IntegerDataEncodingType and
    EnumeratedDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentEnumeratedDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, EnumerationList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EnumeratedArgumentType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                     name, baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                     IntegerDataEncoding, StringDataEncoding, initialValue,
                                                     EnumerationList, **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnumeratedArgumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnumeratedArgumentType.subclass:
            return EnumeratedArgumentType.subclass(*args_, **kwargs_)
        else:
            return EnumeratedArgumentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(EnumeratedArgumentType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnumeratedArgumentType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnumeratedArgumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EnumeratedArgumentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnumeratedArgumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EnumeratedArgumentType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EnumeratedArgumentType'):
        super(EnumeratedArgumentType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                             name_='EnumeratedArgumentType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnumeratedArgumentType',
                       fromsubclass_=False, pretty_print=True):
        super(EnumeratedArgumentType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                           pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(EnumeratedArgumentType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(EnumeratedArgumentType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class EnumeratedArgumentType


class CommandContainerType(ContainerType):
    """Describe a MetaCommand command container. The command container may
    contain arguments, parameters, other basic containers, and fixed
    values. Arguments are supplied by the user of a commanding application;
    parameters are supplied by the controlling system. Parameters and
    arguments map source data types to encodings. See MetaCommandType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ContainerType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 DefaultRateInStream=None, RateInStreamSet=None, BinaryEncoding=None, EntryList=None,
                 BaseContainer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CommandContainerType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                   DefaultRateInStream, RateInStreamSet, BinaryEncoding, **kwargs_)
        self.EntryList = EntryList
        self.EntryList_nsprefix_ = None
        self.BaseContainer = BaseContainer
        self.BaseContainer_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommandContainerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommandContainerType.subclass:
            return CommandContainerType.subclass(*args_, **kwargs_)
        else:
            return CommandContainerType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_EntryList(self) -> 'CommandContainerEntryListType':
        return self.EntryList

    def set_EntryList(self, EntryList):
        self.EntryList = EntryList

    def get_BaseContainer(self):
        return self.BaseContainer

    def set_BaseContainer(self, BaseContainer):
        self.BaseContainer = BaseContainer

    def hasContent_(self):
        if (
                self.EntryList is not None or
                self.BaseContainer is not None or
                super(CommandContainerType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CommandContainerType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CommandContainerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CommandContainerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CommandContainerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CommandContainerType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CommandContainerType'):
        super(CommandContainerType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='CommandContainerType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CommandContainerType',
                       fromsubclass_=False, pretty_print=True):
        super(CommandContainerType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EntryList is not None:
            namespaceprefix_ = self.EntryList_nsprefix_ + ':' if (UseCapturedNS_ and self.EntryList_nsprefix_) else ''
            self.EntryList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EntryList',
                                  pretty_print=pretty_print)
        if self.BaseContainer is not None:
            namespaceprefix_ = self.BaseContainer_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BaseContainer_nsprefix_) else ''
            self.BaseContainer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BaseContainer',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(CommandContainerType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EntryList':
            obj_ = CommandContainerEntryListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EntryList = obj_
            obj_.original_tagname_ = 'EntryList'
        elif nodeName_ == 'BaseContainer':
            obj_ = BaseContainerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BaseContainer = obj_
            obj_.original_tagname_ = 'BaseContainer'
        super(CommandContainerType, self).buildChildren(child_, node, nodeName_, True)


# end class CommandContainerType


class BooleanArgumentType(ArgumentBooleanDataType):
    """Defines a boolean argument type which has two values only: ‘True’ (1) or
    ‘False’ (0). The values one and zero may be mapped to a specific string
    using the attributes oneStringValue and zeroStringValue. This type is a
    simplified form of the EnumeratedDataType. See IntegerDataEncoding and
    BooleanDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentBooleanDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, oneStringValue='True', zeroStringValue='False',
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BooleanArgumentType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                  baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                  IntegerDataEncoding, StringDataEncoding, initialValue, oneStringValue,
                                                  zeroStringValue, **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BooleanArgumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BooleanArgumentType.subclass:
            return BooleanArgumentType.subclass(*args_, **kwargs_)
        else:
            return BooleanArgumentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(BooleanArgumentType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BooleanArgumentType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BooleanArgumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BooleanArgumentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanArgumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BooleanArgumentType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BooleanArgumentType'):
        super(BooleanArgumentType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                          name_='BooleanArgumentType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BooleanArgumentType',
                       fromsubclass_=False, pretty_print=True):
        super(BooleanArgumentType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                        pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(BooleanArgumentType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BooleanArgumentType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class BooleanArgumentType


class BinaryArgumentType(ArgumentBinaryDataType):
    """Defines a binary engineering/calibrated argument type (often called
    “blob type”). The binary data may be of fixed or variable length, and
    has an optional encoding and decoding algorithm that may be defined to
    transform the data between space and ground. See
    BinaryDataEncodingType, IntegerValueType, InputAlgorithmType, and
    BinaryDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ArgumentBinaryDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BinaryArgumentType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                 baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                 IntegerDataEncoding, StringDataEncoding, initialValue, **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BinaryArgumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BinaryArgumentType.subclass:
            return BinaryArgumentType.subclass(*args_, **kwargs_)
        else:
            return BinaryArgumentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (
                super(BinaryArgumentType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BinaryArgumentType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BinaryArgumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BinaryArgumentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BinaryArgumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BinaryArgumentType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BinaryArgumentType'):
        super(BinaryArgumentType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                         name_='BinaryArgumentType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BinaryArgumentType',
                       fromsubclass_=False, pretty_print=True):
        super(BinaryArgumentType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                       pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(BinaryArgumentType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BinaryArgumentType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class BinaryArgumentType


class TimeAssociationType(ParameterInstanceRefType):
    """Describes a time association consisting of an instance of an absolute
    time parameter (parameterRef) and this entry. Because telemetry
    parameter instances are oftentimes "time-tagged" with a timing signal
    either provided on the ground or on the space system. This data element
    allows one to specify which of possibly many AbsoluteTimeParameters to
    use to "time-tag" parameter instances with. See
    AbsoluteTimeParameterType.If true, then the current value of the
    AbsoluteTime will be projected to current time. In other words, if the
    value of the AbsoluteTime parameter was set 10 seconds ago, then 10
    seconds will be added to its value before associating this time with
    the parameter.The offset is used to supply a relative time offset from
    the time association and to this parameterSpecify the units the offset
    is in, the default is si_second."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ParameterInstanceRefType

    def __init__(self, parameterRef=None, instance=0, useCalibratedValue=True, interpolateTime=True, offset=None,
                 unit='si_second', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TimeAssociationType, self).__init__(parameterRef, instance, useCalibratedValue, **kwargs_)
        self.interpolateTime = _cast(bool, interpolateTime)
        self.interpolateTime_nsprefix_ = None
        self.offset = _cast(float, offset)
        self.offset_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeAssociationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeAssociationType.subclass:
            return TimeAssociationType.subclass(*args_, **kwargs_)
        else:
            return TimeAssociationType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_interpolateTime(self):
        return self.interpolateTime

    def set_interpolateTime(self, interpolateTime):
        self.interpolateTime = interpolateTime

    def get_offset(self):
        return self.offset

    def set_offset(self, offset):
        self.offset = offset

    def get_unit(self):
        return self.unit

    def set_unit(self, unit):
        self.unit = unit

    def validate_TimeAssociationUnitType(self, value):
        # Validate type xtce:TimeAssociationUnitType, a restriction on string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['si_nanosecond', 'si_microsecond', 'si_millsecond', 'si_second', 'minute', 'day',
                            'julianYear']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TimeAssociationUnitType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                super(TimeAssociationType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeAssociationType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeAssociationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeAssociationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeAssociationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeAssociationType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeAssociationType'):
        super(TimeAssociationType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                          name_='TimeAssociationType')
        if not self.interpolateTime and 'interpolateTime' not in already_processed:
            already_processed.add('interpolateTime')
            outfile.write(
                ' interpolateTime="%s"' % self.gds_format_boolean(self.interpolateTime, input_name='interpolateTime'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_double(self.offset, input_name='offset'))
        if self.unit != "si_second" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(
                ' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeAssociationType',
                       fromsubclass_=False, pretty_print=True):
        super(TimeAssociationType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                        pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interpolateTime', node)
        if value is not None and 'interpolateTime' not in already_processed:
            already_processed.add('interpolateTime')
            if value in ('true', '1'):
                self.interpolateTime = True
            elif value in ('false', '0'):
                self.interpolateTime = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            value = self.gds_parse_double(value, node, 'offset')
            self.offset = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_TimeAssociationUnitType(self.unit)  # validate type TimeAssociationUnitType
        super(TimeAssociationType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TimeAssociationType, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class TimeAssociationType


class RelativeTimeParameterType(RelativeTimeDataType):
    """Describes a relative time parameter type. Relative time parameters are
    time offsets (e.g. 10 second, 1.24 milliseconds, etc.) See
    IntegerDataEncodingType, FloatDataEncoding and RelativeTimeDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RelativeTimeDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, Encoding=None, ReferenceTime=None, initialValue=None, DefaultAlarm=None,
                 ContextAlarmList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RelativeTimeParameterType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                        name, baseType, Encoding, ReferenceTime, initialValue,
                                                        **kwargs_)
        self.DefaultAlarm = DefaultAlarm
        self.DefaultAlarm_nsprefix_ = None
        self.ContextAlarmList = ContextAlarmList
        self.ContextAlarmList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelativeTimeParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelativeTimeParameterType.subclass:
            return RelativeTimeParameterType.subclass(*args_, **kwargs_)
        else:
            return RelativeTimeParameterType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DefaultAlarm(self):
        return self.DefaultAlarm

    def set_DefaultAlarm(self, DefaultAlarm):
        self.DefaultAlarm = DefaultAlarm

    def get_ContextAlarmList(self):
        return self.ContextAlarmList

    def set_ContextAlarmList(self, ContextAlarmList):
        self.ContextAlarmList = ContextAlarmList

    def hasContent_(self):
        if (
                self.DefaultAlarm is not None or
                self.ContextAlarmList is not None or
                super(RelativeTimeParameterType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RelativeTimeParameterType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RelativeTimeParameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RelativeTimeParameterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RelativeTimeParameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RelativeTimeParameterType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='RelativeTimeParameterType'):
        super(RelativeTimeParameterType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                                name_='RelativeTimeParameterType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RelativeTimeParameterType',
                       fromsubclass_=False, pretty_print=True):
        super(RelativeTimeParameterType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                              True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultAlarm is not None:
            namespaceprefix_ = self.DefaultAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DefaultAlarm_nsprefix_) else ''
            self.DefaultAlarm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DefaultAlarm',
                                     pretty_print=pretty_print)
        if self.ContextAlarmList is not None:
            namespaceprefix_ = self.ContextAlarmList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextAlarmList_nsprefix_) else ''
            self.ContextAlarmList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextAlarmList',
                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(RelativeTimeParameterType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DefaultAlarm':
            class_obj_ = self.get_class_obj_(child_, TimeAlarmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DefaultAlarm = obj_
            obj_.original_tagname_ = 'DefaultAlarm'
        elif nodeName_ == 'ContextAlarmList':
            obj_ = TimeContextAlarmListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextAlarmList = obj_
            obj_.original_tagname_ = 'ContextAlarmList'
        super(RelativeTimeParameterType, self).buildChildren(child_, node, nodeName_, True)


# end class RelativeTimeParameterType


class StringParameterType(StringDataType):
    """Describes a string parameter type. Three forms are supported: fixed
    length, variable length and variable length using a prefix. See
    StringDataEncodingType and StringDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = StringDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, restrictionPattern=None, characterWidth=None,
                 SizeRangeInCharacters=None, DefaultAlarm=None, ContextAlarmList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(StringParameterType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                  baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                  IntegerDataEncoding, StringDataEncoding, initialValue,
                                                  restrictionPattern, characterWidth, SizeRangeInCharacters, **kwargs_)
        self.DefaultAlarm = DefaultAlarm
        self.DefaultAlarm_nsprefix_ = None
        self.ContextAlarmList = ContextAlarmList
        self.ContextAlarmList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringParameterType.subclass:
            return StringParameterType.subclass(*args_, **kwargs_)
        else:
            return StringParameterType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DefaultAlarm(self):
        return self.DefaultAlarm

    def set_DefaultAlarm(self, DefaultAlarm):
        self.DefaultAlarm = DefaultAlarm

    def get_ContextAlarmList(self):
        return self.ContextAlarmList

    def set_ContextAlarmList(self, ContextAlarmList):
        self.ContextAlarmList = ContextAlarmList

    def hasContent_(self):
        if (
                self.DefaultAlarm is not None or
                self.ContextAlarmList is not None or
                super(StringParameterType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringParameterType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringParameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StringParameterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringParameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringParameterType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StringParameterType'):
        super(StringParameterType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                          name_='StringParameterType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringParameterType',
                       fromsubclass_=False, pretty_print=True):
        super(StringParameterType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                        pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultAlarm is not None:
            namespaceprefix_ = self.DefaultAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DefaultAlarm_nsprefix_) else ''
            self.DefaultAlarm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DefaultAlarm',
                                     pretty_print=pretty_print)
        if self.ContextAlarmList is not None:
            namespaceprefix_ = self.ContextAlarmList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextAlarmList_nsprefix_) else ''
            self.ContextAlarmList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextAlarmList',
                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(StringParameterType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DefaultAlarm':
            class_obj_ = self.get_class_obj_(child_, StringAlarmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DefaultAlarm = obj_
            obj_.original_tagname_ = 'DefaultAlarm'
        elif nodeName_ == 'ContextAlarmList':
            obj_ = StringContextAlarmListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextAlarmList = obj_
            obj_.original_tagname_ = 'ContextAlarmList'
        super(StringParameterType, self).buildChildren(child_, node, nodeName_, True)


# end class StringParameterType


class IntegerParameterType(IntegerDataType):
    """Describe an integer parameter type. Several are supported. Calibrated
    integer to integer relationships should be described with this data
    type. Use the integer data encoding to define calibrators. Joins float
    as one of the numerics. See IntegerDataEncoding and IntegerDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IntegerDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, sizeInBits='32', signed=True, ToString=None,
                 ValidRange=None, DefaultAlarm=None, ContextAlarmList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IntegerParameterType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                   baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                   IntegerDataEncoding, StringDataEncoding, initialValue, sizeInBits,
                                                   signed, ToString, ValidRange, **kwargs_)
        self.DefaultAlarm = DefaultAlarm
        self.DefaultAlarm_nsprefix_ = None
        self.ContextAlarmList = ContextAlarmList
        self.ContextAlarmList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntegerParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntegerParameterType.subclass:
            return IntegerParameterType.subclass(*args_, **kwargs_)
        else:
            return IntegerParameterType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DefaultAlarm(self):
        return self.DefaultAlarm

    def set_DefaultAlarm(self, DefaultAlarm):
        self.DefaultAlarm = DefaultAlarm

    def get_ContextAlarmList(self):
        return self.ContextAlarmList

    def set_ContextAlarmList(self, ContextAlarmList):
        self.ContextAlarmList = ContextAlarmList

    def hasContent_(self):
        if (
                self.DefaultAlarm is not None or
                self.ContextAlarmList is not None or
                super(IntegerParameterType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IntegerParameterType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IntegerParameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IntegerParameterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IntegerParameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IntegerParameterType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IntegerParameterType'):
        super(IntegerParameterType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='IntegerParameterType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IntegerParameterType',
                       fromsubclass_=False, pretty_print=True):
        super(IntegerParameterType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultAlarm is not None:
            namespaceprefix_ = self.DefaultAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DefaultAlarm_nsprefix_) else ''
            self.DefaultAlarm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DefaultAlarm',
                                     pretty_print=pretty_print)
        if self.ContextAlarmList is not None:
            namespaceprefix_ = self.ContextAlarmList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextAlarmList_nsprefix_) else ''
            self.ContextAlarmList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextAlarmList',
                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(IntegerParameterType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DefaultAlarm':
            class_obj_ = self.get_class_obj_(child_, NumericAlarmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DefaultAlarm = obj_
            obj_.original_tagname_ = 'DefaultAlarm'
        elif nodeName_ == 'ContextAlarmList':
            obj_ = NumericContextAlarmListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextAlarmList = obj_
            obj_.original_tagname_ = 'ContextAlarmList'
        super(IntegerParameterType, self).buildChildren(child_, node, nodeName_, True)


# end class IntegerParameterType


class FloatParameterType(FloatDataType):
    """Describe a floating point parameter type. Several encodings are
    supported. Calibrated integer to float relationships should be
    described with this data type. Use the data encoding to define
    calibrators. Joins integer as one of the numerics. See
    FloatDataEncodingType, IntegerDataEncodingType and FloatDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FloatDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, sizeInBits='32', ToString=None, ValidRange=None,
                 DefaultAlarm=None, ContextAlarmList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FloatParameterType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                 baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                 IntegerDataEncoding, StringDataEncoding, initialValue, sizeInBits,
                                                 ToString, ValidRange, **kwargs_)
        self.DefaultAlarm = DefaultAlarm
        self.DefaultAlarm_nsprefix_ = None
        self.ContextAlarmList = ContextAlarmList
        self.ContextAlarmList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatParameterType.subclass:
            return FloatParameterType.subclass(*args_, **kwargs_)
        else:
            return FloatParameterType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DefaultAlarm(self):
        return self.DefaultAlarm

    def set_DefaultAlarm(self, DefaultAlarm):
        self.DefaultAlarm = DefaultAlarm

    def get_ContextAlarmList(self):
        return self.ContextAlarmList

    def set_ContextAlarmList(self, ContextAlarmList):
        self.ContextAlarmList = ContextAlarmList

    def hasContent_(self):
        if (
                self.DefaultAlarm is not None or
                self.ContextAlarmList is not None or
                super(FloatParameterType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FloatParameterType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FloatParameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FloatParameterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FloatParameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FloatParameterType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FloatParameterType'):
        super(FloatParameterType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                         name_='FloatParameterType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FloatParameterType',
                       fromsubclass_=False, pretty_print=True):
        super(FloatParameterType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                       pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultAlarm is not None:
            namespaceprefix_ = self.DefaultAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DefaultAlarm_nsprefix_) else ''
            self.DefaultAlarm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DefaultAlarm',
                                     pretty_print=pretty_print)
        if self.ContextAlarmList is not None:
            namespaceprefix_ = self.ContextAlarmList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextAlarmList_nsprefix_) else ''
            self.ContextAlarmList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextAlarmList',
                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(FloatParameterType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DefaultAlarm':
            class_obj_ = self.get_class_obj_(child_, NumericAlarmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DefaultAlarm = obj_
            obj_.original_tagname_ = 'DefaultAlarm'
        elif nodeName_ == 'ContextAlarmList':
            obj_ = NumericContextAlarmListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextAlarmList = obj_
            obj_.original_tagname_ = 'ContextAlarmList'
        super(FloatParameterType, self).buildChildren(child_, node, nodeName_, True)


# end class FloatParameterType


class EnumeratedParameterType(EnumeratedDataType):
    """Describe an enumerated parameter type. The enumeration list consists of
    label/value pairs. See EnumerationListType, IntegerDataEncodingType and
    EnumeratedDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = EnumeratedDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, EnumerationList=None, DefaultAlarm=None,
                 ContextAlarmList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EnumeratedParameterType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet,
                                                      name, baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                      IntegerDataEncoding, StringDataEncoding, initialValue,
                                                      EnumerationList, **kwargs_)
        self.DefaultAlarm = DefaultAlarm
        self.DefaultAlarm_nsprefix_ = None
        self.ContextAlarmList = ContextAlarmList
        self.ContextAlarmList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnumeratedParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnumeratedParameterType.subclass:
            return EnumeratedParameterType.subclass(*args_, **kwargs_)
        else:
            return EnumeratedParameterType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DefaultAlarm(self):
        return self.DefaultAlarm

    def set_DefaultAlarm(self, DefaultAlarm):
        self.DefaultAlarm = DefaultAlarm

    def get_ContextAlarmList(self):
        return self.ContextAlarmList

    def set_ContextAlarmList(self, ContextAlarmList):
        self.ContextAlarmList = ContextAlarmList

    def hasContent_(self):
        if (
                self.DefaultAlarm is not None or
                self.ContextAlarmList is not None or
                super(EnumeratedParameterType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnumeratedParameterType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnumeratedParameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EnumeratedParameterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnumeratedParameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EnumeratedParameterType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EnumeratedParameterType'):
        super(EnumeratedParameterType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                              name_='EnumeratedParameterType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnumeratedParameterType',
                       fromsubclass_=False, pretty_print=True):
        super(EnumeratedParameterType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_,
                                                            True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultAlarm is not None:
            namespaceprefix_ = self.DefaultAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DefaultAlarm_nsprefix_) else ''
            self.DefaultAlarm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DefaultAlarm',
                                     pretty_print=pretty_print)
        if self.ContextAlarmList is not None:
            namespaceprefix_ = self.ContextAlarmList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextAlarmList_nsprefix_) else ''
            self.ContextAlarmList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextAlarmList',
                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(EnumeratedParameterType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DefaultAlarm':
            class_obj_ = self.get_class_obj_(child_, EnumerationAlarmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DefaultAlarm = obj_
            obj_.original_tagname_ = 'DefaultAlarm'
        elif nodeName_ == 'ContextAlarmList':
            obj_ = EnumerationContextAlarmListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextAlarmList = obj_
            obj_.original_tagname_ = 'ContextAlarmList'
        super(EnumeratedParameterType, self).buildChildren(child_, node, nodeName_, True)


# end class EnumeratedParameterType


class BooleanParameterType(BooleanDataType):
    """Describe a boolean parameter type which has two values only: ‘True’ (1)
    or ‘False’ (0). The values one and zero may be mapped to a specific
    string using the attributes oneStringValue and zeroStringValue. This
    type is a simplified form of the EnumeratedDataType. See
    IntegerDataEncoding and BooleanDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BooleanDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, oneStringValue='True', zeroStringValue='False',
                 DefaultAlarm=None, ContextAlarmList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BooleanParameterType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                   baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                   IntegerDataEncoding, StringDataEncoding, initialValue,
                                                   oneStringValue, zeroStringValue, **kwargs_)
        self.DefaultAlarm = DefaultAlarm
        self.DefaultAlarm_nsprefix_ = None
        self.ContextAlarmList = ContextAlarmList
        self.ContextAlarmList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BooleanParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BooleanParameterType.subclass:
            return BooleanParameterType.subclass(*args_, **kwargs_)
        else:
            return BooleanParameterType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DefaultAlarm(self):
        return self.DefaultAlarm

    def set_DefaultAlarm(self, DefaultAlarm):
        self.DefaultAlarm = DefaultAlarm

    def get_ContextAlarmList(self):
        return self.ContextAlarmList

    def set_ContextAlarmList(self, ContextAlarmList):
        self.ContextAlarmList = ContextAlarmList

    def hasContent_(self):
        if (
                self.DefaultAlarm is not None or
                self.ContextAlarmList is not None or
                super(BooleanParameterType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BooleanParameterType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BooleanParameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BooleanParameterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanParameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BooleanParameterType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BooleanParameterType'):
        super(BooleanParameterType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='BooleanParameterType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BooleanParameterType',
                       fromsubclass_=False, pretty_print=True):
        super(BooleanParameterType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultAlarm is not None:
            namespaceprefix_ = self.DefaultAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DefaultAlarm_nsprefix_) else ''
            self.DefaultAlarm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DefaultAlarm',
                                     pretty_print=pretty_print)
        if self.ContextAlarmList is not None:
            namespaceprefix_ = self.ContextAlarmList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ContextAlarmList_nsprefix_) else ''
            self.ContextAlarmList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContextAlarmList',
                                         pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(BooleanParameterType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DefaultAlarm':
            class_obj_ = self.get_class_obj_(child_, BooleanAlarmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DefaultAlarm = obj_
            obj_.original_tagname_ = 'DefaultAlarm'
        elif nodeName_ == 'ContextAlarmList':
            obj_ = BooleanContextAlarmListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContextAlarmList = obj_
            obj_.original_tagname_ = 'ContextAlarmList'
        super(BooleanParameterType, self).buildChildren(child_, node, nodeName_, True)


# end class BooleanParameterType


class BinaryParameterType(BinaryDataType):
    """Describe a binary engineering/calibrated parameter type (sometimes
    called a “blob type”). It may be of fixed or variable length, and has
    an optional encoding and decoding algorithm that may be defined to
    transform the data between space and ground. See
    BinaryDataEncodingType, IntegerValueType, InputAlgorithmType and
    BinaryDataType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BinaryDataType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 baseType=None, UnitSet=None, BinaryDataEncoding=None, FloatDataEncoding=None, IntegerDataEncoding=None,
                 StringDataEncoding=None, initialValue=None, DefaultAlarm=None, BinaryContextAlarmList=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BinaryParameterType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                  baseType, UnitSet, BinaryDataEncoding, FloatDataEncoding,
                                                  IntegerDataEncoding, StringDataEncoding, initialValue, **kwargs_)
        self.DefaultAlarm = DefaultAlarm
        self.DefaultAlarm_nsprefix_ = None
        self.BinaryContextAlarmList = BinaryContextAlarmList
        self.BinaryContextAlarmList_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BinaryParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BinaryParameterType.subclass:
            return BinaryParameterType.subclass(*args_, **kwargs_)
        else:
            return BinaryParameterType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_DefaultAlarm(self):
        return self.DefaultAlarm

    def set_DefaultAlarm(self, DefaultAlarm):
        self.DefaultAlarm = DefaultAlarm

    def get_BinaryContextAlarmList(self):
        return self.BinaryContextAlarmList

    def set_BinaryContextAlarmList(self, BinaryContextAlarmList):
        self.BinaryContextAlarmList = BinaryContextAlarmList

    def hasContent_(self):
        if (
                self.DefaultAlarm is not None or
                self.BinaryContextAlarmList is not None or
                super(BinaryParameterType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BinaryParameterType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BinaryParameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BinaryParameterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BinaryParameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BinaryParameterType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BinaryParameterType'):
        super(BinaryParameterType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                          name_='BinaryParameterType')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BinaryParameterType',
                       fromsubclass_=False, pretty_print=True):
        super(BinaryParameterType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                        pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultAlarm is not None:
            namespaceprefix_ = self.DefaultAlarm_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DefaultAlarm_nsprefix_) else ''
            self.DefaultAlarm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DefaultAlarm',
                                     pretty_print=pretty_print)
        if self.BinaryContextAlarmList is not None:
            namespaceprefix_ = self.BinaryContextAlarmList_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BinaryContextAlarmList_nsprefix_) else ''
            self.BinaryContextAlarmList.export(outfile, level, namespaceprefix_, namespacedef_='',
                                               name_='BinaryContextAlarmList', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(BinaryParameterType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DefaultAlarm':
            obj_ = BinaryAlarmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DefaultAlarm = obj_
            obj_.original_tagname_ = 'DefaultAlarm'
        elif nodeName_ == 'BinaryContextAlarmList':
            obj_ = BinaryContextAlarmListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BinaryContextAlarmList = obj_
            obj_.original_tagname_ = 'BinaryContextAlarmList'
        super(BinaryParameterType, self).buildChildren(child_, node, nodeName_, True)


# end class BinaryParameterType


class SequenceContainerType(ContainerType):
    """Describes the binary layout/packing of data and also related properties,
    including an entry list of parameters, parameter segments, array
    parameters, stream segments, containers, and container segments.
    Sequence containers may extend other sequence containers (see
    BaseContainerType). The parent container’s entries are placed before
    the entries in the child container forming one entry list. An
    inheritance chain may be formed using this mechanism, but only one
    entry list is being created. Sequence containers may be marked as
    "abstract", when this occurs an instance of it cannot itself be
    created. The idle pattern is part of any unallocated space in the
    container. See EntryListType.Abstract container definitions that are
    not instantiated, rather only used as bases to inherit from to create
    specialized container definitions.The idle pattern is part of any
    unallocated space in the container. This is uncommon."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ContainerType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 DefaultRateInStream=None, RateInStreamSet=None, BinaryEncoding=None, abstract=False, idlePattern='0x0',
                 EntryList=None, BaseContainer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SequenceContainerType, self).__init__(shortDescription, LongDescription, AliasSet, AncillaryDataSet, name,
                                                    DefaultRateInStream, RateInStreamSet, BinaryEncoding, **kwargs_)
        self.abstract = _cast(bool, abstract)
        self.abstract_nsprefix_ = None
        self.idlePattern = _cast(None, idlePattern)
        self.idlePattern_nsprefix_ = None
        self.EntryList = EntryList
        self.EntryList_nsprefix_ = None
        self.BaseContainer = BaseContainer
        self.BaseContainer_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SequenceContainerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SequenceContainerType.subclass:
            return SequenceContainerType.subclass(*args_, **kwargs_)
        else:
            return SequenceContainerType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_EntryList(self):
        return self.EntryList

    def set_EntryList(self, EntryList):
        self.EntryList = EntryList

    def get_BaseContainer(self)->BaseContainerType:
        return self.BaseContainer

    def set_BaseContainer(self, BaseContainer):
        self.BaseContainer = BaseContainer

    def get_abstract(self):
        return self.abstract

    def set_abstract(self, abstract):
        self.abstract = abstract

    def get_idlePattern(self):
        return self.idlePattern

    def set_idlePattern(self, idlePattern):
        self.idlePattern = idlePattern

    def validate_FixedIntegerValueType(self, value):
        # Validate type xtce:FixedIntegerValueType, a restriction on None.
        pass

    def hasContent_(self):
        if (
                self.EntryList is not None or
                self.BaseContainer is not None or
                super(SequenceContainerType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SequenceContainerType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SequenceContainerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SequenceContainerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SequenceContainerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SequenceContainerType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SequenceContainerType'):
        super(SequenceContainerType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                            name_='SequenceContainerType')
        if self.abstract and 'abstract' not in already_processed:
            already_processed.add('abstract')
            outfile.write(' abstract="%s"' % self.gds_format_boolean(self.abstract, input_name='abstract'))
        if self.idlePattern != "0x0" and 'idlePattern' not in already_processed:
            already_processed.add('idlePattern')
            outfile.write(' idlePattern=%s' % (quote_attrib(self.idlePattern),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SequenceContainerType',
                       fromsubclass_=False, pretty_print=True):
        super(SequenceContainerType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                          pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EntryList is not None:
            namespaceprefix_ = self.EntryList_nsprefix_ + ':' if (UseCapturedNS_ and self.EntryList_nsprefix_) else ''
            self.EntryList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EntryList',
                                  pretty_print=pretty_print)
        if self.BaseContainer is not None:
            namespaceprefix_ = self.BaseContainer_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.BaseContainer_nsprefix_) else ''
            self.BaseContainer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BaseContainer',
                                      pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('abstract', node)
        if value is not None and 'abstract' not in already_processed:
            already_processed.add('abstract')
            if value in ('true', '1'):
                self.abstract = True
            elif value in ('false', '0'):
                self.abstract = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('idlePattern', node)
        if value is not None and 'idlePattern' not in already_processed:
            already_processed.add('idlePattern')
            self.idlePattern = value
            self.validate_FixedIntegerValueType(self.idlePattern)  # validate type FixedIntegerValueType
        super(SequenceContainerType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EntryList':
            obj_ = EntryListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EntryList = obj_
            obj_.original_tagname_ = 'EntryList'
        elif nodeName_ == 'BaseContainer':
            obj_ = BaseContainerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BaseContainer = obj_
            obj_.original_tagname_ = 'BaseContainer'
        super(SequenceContainerType, self).buildChildren(child_, node, nodeName_, True)


# end class SequenceContainerType


class InputOutputTriggerAlgorithmType(InputOutputAlgorithmType):
    """Input output algorithm is extended with a set of labeled triggers. See
    InputOutputAlgorithmType.First telemetry container from which the
    output parameter should be calculated.Algorithm processing priority. If
    more than one algorithm is triggered by the same container, the lowest
    priority algorithm should be calculated first."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = InputOutputAlgorithmType

    def __init__(self, shortDescription=None, LongDescription=None, AliasSet=None, AncillaryDataSet=None, name=None,
                 AlgorithmText=None, ExternalAlgorithmSet=None, InputSet=None, thread=False, OutputSet=None,
                 triggerContainer=None, priority=None, TriggerSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(InputOutputTriggerAlgorithmType, self).__init__(shortDescription, LongDescription, AliasSet,
                                                              AncillaryDataSet, name, AlgorithmText,
                                                              ExternalAlgorithmSet, InputSet, thread, OutputSet,
                                                              **kwargs_)
        self.triggerContainer = _cast(None, triggerContainer)
        self.triggerContainer_nsprefix_ = None
        self.priority = _cast(int, priority)
        self.priority_nsprefix_ = None
        self.TriggerSet = TriggerSet
        self.TriggerSet_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InputOutputTriggerAlgorithmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InputOutputTriggerAlgorithmType.subclass:
            return InputOutputTriggerAlgorithmType.subclass(*args_, **kwargs_)
        else:
            return InputOutputTriggerAlgorithmType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_TriggerSet(self):
        return self.TriggerSet

    def set_TriggerSet(self, TriggerSet):
        self.TriggerSet = TriggerSet

    def get_triggerContainer(self):
        return self.triggerContainer

    def set_triggerContainer(self, triggerContainer):
        self.triggerContainer = triggerContainer

    def get_priority(self):
        return self.priority

    def set_priority(self, priority):
        self.priority = priority

    def validate_NameReferenceType(self, value):
        # Validate type xtce:NameReferenceType, a restriction on normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NameReferenceType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (
                encode_str_2_3(value), self.validate_NameReferenceType_patterns_,))

    validate_NameReferenceType_patterns_ = [['^(/?(([^./:\\[\\]]+|\\.|\\.\\.)/)*([^./:\\[\\]]+)+)$']]

    def hasContent_(self):
        if (
                self.TriggerSet is not None or
                super(InputOutputTriggerAlgorithmType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InputOutputTriggerAlgorithmType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InputOutputTriggerAlgorithmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InputOutputTriggerAlgorithmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='InputOutputTriggerAlgorithmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='InputOutputTriggerAlgorithmType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='InputOutputTriggerAlgorithmType'):
        super(InputOutputTriggerAlgorithmType, self).exportAttributes(outfile, level, already_processed,
                                                                      namespaceprefix_,
                                                                      name_='InputOutputTriggerAlgorithmType')
        if self.triggerContainer is not None and 'triggerContainer' not in already_processed:
            already_processed.add('triggerContainer')
            outfile.write(' triggerContainer=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.triggerContainer), input_name='triggerContainer')),))
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            outfile.write(' priority="%s"' % self.gds_format_integer(self.priority, input_name='priority'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='InputOutputTriggerAlgorithmType', fromsubclass_=False, pretty_print=True):
        super(InputOutputTriggerAlgorithmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_,
                                                                    name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TriggerSet is not None:
            namespaceprefix_ = self.TriggerSet_nsprefix_ + ':' if (UseCapturedNS_ and self.TriggerSet_nsprefix_) else ''
            self.TriggerSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TriggerSet',
                                   pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('triggerContainer', node)
        if value is not None and 'triggerContainer' not in already_processed:
            already_processed.add('triggerContainer')
            self.triggerContainer = value
            self.validate_NameReferenceType(self.triggerContainer)  # validate type NameReferenceType
        value = find_attr_value_('priority', node)
        if value is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            self.priority = self.gds_parse_integer(value, node, 'priority')
        super(InputOutputTriggerAlgorithmType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TriggerSet':
            obj_ = TriggerSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TriggerSet = obj_
            obj_.original_tagname_ = 'TriggerSet'
        super(InputOutputTriggerAlgorithmType, self).buildChildren(child_, node, nodeName_, True)


# end class InputOutputTriggerAlgorithmType


GDSClassesMapping = {
    'SpaceSystem': SpaceSystemType,
}

USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SpaceSystemType'
        rootClass = SpaceSystemType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SpaceSystemType'
        rootClass = SpaceSystemType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if mapping is None:
        mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping, nsmap_=nsmap)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode = parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SpaceSystemType'
        rootClass = SpaceSystemType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:xtce="http://www.omg.org/spec/XTCE/20180204"')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SpaceSystemType'
        rootClass = SpaceSystemType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from xtce import *\n\n')
        sys.stdout.write('import xtce as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    # import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://www.omg.org/spec/XTCE/20180204': [('ReferenceLocationType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('ReferencePointType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('TelemetryDataSourceType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('TimeWindowIsRelativeToType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('TimeAssociationUnitType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('VerifierEnumerationType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('FlagBitType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('PCMType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('BitOrderType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('CharacterWidthType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('EpochType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('FloatEncodingSizeInBitsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('FloatEncodingType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('FloatSizeInBitsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('IntegerEncodingType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('ParityFormType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('StringEncodingType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('EpochTimeEnumsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('AuthorType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('BinaryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('ByteOrderType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('ByteOrderCommonType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('ByteOrderArbitraryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('ComparisonOperatorsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('FixedIntegerValueType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('HexadecimalType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('HistoryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('LongDescriptionType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('MathOperatorsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('NameType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('NameReferenceType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('NoteType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('OctalType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('RadixType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('RangeFormType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('RelativeTimeType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('ShortDescriptionType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('TimeUnitsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('ValidationStatusType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('BasisType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('ChangeBasisType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('ConcernLevelsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('ConsequenceLevelType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('ChangeSpanType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('FloatingPointNotationType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('NonNegativeLongType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('PositiveLongType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('UnitFormType',
                                                                      '../SpaceSystem.xsd',
                                                                      'ST'),
                                                                     ('SpaceSystemType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('CommandMetaDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('TelemetryMetaDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentArgumentRefEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentArrayArgumentRefEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentArrayParameterRefEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentContainerRefEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentContainerSegmentRefEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentFixedValueEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentIndirectParameterRefEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentParameterRefEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentParameterSegmentRefEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentStreamSegmentEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArrayParameterRefEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BaseAlarmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BaseContainerType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ContainerType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ContainerRefSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ContainerRefType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ContainerRefEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ContainerSegmentRefEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ContainerSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('EntryListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('IndirectParameterRefEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('LocationInContainerInBitsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentLocationInContainerInBitsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('MessageRefType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ParameterRefEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ParameterSegmentRefEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('SequenceContainerType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('SequenceEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentSequenceEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ServiceType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('StreamSegmentEntryType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('MessageType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('MessageSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('RateInStreamSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('RateInStreamType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('RateInStreamWithStreamNameType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('RestrictionCriteriaType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AbsoluteTimeParameterType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AggregateParameterType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArrayParameterType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BinaryParameterType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BooleanParameterType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('EnumeratedParameterType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('EnumerationContextAlarmListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('FloatParameterType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('IntegerParameterType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('MessageRefSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('NumericContextAlarmListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ParameterInstanceRefType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ParameterPropertiesType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ParameterType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ParameterTypeSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ParameterRefType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('PhysicalAddressSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('PhysicalAddressType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ServiceSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('StringParameterType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('RelativeTimeParameterType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('TimeAssociationType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AbsoluteTimeArgumentType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArrayArgumentType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AggregateArgumentType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentAssignmentListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentAssignmentType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentComparisonType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentComparisonCheckType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentComparisonListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentDiscreteLookupType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentDiscreteLookupListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentDynamicValueType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentInputAlgorithmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentInputSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentInstanceRefType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentBooleanExpressionType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentANDedConditionsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentORedConditionsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentMatchCriteriaType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentTypeSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BaseMetaCommandType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BinaryArgumentType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BlockMetaCommandType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BooleanArgumentType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('CommandContainerEntryListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('CommandContainerSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('CommandContainerType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('CommandVerifierType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('EnumeratedArgumentType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('FloatArgumentType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('IntegerArgumentType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('MetaCommandSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('MetaCommandStepListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('MetaCommandStepType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('MetaCommandType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('RelativeTimeArgumentType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('SignificanceType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('StringArgumentType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AcceptedVerifierType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('CheckWindowType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('CheckWindowAlgorithmsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('CompleteVerifierType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ContextSignificanceType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ContextSignificanceListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ExecutionVerifierType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('FailedVerifierType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('InterlockType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ParameterToSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ParameterToSetListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ParameterToSuspendAlarmsOnType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ParametersToSuspendAlarmsOnSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ParameterValueChangeType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('QueuedVerifierType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ReceivedVerifierType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('SentFromRangeVerifierType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('TransferredToRangeVerifierType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('TransmissionConstraintType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('TransmissionConstraintListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('VerifierSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AlgorithmTextType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BaseTriggerType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ChecksumType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ConstantType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ContextCalibratorListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ExternalAlgorithmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ExternalAlgorithmSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('InputAlgorithmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('InputOutputAlgorithmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('InputOutputTriggerAlgorithmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('InputParameterInstanceRefType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('InputSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('MathAlgorithmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('OnContainerUpdateTriggerType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('OnPeriodicRateTriggerType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('OnParameterUpdateTriggerType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('OutputParameterRefType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('OutputSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('SimpleAlgorithmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('TriggeredMathOperationType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('TriggerSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BaseCalibratorType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('CalibratorType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ChangeValueType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('MathOperationCalibratorType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('PolynomialCalibratorType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('SplineCalibratorType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AutoInvertType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('CustomStreamType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('FlagType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('FrameStreamType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('FixedFrameStreamType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('FixedFrameSyncStrategyType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('PCMStreamType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('StreamRefType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('StreamSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('SyncStrategyType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('SyncPatternType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('VariableFrameStreamType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('VariableFrameSyncStrategyType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentAbsoluteTimeDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AbsoluteTimeDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AggregateDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArrayDataTypeType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BaseDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentBaseDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentBaseTimeDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BaseTimeDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentBinaryDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BinaryDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentBooleanDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BooleanDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('DimensionType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentDimensionType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('DimensionListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentDimensionListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentEnumeratedDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('EnumeratedDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('EnumerationListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentFloatDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('FloatDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentIntegerDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('IntegerDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('MemberType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('MemberListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentRelativeTimeDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('RelativeTimeDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentStringDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('StringDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('UnitSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ValidFloatRangeSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ValidIntegerRangeSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentBinaryDataEncodingType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BinaryDataEncodingType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ByteType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('CRCType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('DataEncodingType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('EncodingType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('FloatDataEncodingType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('IntegerDataEncodingType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('LeadingSizeType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ParityType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('SizeInBitsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentVariableStringType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('VariableStringType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentStringDataEncodingType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('StringDataEncodingType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ToStringType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AlgorithmSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AliasSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AliasType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AncillaryDataType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AncillaryDataSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ANDedConditionsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AuthorSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BaseConditionsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BooleanExpressionType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ComparisonCheckType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ComparisonListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ComparisonType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ContextCalibratorType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ContextMatchType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('CustomAlarmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('PercentCompleteType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('DescriptionType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('DiscreteLookupListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('DynamicValueType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ErrorDetectCorrectType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('HeaderType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('HistorySetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('IntegerValueType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentIntegerValueType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('MatchCriteriaType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('MathOperationType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('NameDescriptionType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('NoteSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('NumberFormatType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('OptionalNameDescriptionType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ORedConditionsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ParameterSetType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ReferenceTimeType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('RepeatType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ArgumentRepeatType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ServiceRefType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('SplinePointType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('TermType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('UnitType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ValueEnumerationType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AlarmConditionsType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AlarmRangesType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AlarmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('AlarmMultiRangesType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BinaryAlarmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BooleanAlarmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BinaryContextAlarmListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BinaryContextAlarmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BooleanContextAlarmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('BooleanContextAlarmListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('ChangeAlarmRangesType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('DiscreteLookupType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('EnumerationAlarmLevelType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('EnumerationAlarmListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('EnumerationContextAlarmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('EnumerationAlarmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('FloatRangeType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('IntegerRangeType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('LinearAdjustmentType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('MultiRangeType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('NumericAlarmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('NumericContextAlarmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('StringAlarmLevelType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('StringAlarmListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('StringAlarmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('StringContextAlarmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('StringContextAlarmListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('TimeAlarmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('TimeAlarmRangesType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('TimeContextAlarmListType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT'),
                                                                     ('TimeContextAlarmType',
                                                                      '../SpaceSystem.xsd',
                                                                      'CT')],
                           'http://www.w3.org/XML/1998/namespace': []}

__all__ = [
    "ANDedConditionsType",
    "AbsoluteTimeArgumentType",
    "AbsoluteTimeDataType",
    "AbsoluteTimeParameterType",
    "AcceptedVerifierType",
    "AggregateArgumentType",
    "AggregateDataType",
    "AggregateParameterType",
    "AlarmConditionsType",
    "AlarmMultiRangesType",
    "AlarmRangesType",
    "AlarmType",
    "AlgorithmSetType",
    "AlgorithmTextType",
    "AliasSetType",
    "AliasType",
    "AncillaryDataSetType",
    "AncillaryDataType",
    "ArgumentANDedConditionsType",
    "ArgumentAbsoluteTimeDataType",
    "ArgumentArgumentRefEntryType",
    "ArgumentArrayArgumentRefEntryType",
    "ArgumentArrayParameterRefEntryType",
    "ArgumentAssignmentListType",
    "ArgumentAssignmentType",
    "ArgumentBaseDataType",
    "ArgumentBaseTimeDataType",
    "ArgumentBinaryDataEncodingType",
    "ArgumentBinaryDataType",
    "ArgumentBooleanDataType",
    "ArgumentBooleanExpressionType",
    "ArgumentComparisonCheckType",
    "ArgumentComparisonListType",
    "ArgumentComparisonType",
    "ArgumentContainerRefEntryType",
    "ArgumentContainerSegmentRefEntryType",
    "ArgumentDimensionListType",
    "ArgumentDimensionType",
    "ArgumentDiscreteLookupListType",
    "ArgumentDiscreteLookupType",
    "ArgumentDynamicValueType",
    "ArgumentEnumeratedDataType",
    "ArgumentFixedValueEntryType",
    "ArgumentFloatDataType",
    "ArgumentIndirectParameterRefEntryType",
    "ArgumentInputAlgorithmType",
    "ArgumentInputSetType",
    "ArgumentInstanceRefType",
    "ArgumentIntegerDataType",
    "ArgumentIntegerValueType",
    "ArgumentListType",
    "ArgumentLocationInContainerInBitsType",
    "ArgumentMatchCriteriaType",
    "ArgumentORedConditionsType",
    "ArgumentParameterRefEntryType",
    "ArgumentParameterSegmentRefEntryType",
    "ArgumentRelativeTimeDataType",
    "ArgumentRepeatType",
    "ArgumentSequenceEntryType",
    "ArgumentStreamSegmentEntryType",
    "ArgumentStringDataEncodingType",
    "ArgumentStringDataType",
    "ArgumentType",
    "ArgumentTypeSetType",
    "ArgumentVariableStringType",
    "ArrayArgumentType",
    "ArrayDataTypeType",
    "ArrayParameterRefEntryType",
    "ArrayParameterType",
    "AuthorSetType",
    "AutoInvertType",
    "BaseAlarmType",
    "BaseCalibratorType",
    "BaseConditionsType",
    "BaseContainerType",
    "BaseDataType",
    "BaseMetaCommandType",
    "BaseTimeDataType",
    "BaseTriggerType",
    "BinaryAlarmType",
    "BinaryArgumentType",
    "BinaryContextAlarmListType",
    "BinaryContextAlarmType",
    "BinaryDataEncodingType",
    "BinaryDataType",
    "BinaryParameterType",
    "BlockMetaCommandType",
    "BooleanAlarmType",
    "BooleanArgumentType",
    "BooleanContextAlarmListType",
    "BooleanContextAlarmType",
    "BooleanDataType",
    "BooleanExpressionType",
    "BooleanParameterType",
    "ByteType",
    "CRCType",
    "CalibratorType",
    "ChangeAlarmRangesType",
    "ChangeValueType",
    "CheckWindowAlgorithmsType",
    "CheckWindowType",
    "ChecksumType",
    "CommandContainerEntryListType",
    "CommandContainerSetType",
    "CommandContainerType",
    "CommandMetaDataType",
    "CommandVerifierType",
    "ComparisonCheckType",
    "ComparisonListType",
    "ComparisonType",
    "CompleteVerifierType",
    "ConstantType",
    "ContainerRefEntryType",
    "ContainerRefSetType",
    "ContainerRefType",
    "ContainerSegmentRefEntryType",
    "ContainerSetType",
    "ContainerType",
    "ContextCalibratorListType",
    "ContextCalibratorType",
    "ContextMatchType",
    "ContextSignificanceListType",
    "ContextSignificanceType",
    "CustomAlarmType",
    "CustomStreamType",
    "DataEncodingType",
    "DescriptionType",
    "DimensionListType",
    "DimensionType",
    "DiscreteLookupListType",
    "DiscreteLookupType",
    "DynamicValueType",
    "EncodingType",
    "EntryListType",
    "EnumeratedArgumentType",
    "EnumeratedDataType",
    "EnumeratedParameterType",
    "EnumerationAlarmLevelType",
    "EnumerationAlarmListType",
    "EnumerationAlarmType",
    "EnumerationContextAlarmListType",
    "EnumerationContextAlarmType",
    "EnumerationListType",
    "ErrorDetectCorrectType",
    "ExecutionVerifierType",
    "ExternalAlgorithmSetType",
    "ExternalAlgorithmType",
    "FailedVerifierType",
    "FixedFrameStreamType",
    "FixedFrameSyncStrategyType",
    "FixedType",
    "FlagType",
    "FloatArgumentType",
    "FloatDataEncodingType",
    "FloatDataType",
    "FloatParameterType",
    "FloatRangeType",
    "FrameStreamType",
    "HeaderType",
    "HistorySetType",
    "IndirectParameterRefEntryType",
    "InputAlgorithmType",
    "InputOutputAlgorithmType",
    "InputOutputTriggerAlgorithmType",
    "InputParameterInstanceRefType",
    "InputSetType",
    "IntegerArgumentType",
    "IntegerDataEncodingType",
    "IntegerDataType",
    "IntegerParameterType",
    "IntegerRangeType",
    "IntegerValueType",
    "InterlockType",
    "LeadingSizeType",
    "LinearAdjustmentType",
    "LocationInContainerInBitsType",
    "MatchCriteriaType",
    "MathAlgorithmType",
    "MathOperationCalibratorType",
    "MathOperationType",
    "MemberListType",
    "MemberType",
    "MessageRefSetType",
    "MessageRefType",
    "MessageSetType",
    "MessageType",
    "MetaCommandSetType",
    "MetaCommandStepListType",
    "MetaCommandStepType",
    "MetaCommandType",
    "MultiRangeType",
    "NameDescriptionType",
    "NoteSetType",
    "NumberFormatType",
    "NumericAlarmType",
    "NumericContextAlarmListType",
    "NumericContextAlarmType",
    "ORedConditionsType",
    "OnContainerUpdateTriggerType",
    "OnParameterUpdateTriggerType",
    "OnPeriodicRateTriggerType",
    "OptionalNameDescriptionType",
    "OutputParameterRefType",
    "OutputSetType",
    "PCMStreamType",
    "ParameterInstanceRefType",
    "ParameterPropertiesType",
    "ParameterRefEntryType",
    "ParameterRefType",
    "ParameterSegmentRefEntryType",
    "ParameterSetType",
    "ParameterToSetListType",
    "ParameterToSetType",
    "ParameterToSuspendAlarmsOnType",
    "ParameterType",
    "ParameterTypeSetType",
    "ParameterValueChangeType",
    "ParametersToSuspendAlarmsOnSetType",
    "ParityType",
    "PercentCompleteType",
    "PhysicalAddressSetType",
    "PhysicalAddressType",
    "PolynomialCalibratorType",
    "QueuedVerifierType",
    "RateInStreamSetType",
    "RateInStreamType",
    "RateInStreamWithStreamNameType",
    "ReceivedVerifierType",
    "ReferenceTimeType",
    "RelativeTimeArgumentType",
    "RelativeTimeDataType",
    "RelativeTimeParameterType",
    "RepeatType",
    "RestrictionCriteriaType",
    "SentFromRangeVerifierType",
    "SequenceContainerType",
    "SequenceEntryType",
    "ServiceRefType",
    "ServiceSetType",
    "ServiceType",
    "SignificanceType",
    "SimpleAlgorithmType",
    "SizeInBitsType",
    "SpaceSystemType",
    "SplineCalibratorType",
    "SplinePointType",
    "StreamRefType",
    "StreamSegmentEntryType",
    "StreamSetType",
    "StringAlarmLevelType",
    "StringAlarmListType",
    "StringAlarmType",
    "StringArgumentType",
    "StringContextAlarmListType",
    "StringContextAlarmType",
    "StringDataEncodingType",
    "StringDataType",
    "StringParameterType",
    "SyncPatternType",
    "SyncStrategyType",
    "TelemetryMetaDataType",
    "TermType",
    "TimeAlarmRangesType",
    "TimeAlarmType",
    "TimeAssociationType",
    "TimeContextAlarmListType",
    "TimeContextAlarmType",
    "ToStringType",
    "TransferredToRangeVerifierType",
    "TransmissionConstraintListType",
    "TransmissionConstraintType",
    "TriggerSetType",
    "TriggeredMathOperationType",
    "UnitSetType",
    "UnitType",
    "ValidFloatRangeSetType",
    "ValidIntegerRangeSetType",
    "ValidRangeType",
    "ValidRangeType1",
    "ValueEnumerationType",
    "VariableFrameStreamType",
    "VariableFrameSyncStrategyType",
    "VariableStringType",
    "VerifierSetType"
]
